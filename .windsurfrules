# Fixture Monkey Development Rules

## Documentation Improvement Guidelines

When working on Fixture Monkey documentation modifications:
- You are a user who is new to Fixture Monkey
- You know what Fixture Monkey library does but don't know how to use it well
- You have basic Java and Kotlin knowledge
- You want to use Fixture Monkey for writing tests
- You only need information necessary for writing tests
- You don't need to know information that's not required for writing tests
- Maintain this perspective when suggesting documentation improvements
- Content should be ordered by helpfulness for your understanding
- Always update both English and Korean documentation together:
  - English docs are in `docs/content/v1.1.x/docs`
  - Korean docs are in `docs/content/v1.1.x-kor/docs`

## Good First Issue (GFI) Creation Guidelines

### Overview
This section provides guidelines for creating Good First Issue (GFI) issues in the naver/fixture-monkey repository. It helps create well-structured, beginner-friendly issues that follow established patterns and encourage community contribution.

### Example GFI Issue Template

**Title**: Add DoubleCombinableArbitrary for easy double customization

**Summary**
Add a `DoubleCombinableArbitrary` interface to provide fluent API for customizing double values, similar to existing `StringCombinableArbitrary`.

**Description**
Currently, customizing double values in Fixture Monkey requires verbose `Arbitraries` calls:
```java
// Current approach - verbose and not intuitive
fixtureMonkey.giveMeBuilder(Product.class)
    .set("price", Arbitraries.doubles().between(10.0, 1000.0).greaterThan(0))
```

Following the successful pattern established in PR #1179 (StringCombinableArbitrary), we should add a `DoubleCombinableArbitrary` interface that provides:
- `positive()` - generates positive doubles
- `negative()` - generates negative doubles
- `between(min, max)` - generates doubles within range
- `greaterThan(value)` - generates doubles greater than value
- `lessThan(value)` - generates doubles less than value

**Expected Usage**
```java
// After implementation - clean and intuitive
fixtureMonkey.giveMeBuilder(Product.class)
    .set("price", CombinableArbitrary.doubles().positive().between(10.0, 1000.0))
    .set("discount", CombinableArbitrary.doubles().between(0.0, 1.0))
```

**Implementation Hints**
1. Study `StringCombinableArbitrary` interface and implementation
2. Create `DoubleCombinableArbitrary` interface with double-specific methods
3. Implement `DoubleCombinableArbitraryDelegator` for filtering operations
4. Add factory method in `CombinableArbitrary` class
5. Add ServiceLoader configuration and tests

**Files to Reference**
- `fixture-monkey-api/src/main/java/com/navercorp/fixturemonkey/api/arbitrary/StringCombinableArbitrary.java`
- `fixture-monkey/src/main/java/com/navercorp/fixturemonkey/arbitrary/StringCombinableArbitraryDelegator.java`
- `fixture-monkey-api/src/main/java/com/navercorp/fixturemonkey/api/arbitrary/CombinableArbitrary.java`

**Good First Issue Because**
This is perfect for beginners because it follows an established pattern with clear examples. You'll learn about Fixture Monkey's architecture while implementing a useful feature that many users will benefit from.

**If you're interested**
1. Comment below to let us know you'd like to work on this
2. Study the referenced files to understand the pattern
3. Ask questions if anything is unclear - we're here to help! üöÄ

### GFI Issue Structure Guidelines

#### Title Format
- Use clear, action-oriented titles: "Add [Feature] for [Purpose]"
- Keep it concise and specific to the feature being implemented
- Examples:
  - "Add DoubleCombinableArbitrary for easy double customization"
  - "Add validation support for @Email annotation"
  - "Add Kotlin extension functions for ArbitraryBuilder"

#### Required Sections

1. **Summary**
   - One sentence describing what needs to be added
   - Reference existing similar functionality when applicable
   - Keep it simple and clear
   - Focus on the value proposition

2. **Description**
   - Explain current limitations or pain points
   - Reference successful precedents when available
   - List 3-5 key features/methods to implement
   - Use bullet points for clarity
   - Show the problem this solves

3. **Expected Usage**
   - Provide before/after code examples
   - Show 2-3 realistic usage scenarios
   - Use simple, understandable examples
   - Demonstrate the improvement in developer experience

4. **Implementation Hints**
   - List 5 high-level steps
   - Reference specific files to look at
   - Don't provide detailed implementation
   - Focus on pattern-following approach
   - Guide without micromanaging

5. **Files to Reference**
   - List key files that show similar patterns
   - Include both interface and implementation examples
   - Mention test files for reference
   - Help contributors understand the codebase structure

6. **Good First Issue Because**
   - Explain why it's suitable for beginners
   - Emphasize pattern-following nature
   - Mention available examples and support
   - Highlight learning opportunities

7. **If you're interested**
   - Simple 3-step process for contributors
   - Encourage questions and engagement
   - Create welcoming atmosphere
   - Provide clear next steps

### Key Principles for GFI Issues

#### Simplicity
- Avoid overwhelming technical details
- Focus on pattern-following rather than innovation
- Provide clear direction without micromanaging
- Break complex features into smaller, manageable pieces

#### Clarity
- Use consistent terminology throughout
- Provide concrete, runnable examples
- Reference existing successful implementations
- Explain the "why" behind the feature

#### Accessibility
- Assume basic Java/Kotlin knowledge only
- Explain architectural concepts briefly
- Encourage questions and learning
- Provide multiple entry points for understanding

#### Scope Management
- Focus on single feature implementation
- Avoid complex cross-cutting concerns
- Keep the scope well-defined and achievable
- Ensure the issue can be completed in reasonable time

### Common Patterns to Reference

#### API Enhancement Patterns
When creating issues for new API features:
1. Always reference similar existing functionality
2. Identify type-specific or domain-specific methods
3. Follow established naming conventions
4. Include both interface and implementation
5. Add comprehensive test coverage

#### Plugin Development Patterns
For plugin-related issues:
1. Reference existing plugin implementations
2. Identify integration points clearly
3. Specify configuration requirements
4. Include both positive and negative test cases
5. Document plugin lifecycle considerations

#### Documentation Patterns
For documentation improvements:
1. Identify gaps in current documentation
2. Reference well-documented similar features
3. Specify target audience clearly
4. Include code examples and use cases
5. Consider multiple learning styles

### Labels and Metadata
- Always include: `enhancement`, `good first issue`
- Add relevant domain labels: `api`, `plugin`, `documentation`, etc.
- Consider difficulty labels: `beginner-friendly`, `intermediate`
- Don't assign to specific milestones initially
- Let maintainers handle assignee decisions

### Common Pitfalls to Avoid
- Don't provide too much implementation detail
- Don't assume advanced knowledge of the codebase
- Don't create issues that are too broad or too narrow
- Don't forget to reference successful precedents
- Don't skip the "why this is good for beginners" explanation
- Don't make the scope too ambitious for a first contribution

### Quality Checklist
- [ ] Title is clear and action-oriented
- [ ] References existing patterns when applicable
- [ ] Provides concrete usage examples
- [ ] Lists implementation hints without being prescriptive
- [ ] Explains why it's suitable for beginners
- [ ] Includes proper labels
- [ ] Encourages contributor engagement
- [ ] Maintains appropriate scope for a first contribution
- [ ] Shows clear value proposition
- [ ] Provides multiple reference points for learning

### Creating Your GFI Issue

#### Step 1: Identify the Opportunity
- Look for repetitive patterns in the codebase
- Find areas where developer experience could be improved
- Identify missing features that follow existing patterns
- Consider community feedback and feature requests

#### Step 2: Research Existing Patterns
- Find similar implementations in the codebase
- Study the architecture and naming conventions
- Understand the testing patterns
- Identify integration points

#### Step 3: Draft the Issue
- Start with the example template above
- Customize for your specific feature
- Focus on the developer experience improvement
- Keep the scope manageable

#### Step 4: Review and Refine
- Check against the quality checklist
- Ensure examples are clear and runnable
- Verify the scope is appropriate for beginners
- Add encouraging and welcoming language

Remember: The goal is to create issues that are both valuable to the project and achievable for newcomers. Focus on clear communication, helpful examples, and supportive guidance.

## Test Writing Guidelines

### Overview
This section provides comprehensive guidelines for writing effective tests using Fixture Monkey, helping developers choose the right patterns and avoid common pitfalls when generating test data.

### When to Use Fixture Monkey

#### Use Fixture Monkey When:
- Creating test objects with complex nested structures
- Need random but valid test data for property-based testing
- Want to reduce boilerplate test setup code
- Testing with multiple variations of the same object type
- Working with objects that have many optional fields

#### Don't Use Fixture Monkey When:
- Testing specific edge cases that require exact values
- Simple objects with only 1-2 fields
- Testing null/empty scenarios specifically
- Performance-critical test scenarios where object creation overhead matters

### FixtureMonkey Instance Creation Patterns

#### Basic Setup (Java)
```java
// For simple cases - use default configuration
FixtureMonkey fixtureMonkey = FixtureMonkey.create();

// For Lombok projects - use ConstructorProperties
FixtureMonkey fixtureMonkey = FixtureMonkey.builder()
    .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE)
    .defaultNotNull(true)
    .build();

// For complex scenarios - add plugins and customizations
FixtureMonkey fixtureMonkey = FixtureMonkey.builder()
    .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE)
    .plugin(new JavaxValidationPlugin())
    .defaultNotNull(true)
    .register(User.class, fm -> fm.giveMeBuilder(User.class)
        .set("email", Arbitraries.strings().withCharset("@").ofMinLength(5)))
    .build();
```

#### Basic Setup (Kotlin)
```kotlin
// For Kotlin projects - always use KotlinPlugin
val fixtureMonkey = FixtureMonkey.builder()
    .plugin(KotlinPlugin())
    .build()

// With additional customizations
val fixtureMonkey = FixtureMonkey.builder()
    .plugin(KotlinPlugin())
    .plugin(KotestPlugin()) // If using Kotest
    .defaultNotNull(true)
    .build()
```

### Method Selection Guide

#### Use `giveMeOne()` When:
- You need a single instance with random values
- No customization required
- Quick and simple object creation

```java
// Simple case
User user = fixtureMonkey.giveMeOne(User.class);

// With generic types
List<String> tags = fixtureMonkey.giveMeOne(new TypeReference<List<String>>() {});
```

#### Use `giveMeBuilder()` When:
- You need to customize specific fields
- Setting constraints or validations
- Working with collections that need specific sizes
- Most common pattern for test scenarios

```java
// Customizing specific fields
Product product = fixtureMonkey.giveMeBuilder(Product.class)
    .set("name", "Test Product")
    .set("price", Arbitraries.longs().greaterThan(0))
    .size("tags", 3)
    .sample();

// Complex nested customization
Order order = fixtureMonkey.giveMeBuilder(Order.class)
    .set("customer.email", "test@example.com")
    .set("items[0].quantity", 5)
    .size("items", 2)
    .sample();
```

#### Use `giveMe()` When:
- You need multiple instances
- Batch testing scenarios
- Property-based testing with multiple samples

```java
// Multiple instances
List<User> users = fixtureMonkey.giveMe(User.class, 10);

// With customization
List<Product> products = fixtureMonkey.giveMeBuilder(Product.class)
    .set("category", "Electronics")
    .sampleList(5);
```

### Common Patterns and Best Practices

#### 1. Field Customization Patterns
```java
// Setting simple values
.set("fieldName", "specificValue")
.set("fieldName", Arbitraries.strings().alpha().ofLength(10))

// Setting nested fields
.set("address.street", "123 Main St")
.set("user.profile.bio", "Test bio")

// Setting collection elements
.set("tags[0]", "important")
.set("items[*].status", "ACTIVE") // All elements

// Setting collection sizes
.size("items", 3)
.size("tags", 1, 5) // Between 1 and 5
```

#### 2. Working with Collections
```java
// List customization
Product product = fixtureMonkey.giveMeBuilder(Product.class)
    .size("reviews", 3)
    .set("reviews[0].rating", 5)
    .set("reviews[1].rating", 4)
    .sample();

// Map customization
User user = fixtureMonkey.giveMeBuilder(User.class)
    .size("preferences", 2)
    .set("preferences.theme", "dark")
    .sample();
```

#### 3. Generic Types
```java
// Simple generic
GenericContainer<String> container = fixtureMonkey.giveMeOne(
    new TypeReference<GenericContainer<String>>() {}
);

// Complex generic with customization
ResponseWrapper<List<Product>> response = fixtureMonkey.giveMeBuilder(
    new TypeReference<ResponseWrapper<List<Product>>>() {}
)
    .set("data", fixtureMonkey.giveMe(Product.class, 3))
    .set("status", "SUCCESS")
    .sample();
```

#### 4. Validation and Constraints
```java
// Using Arbitraries for constraints
User user = fixtureMonkey.giveMeBuilder(User.class)
    .set("age", Arbitraries.integers().between(18, 65))
    .set("email", Arbitraries.strings()
        .withCharset("abcdefghijklmnopqrstuvwxyz@.")
        .ofMinLength(5))
    .set("phone", Arbitraries.strings().numeric().ofLength(10))
    .sample();

// Post-conditions for complex validation
Product product = fixtureMonkey.giveMeBuilder(Product.class)
    .setPostCondition(p -> p.getPrice() > 0 && p.getName() != null)
    .sample();
```

### Test Structure Patterns

#### 1. Single Test Method Pattern
```java
@Test
void shouldCalculateDiscountCorrectly() {
    // given
    FixtureMonkey fixtureMonkey = FixtureMonkey.builder()
        .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE)
        .defaultNotNull(true)
        .build();

    Product product = fixtureMonkey.giveMeBuilder(Product.class)
        .set("price", 1000L)
        .set("category", "ELECTRONICS")
        .sample();

    // when
    double discount = discountService.calculateDiscount(product);

    // then
    assertThat(discount).isEqualTo(100.0);
}
```

#### 2. Test Class with Shared FixtureMonkey
```java
class ProductServiceTest {
    private static final FixtureMonkey fixtureMonkey = FixtureMonkey.builder()
        .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE)
        .defaultNotNull(true)
        .register(Product.class, fm -> fm.giveMeBuilder(Product.class)
            .set("price", Arbitraries.longs().greaterThan(0)))
        .build();

    @Test
    void shouldProcessValidProduct() {
        // given
        Product product = fixtureMonkey.giveMeBuilder(Product.class)
            .set("status", "ACTIVE")
            .sample();

        // when & then
        assertThatNoException().isThrownBy(() ->
            productService.process(product));
    }
}
```

#### 3. Property-Based Testing Pattern
```java
@RepeatedTest(100)
void shouldAlwaysReturnPositivePrice() {
    // given
    Product product = fixtureMonkey.giveMeBuilder(Product.class)
        .set("basePrice", Arbitraries.doubles().greaterThan(0))
        .sample();

    // when
    double finalPrice = pricingService.calculateFinalPrice(product);

    // then
    assertThat(finalPrice).isPositive();
}
```

### Common Mistakes to Avoid

#### 1. Over-customization
```java
// ‚ùå Bad - too much manual setup defeats the purpose
Product product = fixtureMonkey.giveMeBuilder(Product.class)
    .set("id", 1L)
    .set("name", "Test Product")
    .set("description", "Test Description")
    .set("price", 100L)
    .set("category", "TEST")
    .set("createdAt", Instant.now())
    .sample();

// ‚úÖ Good - only customize what's necessary for the test
Product product = fixtureMonkey.giveMeBuilder(Product.class)
    .set("price", 100L) // Only what matters for this test
    .sample();
```

#### 2. Not Using Type References for Generics
```java
// ‚ùå Bad - loses generic type information
List products = fixtureMonkey.giveMeOne(List.class);

// ‚úÖ Good - preserves type safety
List<Product> products = fixtureMonkey.giveMeOne(new TypeReference<List<Product>>() {});
```

#### 3. Creating FixtureMonkey in Every Test
```java
// ‚ùå Bad - repetitive and inefficient
@Test
void test1() {
    FixtureMonkey fm = FixtureMonkey.create();
    // test logic
}

@Test
void test2() {
    FixtureMonkey fm = FixtureMonkey.create();
    // test logic
}

// ‚úÖ Good - shared instance
class MyTest {
    private static final FixtureMonkey fixtureMonkey = FixtureMonkey.create();

    @Test void test1() { /* use fixtureMonkey */ }
    @Test void test2() { /* use fixtureMonkey */ }
}
```

### Framework-Specific Patterns

#### Spring Boot Tests
```java
@SpringBootTest
class UserServiceIntegrationTest {
    private static final FixtureMonkey fixtureMonkey = FixtureMonkey.builder()
        .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE)
        .plugin(new JavaxValidationPlugin())
        .defaultNotNull(true)
        .build();

    @Autowired
    private UserService userService;

    @Test
    void shouldCreateUser() {
        // given
        CreateUserRequest request = fixtureMonkey.giveMeBuilder(CreateUserRequest.class)
            .set("email", "test@example.com")
            .sample();

        // when & then
        assertThatNoException().isThrownBy(() -> userService.createUser(request));
    }
}
```

#### JPA Entity Testing
```java
@DataJpaTest
class UserRepositoryTest {
    private static final FixtureMonkey fixtureMonkey = FixtureMonkey.builder()
        .objectIntrospector(FieldReflectionArbitraryIntrospector.INSTANCE)
        .defaultNotNull(true)
        .build();

    @Test
    void shouldSaveUser() {
        // given
        User user = fixtureMonkey.giveMeBuilder(User.class)
            .setNull("id") // Let JPA generate ID
            .set("email", "unique@example.com")
            .sample();

        // when
        User saved = userRepository.save(user);

        // then
        assertThat(saved.getId()).isNotNull();
    }
}
```

### Performance Considerations

#### 1. Reuse FixtureMonkey Instances
```java
// ‚úÖ Good - static instance for reuse
private static final FixtureMonkey fixtureMonkey = FixtureMonkey.builder()
    .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE)
    .build();
```

#### 2. Use Appropriate Sample Sizes
```java
// ‚úÖ Good - reasonable sample size for property testing
@RepeatedTest(10) // Not 1000 unless necessary
void propertyTest() {
    Product product = fixtureMonkey.giveMeOne(Product.class);
    // test logic
}
```

#### 3. Cache Complex Builders
```java
// ‚úÖ Good - cache expensive builder configurations
private static final ArbitraryBuilder<ComplexObject> COMPLEX_BUILDER =
    fixtureMonkey.giveMeBuilder(ComplexObject.class)
        .set("field1", "value1")
        .set("field2", Arbitraries.strings().alpha())
        .size("collection", 5);

@Test
void test() {
    ComplexObject obj = COMPLEX_BUILDER.sample();
    // test logic
}
```

### Troubleshooting Common Issues

#### 1. Null Values in Required Fields
```java
// Problem: Getting null values unexpectedly
// Solution: Use defaultNotNull(true) or set specific fields
FixtureMonkey fixtureMonkey = FixtureMonkey.builder()
    .defaultNotNull(true)
    .build();
```

#### 2. Validation Errors
```java
// Problem: Generated objects fail validation
// Solution: Use JavaxValidationPlugin and set constraints
FixtureMonkey fixtureMonkey = FixtureMonkey.builder()
    .plugin(new JavaxValidationPlugin())
    .build();
```

#### 3. Complex Object Creation Failures
```java
// Problem: Cannot create objects with complex constructors
// Solution: Use appropriate introspector
FixtureMonkey fixtureMonkey = FixtureMonkey.builder()
    .objectIntrospector(new FailoverIntrospector(
        ConstructorPropertiesArbitraryIntrospector.INSTANCE,
        FieldReflectionArbitraryIntrospector.INSTANCE,
        BeanArbitraryIntrospector.INSTANCE
    ))
    .build();
```

### Quick Reference

#### Method Cheat Sheet
- `giveMeOne(Class)` ‚Üí Single random instance
- `giveMeBuilder(Class)` ‚Üí Customizable builder
- `giveMe(Class, count)` ‚Üí Multiple instances
- `.set(field, value)` ‚Üí Set specific field
- `.size(collection, size)` ‚Üí Set collection size
- `.setNull(field)` ‚Üí Explicitly set null
- `.sample()` ‚Üí Generate final instance
- `.sampleList(count)` ‚Üí Generate multiple from builder

#### Common Arbitraries
- `Arbitraries.strings().alpha().ofLength(10)` ‚Üí Alphabetic strings
- `Arbitraries.integers().between(1, 100)` ‚Üí Bounded integers
- `Arbitraries.doubles().greaterThan(0)` ‚Üí Positive doubles
- `Arbitraries.of("A", "B", "C")` ‚Üí From specific values

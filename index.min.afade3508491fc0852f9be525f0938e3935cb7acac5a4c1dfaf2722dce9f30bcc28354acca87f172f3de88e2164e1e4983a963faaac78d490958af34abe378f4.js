var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",resolution:9,minlength:3,optimize:!0,fastupdate:!0,cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/v1-1-0/docs/introduction/",title:"Introduction",description:"",content:""}),e.add({id:1,href:"/v1-1-0/docs/migration-guide/migration-guide/",title:"From 1.0.x",description:`Create an instance of the Kotlin type # In 1.0.x, when you apply the KotlinPlugin, Java and Kotlin types are created by the PrimaryConstructorArbitraryIntrospector, which uses the Kotlin primary constructor by default. Creating a Java type with it causes the exception.
As of 1.1.x, when you apply the KotlinPlugin, Java types are created by the BeanArbitraryIntrospector, Kotlin types are created by the PrimaryConstructorArbitraryIntrospector.
Different ArbitraryBuilder APIs between Java and Kotlin # In 1.0.x, Java and Kotlin use the same API in ArbitraryBuilder.
`,content:`Create an instance of the Kotlin type # In 1.0.x, when you apply the KotlinPlugin, Java and Kotlin types are created by the PrimaryConstructorArbitraryIntrospector, which uses the Kotlin primary constructor by default. Creating a Java type with it causes the exception.
As of 1.1.x, when you apply the KotlinPlugin, Java types are created by the BeanArbitraryIntrospector, Kotlin types are created by the PrimaryConstructorArbitraryIntrospector.
Different ArbitraryBuilder APIs between Java and Kotlin # In 1.0.x, Java and Kotlin use the same API in ArbitraryBuilder.
As of 1.1.x, Fixture Monkey provides both Java-specific ArbitraryBuilder APIs and Kotlin-specific ArbitraryBuilder APIs. Of course, you can use the Java-specific APIs when creating a Kotlin type, and vice versa.
How to use Java ArbitraryBuilder APIs # To use Java-specific APIs, use FixtureMonkey.giveMeBuilder(Class) or FixtureMonkey.giveMeJavaBuilder(Class).
How to use Kotlin ArbitraryBuilder APIs # To use Kotlin-specific APIs, use the extension function FixtureMonkey.giveMeKotlinBuilder&lt;Class&gt;().
Resolves the implementation of the abstract type # In 1.0.x, You must use the ObjectPropertyGenerator option in order to resolve the actual type of abstract class or interface.
As of 1.1.x, all you have to do is use the CandidateConcretePropertyResolver option. It is much easier.
Let&rsquo;s take the sealed type as an example. To create an instance of a sealed class in JDK 17, you have to use the SealedTypeObjectPropertyGenerator, which is used by default. It forces you to know the properties of ObjectProperty, most of which are not your concern.
public final class SealedTypeObjectPropertyGenerator implements ObjectPropertyGenerator { @Override public ObjectProperty generate(ObjectPropertyGeneratorContext context) { Property sealedTypeProperty = context.getProperty(); double nullInject = context.getNullInjectGenerator().generate(context); Class&lt;?&gt; actualType = Types.getActualType(sealedTypeProperty.getType()); Set&lt;Class&lt;?&gt;&gt; permittedSubclasses = collectPermittedSubclasses(actualType); Map&lt;Property, List&lt;Property&gt;&gt; childPropertiesByProperty = permittedSubclasses.stream() .collect( toUnmodifiableMap( Function.identity(), it -&gt; context.getPropertyGenerator().generateChildProperties(it) ) ); return new ObjectProperty( sealedTypeProperty, context.getPropertyNameResolver(), nullInject, context.getElementIndex(), childPropertiesByProperty ); } private static Set&lt;Class&lt;?&gt;&gt; collectPermittedSubclasses(Class&lt;?&gt; type) { Set&lt;Class&lt;?&gt;&gt; subclasses = new HashSet&lt;&gt;(); doCollectPermittedSubclasses(type, subclasses); return subclasses; } private static void doCollectPermittedSubclasses(Class&lt;?&gt; type, Set&lt;Class&lt;?&gt;&gt; subclasses) { if (type.isSealed()) { for (Class&lt;?&gt; subclass : type.getPermittedSubclasses()) { doCollectPermittedSubclasses(subclass, subclasses); } } else { subclasses.add(type); } } } As of 1.1.x, you can only focus on the resolved implementation types.
public final class SealedTypeCandidateConcretePropertyResolver implements CandidateConcretePropertyResolver { @Override public List&lt;Property&gt; resolve(Property property) { Class&lt;?&gt; actualType = Types.getActualType(property.getType()); Set&lt;Class&lt;?&gt;&gt; permittedSubclasses = collectPermittedSubclasses(actualType); return permittedSubclasses.stream() .map(PropertyUtils::toProperty) .toList(); } private static Set&lt;Class&lt;?&gt;&gt; collectPermittedSubclasses(Class&lt;?&gt; type) { Set&lt;Class&lt;?&gt;&gt; subclasses = new HashSet&lt;&gt;(); doCollectPermittedSubclasses(type, subclasses); return subclasses; } private static void doCollectPermittedSubclasses(Class&lt;?&gt; type, Set&lt;Class&lt;?&gt;&gt; subclasses) { if (type.isSealed()) { for (Class&lt;?&gt; subclass : type.getPermittedSubclasses()) { doCollectPermittedSubclasses(subclass, subclasses); } } else { subclasses.add(type); } } } `}),e.add({id:2,href:"/v1-1-0/docs/introduction/overview/",title:"Overview",description:`Fixture Monkey # Fixture Monkey is a Java &amp; Kotlin library designed to generate controllable arbitrary test objects.
It focuses on simplifying test writing, by facilitating the generation of necessary test fixtures. Whether you&rsquo;re dealing with basic or complex test fixtures, Fixture Monkey helps you to effortlessly create the test objects you need and easily customize them to match your desired configurations.
Make your JVM tests more concise and safe with Fixture Monkey.
`,content:`Fixture Monkey # Fixture Monkey is a Java &amp; Kotlin library designed to generate controllable arbitrary test objects.
It focuses on simplifying test writing, by facilitating the generation of necessary test fixtures. Whether you&rsquo;re dealing with basic or complex test fixtures, Fixture Monkey helps you to effortlessly create the test objects you need and easily customize them to match your desired configurations.
Make your JVM tests more concise and safe with Fixture Monkey.
Why use Fixture Monkey? # 1. Simplicity # Product actual = fixtureMonkey.giveMeOne(Product.class); Fixture Monkey makes test object generation remarkably easy. With just one line of code, you can effortlessly generate any kind of test object you desire. It simplifies the given section of the test, enabling you to write tests faster and more easily. You also don&rsquo;t need to change the production code or test environment.
2. Reusability # ArbitraryBuilder&lt;Product&gt; actual = fixtureMonkey.giveMeBuilder(Product.class) .set(&quot;id&quot;, 1000L) .set(&quot;productName&quot;, &quot;Book&quot;); Fixture Monkey allows you to reuse configurations of instances across multiple tests, saving you time and effort. Complex specifications only need to be defined once within your builder and can then be reused to obtain instances.
Furthermore, there are additional features that boost reusability. For more details on these features, refer to the sections on &lsquo;Registering Default ArbitraryBuilder&rsquo; and &lsquo;InnerSpec&rsquo;.
3. Randomness # ArbitraryBuilder&lt;Product&gt; actual = fixtureMonkey.giveMeBuilder(Product.class); then(actual.sample()).isNotEqualTo(actual.sample()); Fixture Monkey helps tests become more dynamic by generating test objects with random values. This leads to uncovering edge cases that might remain hidden when using static data.
4. Versatility # // inheritance class Foo { String foo; } class Bar extends Foo { String bar; } Foo foo = FixtureMonkey.create().giveMeOne(Foo.class); Bar bar = FixtureMonkey.create().giveMeOne(Bar.class); // circular-reference class Foo { String value; Foo foo; } Foo foo = FixtureMonkey.create().giveMeOne(Foo.class); // anonymous objects interface Foo { Bar getBar(); } class Bar { String value; } Foo foo = FixtureMonkey.create().giveMeOne(Foo.class); Fixture Monkey is capable to create any kind of object you can imagine. It supports generating basic objects such as lists, nested collections, enums and generic types. It also handles more advanced scenarios, including objects with inheritance relationships, circular-referenced objects, and anonymous objects that implement interfaces.
Proven Effectiveness # Fixture Monkey was originally developed as an in-house library at Naver and played a crucial role in simplifying test object generation for the Plasma project. The Plasma project aimed to revolutionize Naver Pay&rsquo;s architecture, which is the most used mobile payment service in South Korea with a daily active user count of 261,400.
The project required thorough testing of complex business requirements, and with Fixture Monkey&rsquo;s assistance, the team efficiently wrote over 10,000 tests, uncovering critical edge cases and ensuring the system&rsquo;s reliability. Now available as an open-source library, developers worldwide can take advantage of Fixture Monkey to simplify their test codes and build robust applications with confidence.
`}),e.add({id:3,href:"/v1-1-0/docs/get-started/",title:"Getting Started",description:"",content:""}),e.add({id:4,href:"/v1-1-0/docs/get-started/requirements/",title:"Requirements",description:` 💡 Fixture Monkey is designed for test environments. It is not recommended for production use. Prerequisites # JDK 1.8 or higher (Or Kotlin 1.8 or higher) JUnit 5 platform jqwik 1.7.3 Dependencies # Dependency Description fixture-monkey Core library fixture-monkey-starter Starter dependency for fixture monkey fixture-monkey-kotlin Kotlin support fixture-monkey-starter-kotlin Starter dependency for fixture monkey kotlin fixture-monkey-starter is a starter dependency that comes with pre-configured dependencies such as fixture-monkey-jakarta-validation to help you get started using Fixture Monkey.
`,content:` 💡 Fixture Monkey is designed for test environments. It is not recommended for production use. Prerequisites # JDK 1.8 or higher (Or Kotlin 1.8 or higher) JUnit 5 platform jqwik 1.7.3 Dependencies # Dependency Description fixture-monkey Core library fixture-monkey-starter Starter dependency for fixture monkey fixture-monkey-kotlin Kotlin support fixture-monkey-starter-kotlin Starter dependency for fixture monkey kotlin fixture-monkey-starter is a starter dependency that comes with pre-configured dependencies such as fixture-monkey-jakarta-validation to help you get started using Fixture Monkey.
For Kotlin environments, you can use fixture-monkey-starter-kotlin
Gradle # Add junit-platform-launcher as a runtime dependency. The dependency is optional below Gradle 9, but it will be mandatory from Gradle 9 onwards.
📔 Gradle Offical Documentation ⚠️ Issue
testRuntimeOnly(&quot;org.junit.platform:junit-platform-launcher:{version}&quot;) testImplementation(&quot;com.navercorp.fixturemonkey:fixture-monkey-starter:1.1.10&quot;) Maven # &lt;dependency&gt; &lt;groupId&gt;com.navercorp.fixturemonkey&lt;/groupId&gt; &lt;artifactId&gt;fixture-monkey-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; Third party library support # Dependency Description fixture-monkey-jackson Jackson support fixture-monkey-jakarta-validation Jakarta validation support fixture-monkey-javax-validation Javax validation support fixture-monkey-mockito Mockito support fixture-monkey-autoparams Autoparams support `}),e.add({id:5,href:"/v1-1-0/docs/get-started/creating-test-objects/",title:"Creating test objects",description:` Fixture Monkey works in both Java and Kotlin. We have a separate &lsquo;Getting Started&rsquo; page for each environment you can use: Java, Java without Lombok, and Kotlin.
This page explains the Java environment. Please refer to the appropriate page for your environment.
Consider a scenario where you need a test fixture for a Product class, as shown below:
💡 lombok.anyConstructor.addConstructorProperties=true should be added in lombok.config @Value public class Product { long id; String productName; long price; List&lt;String&gt; options; Instant createdAt; ProductType productType; Map&lt;Integer, String&gt; merchantInfo; } (Note that the Lombok annotation @Value is used to make Immutable classes. If you&rsquo;re working in an environment without Lombok, go to creating test objects without lombok)
`,content:` Fixture Monkey works in both Java and Kotlin. We have a separate &lsquo;Getting Started&rsquo; page for each environment you can use: Java, Java without Lombok, and Kotlin.
This page explains the Java environment. Please refer to the appropriate page for your environment.
Consider a scenario where you need a test fixture for a Product class, as shown below:
💡 lombok.anyConstructor.addConstructorProperties=true should be added in lombok.config @Value public class Product { long id; String productName; long price; List&lt;String&gt; options; Instant createdAt; ProductType productType; Map&lt;Integer, String&gt; merchantInfo; } (Note that the Lombok annotation @Value is used to make Immutable classes. If you&rsquo;re working in an environment without Lombok, go to creating test objects without lombok)
With the Fixture Monkey library, generating an instance of Product becomes remarkably simple, requiring just few lines of code.
@Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build(); // when Product actual = fixtureMonkey.giveMeOne(Product.class); // then then(actual).isNotNull(); } First, create a FixtureMonkey instance that facilitates the creation of test fixtures. There are several custom options available in Fixture Monkey that allow you to generate instances according to your specific requirements.
Here we are configuring the objectIntrospector to use ConstructorPropertiesArbitraryIntrospector, which means that the object will be constructed using the constructor annotated with @ConstructorProperties. An Introspector defines how Fixture Monkey generates objects.
For ConstructorPropertiesArbitraryIntrospector, the generated class should have a constructor with @ConstructorProperties or you can add lombok.anyConstructor.addConstructorProperties=true in the lombok.config file. (There are alternative Introspectors available, each with their own requirements. Check out the Introspectors section for more details.)
Next, use the giveMeOne() method with the desired test class type to generate an instance of the specified type.
As evident from the then section, an instance of the Product class is created.
`}),e.add({id:6,href:"/v1-1-0/docs/get-started/creating-test-objects-without-lombok/",title:"Creating test objects without Lombok",description:` 💡 If you're using Lombok in your project, feel free to move on to the next page. Consider a scenario where you need a test fixture for a Product class, as shown below:
public class Product { private long id; private String productName; private long price; private List&lt;String&gt; options; private Instant createdAt; private ProductType productType; private Map&lt;Integer, String&gt; merchantInfo; public Product() { } public void setId(long id) { this.id = id; } public void setProductName(String productName) { this.productName = productName; } public void setPrice(long price) { this.price = price; } public void setOptions(List&lt;String&gt; options) { this.options = options; } public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; } public void setProductType(ProductType productType) { this.productType = productType; } public void setMerchantInfo(Map&lt;Integer, String&gt; merchantInfo) { this.merchantInfo = merchantInfo; } } With the Fixture Monkey library, generating an instance of Product becomes remarkably simple, requiring just few lines of code.
`,content:` 💡 If you're using Lombok in your project, feel free to move on to the next page. Consider a scenario where you need a test fixture for a Product class, as shown below:
public class Product { private long id; private String productName; private long price; private List&lt;String&gt; options; private Instant createdAt; private ProductType productType; private Map&lt;Integer, String&gt; merchantInfo; public Product() { } public void setId(long id) { this.id = id; } public void setProductName(String productName) { this.productName = productName; } public void setPrice(long price) { this.price = price; } public void setOptions(List&lt;String&gt; options) { this.options = options; } public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; } public void setProductType(ProductType productType) { this.productType = productType; } public void setMerchantInfo(Map&lt;Integer, String&gt; merchantInfo) { this.merchantInfo = merchantInfo; } } With the Fixture Monkey library, generating an instance of Product becomes remarkably simple, requiring just few lines of code.
@Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.create(); // when Product actual = fixtureMonkey.giveMeOne(Product.class); // then then(actual).isNotNull(); } First, create a FixtureMonkey instance that facilitates the creation of test fixtures. You can use create() to generate a Fixture Monkey instance with default options. There are also several custom options available in Fixture Monkey that allow you to generate instances according to your specific requirements.
Fixture Monkey uses BeanArbitraryIntrospector as its default method for generating objects. An Introspector defines how Fixture Monkey generates objects.
For BeanArbitraryIntrospector, the class being generated needs to have a no-args constructor and setters. (There are alternative Introspectors available, each with their own requirements. Check out the Introspectors section for more details.)
Next, use the giveMeOne() method with the desired test class type to generate an instance of the specified type.
As evident from the then section, an instance of the Product class is created.
`}),e.add({id:7,href:"/v1-1-0/docs/get-started/adding-bean-validation/",title:"Adding Bean Validation",description:`Sometimes, you might want to create a valid test object that adheres to the constraints specified by the Bean Validation annotations on your class.
Fixture Monkey supports constraint annotations from the jakarta.validation.constraints and javax.validation.constraints packages.
To enable this feature, you need to add the fixture-monkey-jakarta-validation dependency (or fixture-monkey-javax-validation if you are using javax.validation.constraints) to your project as follows:
Gradle # testImplementation(&quot;com.navercorp.fixturemonkey:fixture-monkey-jakarta-validation:1.1.10&quot;) Maven # &lt;dependency&gt; &lt;groupId&gt;com.navercorp.fixturemonkey&lt;/groupId&gt; &lt;artifactId&gt;fixture-monkey-jakarta-validation&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; Fixture Monkey provides additional features as plugins.
`,content:`Sometimes, you might want to create a valid test object that adheres to the constraints specified by the Bean Validation annotations on your class.
Fixture Monkey supports constraint annotations from the jakarta.validation.constraints and javax.validation.constraints packages.
To enable this feature, you need to add the fixture-monkey-jakarta-validation dependency (or fixture-monkey-javax-validation if you are using javax.validation.constraints) to your project as follows:
Gradle # testImplementation(&quot;com.navercorp.fixturemonkey:fixture-monkey-jakarta-validation:1.1.10&quot;) Maven # &lt;dependency&gt; &lt;groupId&gt;com.navercorp.fixturemonkey&lt;/groupId&gt; &lt;artifactId&gt;fixture-monkey-jakarta-validation&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; Fixture Monkey provides additional features as plugins.
To generate objects based on Bean Validation annotations, you need to add the JakartaValidationPlugin (or JavaxValidationPlugin if you are using javax.validation.constraints) option to FixtureMonkey as shown below. If you&rsquo;ve added the fixture-monkey-starter dependency, it&rsquo;s already in place.
FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JakartaValidationPlugin()) // or new JavaxValidationPlugin() .build(); Let&rsquo;s assume that we have added several validation annotations to the previous Product class.
@Value public class Product { @Min(1) long id; @NotBlank String productName; @Max(100000) long price; @Size(min = 3) List&lt;@NotBlank String&gt; options; @Past Instant createdAt; } With the FixtureMonkey instance we created earlier, we can now generate valid objects:
@Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .plugin(new JakartaValidationPlugin()) .build(); // when Product actual = fixtureMonkey.giveMeOne(Product.class); // then then(actual).isNotNull(); then(actual.getId()).isGreaterThan(0); then(actual.getProductName()).isNotBlank(); then(actual.getPrice()).isLessThanOrEqualTo(100000); then(actual.getOptions().size()).isGreaterThanOrEqualTo(3); then(actual.getOptions()).allSatisfy(it -&gt; then(it).isNotEmpty()); then(actual.getCreatedAt()).isNotNull().isLessThanOrEqualTo(Instant.now()); } From the assertions, it&rsquo;s clear that the object created with FixtureMonkey meets all the validation annotation requirements.
`}),e.add({id:8,href:"/v1-1-0/docs/get-started/customizing-objects/",title:"Customizing objects",description:`Suppose you need to customize your test fixture for a specific unit test. In that case, you can use Fixture Monkey to generate a builder and further customize it.
@Value public class Product { long id; String productName; long price; List&lt;String&gt; options; Instant createdAt; } For example, for a certain test you might need a Product instance with an id of 1,000.
In order to do this, you can get a type builder from fixture monkey with the giveMeBuilder method. The Builder allows chaining additional method calls to customize your fixture. In this case you can use the set() function to set the id to 1,000. From the Builder use sample() to get an instance from the builder.
`,content:`Suppose you need to customize your test fixture for a specific unit test. In that case, you can use Fixture Monkey to generate a builder and further customize it.
@Value public class Product { long id; String productName; long price; List&lt;String&gt; options; Instant createdAt; } For example, for a certain test you might need a Product instance with an id of 1,000.
In order to do this, you can get a type builder from fixture monkey with the giveMeBuilder method. The Builder allows chaining additional method calls to customize your fixture. In this case you can use the set() function to set the id to 1,000. From the Builder use sample() to get an instance from the builder.
@Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build(); long id = 1000; // when Product actual = fixtureMonkey.giveMeBuilder(Product.class) .set(&quot;id&quot;, id) .sample(); // then then(actual.getId()).isEqualTo(1000); } In the example above, you can see that the field id is set to a value you desire.
You can also use Fixture Monkey to work with fields that are collections. For instance, you might want the list &ldquo;options&rdquo; to have a specific size, and you might want a certain element of it to have a certain value.
@Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build(); // when Product actual = fixtureMonkey.giveMeBuilder(Product.class) .size(&quot;options&quot;, 3) .set(&quot;options[1]&quot;, &quot;red&quot;) .sample(); // then then(actual.getOptions()).hasSize(3); then(actual.getOptions().get(1)).isEqualTo(&quot;red&quot;); } You can specify the size of a certain collection (list, set, map) and set an element to a specific value using the set() function, and then get your instance by calling the sample() method.
For more examples of how to select properties with expressions and set property values, you can go to the customizing section.
`}),e.add({id:9,href:"/v1-1-0/docs/get-started/creating-objects-in-kotlin/",title:"Creating objects in Kotlin",description:`Fixture Monkey also supports generating classes written in Kotlin code.
In order to do this, first make sure you added the fixture-monkey-starter-kotlin dependency.
Then we can add the Kotlin Plugin, to enable additional features of fixture monkey that support using Kotlin.
@Test fun test() { val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .build() } The Kotlin plugin changes the default ObjectIntrospector to PrimaryConstructorArbitraryIntrospector, which generates Kotlin classes with their primary constructor.
`,content:`Fixture Monkey also supports generating classes written in Kotlin code.
In order to do this, first make sure you added the fixture-monkey-starter-kotlin dependency.
Then we can add the Kotlin Plugin, to enable additional features of fixture monkey that support using Kotlin.
@Test fun test() { val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .build() } The Kotlin plugin changes the default ObjectIntrospector to PrimaryConstructorArbitraryIntrospector, which generates Kotlin classes with their primary constructor.
Suppose you have a Kotlin class like this:
data class Product ( val id: Long, val productName: String, val price: Long, val options: List&lt;String&gt;, val createdAt: Instant, val productType: ProductType, val merchantInfo: Map&lt;Int, String&gt; ) You can generate your Kotlin class just like when you did in Java.
If you are writing your test code in Kotlin, one difference is that you can use giveMeOne() without writing the class name, unlike java when you had to write Product.class.
The following code shows how to generate objects in kotlin:
@Test fun test() { // given val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .build() // when val actual: Product = fixtureMonkey.giveMeOne() // then then(actual).isNotNull } The Kotlin plugin also lets you use a new way to reference the property to customize.
@Test fun test() { // given val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .build(); // when val actual = fixtureMonkey.giveMeBuilder&lt;Product&gt;() .setExp(Product::id, 1000L) .sizeExp(Product::options, 3) .setExp(Product::options[1], &quot;red&quot;) .sample() // then then (actual.id).isEqualTo(1000L) then (actual.options).hasSize(3) then (actual.options[1]).isEqualTo(&quot;red&quot;) } Using the setExp() method instead of the set() method, you can specify property assignments using Kotlin&rsquo;s property reference syntax The pages under Kotlin Plugin introduces more features that are provided by the Kotlin plugin.
`}),e.add({id:10,href:"/v1-1-0/docs/generating-objects/",title:"Generating Objects",description:"",content:""}),e.add({id:11,href:"/v1-1-0/docs/generating-objects/fixture-monkey/",title:"FixtureMonkey",description:`To generate test fixtures, the first step is to create a FixtureMonkey instance, which facilitates the creation of test fixtures.
You can use the create() method to generate a FixtureMonkey instance with default options. For Kotlin environments, add the Kotlin plugin.
Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.create(); val fixtureMonkey = FixtureMonkey .plugin(KotlinPlugin()) .build() If you want to add some options for creating or customizing the test fixtures, you can add them using the FixtureMonkey builder.
`,content:`To generate test fixtures, the first step is to create a FixtureMonkey instance, which facilitates the creation of test fixtures.
You can use the create() method to generate a FixtureMonkey instance with default options. For Kotlin environments, add the Kotlin plugin.
Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.create(); val fixtureMonkey = FixtureMonkey .plugin(KotlinPlugin()) .build() If you want to add some options for creating or customizing the test fixtures, you can add them using the FixtureMonkey builder.
Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() + options... .build(); val fixtureMonkey = FixtureMonkey.builder() + options... .build() For information on what options are available, see the Fixture Monkey Options section.
Generating instances # The FixtureMonkey class provides several methods to help create test objects of the required type.
giveMeOne() # If you need an instance of a certain type, you can use giveMeOne(). Pass either a class or a type reference.
Java Kotlin Product product = fixtureMonkey.giveMeOne(Product.class); List&lt;String&gt; strList = fixtureMonkey.giveMeOne(new TypeReference&lt;List&lt;String&gt;&gt;() {}); val product: Product = fixtureMonkey.giveMeOne() val strList: List&lt;String&gt; = fixtureMonkey.giveMeOne() giveMe() # If you need multiple instances of a certain type, you can use the giveMe() method. You can choose to generate either a stream of instances or a list by specifying the desired size.
Java Kotlin Stream&lt;Product&gt; productStream = fixtureMonkey.giveMe(Product.class); Stream&lt;List&lt;String&gt;&gt; strListStream = fixtureMonkey.giveMe(new TypeReference&lt;List&lt;String&gt;&gt;() {}); List&lt;Product&gt; productList = fixtureMonkey.giveMe(Product.class, 3); List&lt;List&lt;String&gt;&gt; strListList = fixtureMonkey.giveMe(new TypeReference&lt;List&lt;String&gt;&gt;() {}, 3); val productSequence: Sequence&lt;Product&gt; = fixtureMonkey.giveMe() val strListSequence: Sequence&lt;List&lt;String&gt;&gt; = fixtureMonkey.giveMe() val productList: List&lt;Product&gt; = fixtureMonkey.giveMe(3) val strListList: List&lt;List&lt;String&gt;&gt; = fixtureMonkey.giveMe(3) giveMeBuilder() # If you need to further customize the instance to be created, you can use giveMeBuilder(). This will return an ArbitraryBuilder of the given type. An ArbitraryBuilder is a class in Fixture Monkey that acts as a builder for an Arbitrary object of the given class.
Java Kotlin ArbitraryBuilder&lt;Product&gt; productBuilder = fixtureMonkey.giveMeBuilder(Product.class); ArbitraryBuilder&lt;List&lt;String&gt;&gt; strListBuilder = fixtureMonkey.giveMeBuilder(new TypeReference&lt;List&lt;String&gt;&gt;() {}); val productBuilder: ArbitraryBuilder&lt;Product&gt; = fixtureMonkey.giveMeBuilder() val strListBuilder: ArbitraryBuilder&lt;List&lt;String&gt;&gt; = fixtureMonkey.giveMeBuilder() For cases where you already have a generated instance and want to customize it further, you can also use giveMeBuilder().
Java Kotlin Product product = new Product(1L, &#34;Book&#34;, ...); ArbitraryBuilder&lt;Product&gt; productBuilder = fixtureMonkey.giveMeBuilder(product); val product = Product(1L, &#34;Book&#34;, ...) val productBuilder = fixtureMonkey.giveMeBuilder(product) The generated ArbitraryBuilder can be used for further customization of your fixture. For more information on customization options, see the section on customization objects.
To obtain an instance from the ArbitraryBuilder, you can use the sample(), sampleList(), sampleStream() methods of the ArbitraryBuilder.
Java Kotlin ArbitraryBuilder&lt;Product&gt; productBuilder = fixtureMonkey.giveMeBuilder(Product.class); Product product = productBuilder.sample(); List&lt;Product&gt; productList = productBuilder.sampleList(3); Stream&lt;Product&gt; productStream = productBuilder.sampleStream(); val productBuilder: ArbitraryBuilder&lt;Product&gt; = fixtureMonkey.giveMeBuilder() val product = productBuilder.sample() val productList = productBuilder.sampleList(3) val productStream = productBuilder.sampleStream() In cases where you need an Arbitrary itself rather than an instance, you can simply call the build() method.
Java Kotlin ArbitraryBuilder&lt;Product&gt; productBuilder = fixtureMonkey.giveMeBuilder(Product.class); Arbitrary&lt;Product&gt; productArbitrary = productBuilder.build(); val productBuilder: ArbitraryBuilder&lt;Product&gt; = fixtureMonkey.giveMeBuilder() val productArbitrary = productBuilder.build() giveMeArbitrary() # To get an Arbitrary of the specified type, you can use the giveMeArbitrary() method.
Java Kotlin Arbitrary&lt;Product&gt; productArbitrary = fixtureMonkey.giveMeArbitrary(Product.class); Arbitrary&lt;List&lt;String&gt;&gt; strListArbitrary = fixtureMonkey.giveMeArbitrary(new TypeReference&lt;List&lt;String&gt;&gt;() {}); val productArbitrary: Arbitrary&lt;Product&gt; = fixtureMonkey.giveMeArbitrary() val strListArbitrary: Arbitrary&lt;List&lt;String&gt;&gt; = fixtureMonkey.giveMeArbitrary() `}),e.add({id:12,href:"/v1-1-0/docs/generating-objects/generating-complex-types/",title:"Generating Complex Types",description:`Fixture Monkey is capable of generating complex objects that are difficult to create as test fixtures.
This page contains examples of the various types of objects that can be generated.
Java # Generic Objects # @Value public static class GenericObject&lt;T&gt; { T foo; } @Value public static class GenericArrayObject&lt;T&gt; { GenericObject&lt;T&gt;[] foo; } @Value public static class TwoGenericObject&lt;T, U&gt; { T foo; U bar; } @Value public static class ThreeGenericObject&lt;T, U, V&gt; { T foo; U bar; V baz; } Generic Interfaces # public interface GenericInterface&lt;T&gt; { } @Value public static class GenericInterfaceImpl&lt;T&gt; implements GenericInterface&lt;T&gt; { T foo; } public interface TwoGenericInterface&lt;T, U&gt; { } @Value public static class TwoGenericImpl&lt;T, U&gt; implements TwoGenericInterface&lt;T, U&gt; { T foo; U bar; } SelfReference # @Value public class SelfReference { String foo; SelfReference bar; } @Value public class SelfReferenceList { String foo; List&lt;SelfReferenceList&gt; bar; } Interface # public interface Interface { String foo(); Integer bar(); } public interface InheritedInterface extends Interface { String foo(); } public interface InheritedInterfaceWithSameNameMethod extends Interface { String foo(); } public interface ContainerInterface { List&lt;String&gt; baz(); Map&lt;String, Integer&gt; qux(); } public interface InheritedTwoInterface extends Interface, ContainerInterface { } Kotlin # Generic Objects # class Generic&lt;T&gt;(val foo: T) class GenericImpl(val foo: Generic&lt;String&gt;) SelfReference # class SelfReference(val foo: String, val bar: SelfReference?) Sealed class, Value class # sealed class SealedClass object ObjectSealedClass : SealedClass() class SealedClassImpl(val foo: String) : SealedClass() @JvmInline value class ValueClass(val foo: String) `,content:`Fixture Monkey is capable of generating complex objects that are difficult to create as test fixtures.
This page contains examples of the various types of objects that can be generated.
Java # Generic Objects # @Value public static class GenericObject&lt;T&gt; { T foo; } @Value public static class GenericArrayObject&lt;T&gt; { GenericObject&lt;T&gt;[] foo; } @Value public static class TwoGenericObject&lt;T, U&gt; { T foo; U bar; } @Value public static class ThreeGenericObject&lt;T, U, V&gt; { T foo; U bar; V baz; } Generic Interfaces # public interface GenericInterface&lt;T&gt; { } @Value public static class GenericInterfaceImpl&lt;T&gt; implements GenericInterface&lt;T&gt; { T foo; } public interface TwoGenericInterface&lt;T, U&gt; { } @Value public static class TwoGenericImpl&lt;T, U&gt; implements TwoGenericInterface&lt;T, U&gt; { T foo; U bar; } SelfReference # @Value public class SelfReference { String foo; SelfReference bar; } @Value public class SelfReferenceList { String foo; List&lt;SelfReferenceList&gt; bar; } Interface # public interface Interface { String foo(); Integer bar(); } public interface InheritedInterface extends Interface { String foo(); } public interface InheritedInterfaceWithSameNameMethod extends Interface { String foo(); } public interface ContainerInterface { List&lt;String&gt; baz(); Map&lt;String, Integer&gt; qux(); } public interface InheritedTwoInterface extends Interface, ContainerInterface { } Kotlin # Generic Objects # class Generic&lt;T&gt;(val foo: T) class GenericImpl(val foo: Generic&lt;String&gt;) SelfReference # class SelfReference(val foo: String, val bar: SelfReference?) Sealed class, Value class # sealed class SealedClass object ObjectSealedClass : SealedClass() class SealedClassImpl(val foo: String) : SealedClass() @JvmInline value class ValueClass(val foo: String) `}),e.add({id:13,href:"/v1-1-0/docs/generating-objects/instantiate-methods/",title:"Instantiate Methods",description:`For each test, you may want to use a different way of creating objects. For example, even within the same class, one test may require initialization using the constructor, while another test may require initialization using its factory method.
Fixture Monkey allows you to choose the preferred method of creating your object through the instantiate() method. 💡 If the Kotlin Plugin is added, you can use the instantiateBy() method with a custom DSL. `,content:`For each test, you may want to use a different way of creating objects. For example, even within the same class, one test may require initialization using the constructor, while another test may require initialization using its factory method.
Fixture Monkey allows you to choose the preferred method of creating your object through the instantiate() method. 💡 If the Kotlin Plugin is added, you can use the instantiateBy() method with a custom DSL. From the ArbitraryBuilder, you can determine how the object is created by specifying the preferred instantiation method (constructor or factory method).
This doesn&rsquo;t mean that you have to tell the ArbitraryBuilder how to create an object every time you use it. If you want to set a global option as the default method for creating all objects with a Fixture Monkey instance, refer to the Introspector page.
The instantiate() method is just a convenient way to modify the generation method from the ArbitraryBuilder.
Constructor # Let&rsquo;s say you have a custom class with a few different constructors that looks like this:
Java Kotlin @Value public class Product { long id; String productName; long price; List&lt;String&gt; options; Instant createdAt; public Product() { this.id = 0; this.productName = null; this.price = 0; this.options = null; this.createdAt = null; } public Product( String str, long id, long price ) { this.id = id; this.productName = str; this.price = price; this.options = Collections.emptyList(); this.createdAt = Instant.now(); } public Product( long id, long price, List&lt;String&gt; options ) { this.id = id; this.productName = &#34;defaultProductName&#34;; this.price = price; this.options = options; this.createdAt = Instant.now(); } } class Product( val id: Long, val productName: String, val price: Long, val options: List&lt;String&gt;, val createdAt: Instant ) { constructor() : this( id = 0, productName = &#34;&#34;, price = 0, options = emptyList(), createdAt = Instant.now() ) constructor(str: String, id: Long, price: Long) : this( id = id, productName = str, price = price, options = emptyList(), createdAt = Instant.now() ) constructor(id: Long, price: Long, options: List&lt;String&gt;) : this( id = id, productName = &#34;defaultProductName&#34;, price = price, options = options, createdAt = Instant.now() ) companion object { fun from(id: Long, price: Long): Product = Product(&#34;product&#34;, id, price) } } Fixture Monkey allows you to select the exact constructor you&rsquo;d like to use to create the object.
NoArgsConstructor, DefaultConstructor # The most basic way to use instantiate to tell the ArbitraryBuilder to create an object with its constructor is as follows:
Java Kotlin @Test void test() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate(constructor()) .sample(); then(product.getId()).isEqualTo(0); } @Test fun test() { val product = fixtureMonkey.giveMeBuilder&lt;Product&gt;() .instantiateBy { constructor() } .sample() then(product.productName).isEqualTo(&#34;&#34;) } You can specify to use the constructor method by passing the constructor() option. If there is a NoArgsConstructor, it will be used to create the object. If not, the first written constructor is used.
Specifying a Constructor # If a class has multiple constructors, you can specify the desired constructor by providing the necessary parameter information. For instance, consider the Product class with two constructors requiring different parameters.
To use the constructor that creates instances with empty options, specify the paramters as follows:
Java Kotlin @Test void test() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate( constructor() .parameter(String.class) .parameter(long.class) .parameter(long.class) ) .sample(); then(product.getOptions()).isEmpty(); } @RepeatedTest(TEST_COUNT) fun test() { val product = fixtureMonkey.giveMeBuilder&lt;Product&gt;() .instantiateBy { constructor&lt;Product&gt; { parameter&lt;String&gt;() parameter&lt;Long&gt;() parameter&lt;Long&gt;() } } .sample() then(product.options).isEmpty() } If you want to use the other constructor that makes a Product with productName as &ldquo;defaultProductName&rdquo;, you can specify it by just changing the parameter information: Java Kotlin constructor() .parameter(long.class) .parameter(long.class) .parameter(new TypeReference&lt;List&lt;String&gt;&gt;(){}) constructor&lt;Product&gt; { parameter&lt;Long&gt;() parameter&lt;Long&gt;() parameter&lt;List&lt;String&gt;&gt;() } Note that using private constructors is also possible.
Constructor Parameter Hints # In cases where you want to pass a specific value to the constructor, you can add a parameter name hint.
Java Kotlin @Test void test() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate( constructor() .parameter(String.class, &#34;str&#34;) .parameter(long.class) .parameter(long.class) ) .set(&#34;str&#34;, &#34;book&#34;) .sample(); then(product.getProductName()).isEqualTo(&#34;book&#34;); then(product.getOptions()).isEmpty(); } @Test fun test() { val product = fixtureMonkey.giveMeBuilder&lt;Product&gt;() .instantiateBy { constructor&lt;Product&gt; { parameter&lt;String&gt;(&#34;str&#34;) parameter&lt;Long&gt;() parameter&lt;Long&gt;() } } .set(&#34;str&#34;, &#34;book&#34;) .sample() then(product.productName).isEqualTo(&#34;book&#34;) then(product.options).isEmpty() } In this example, we provide a parameter name hint for the productName to be &ldquo;str&rdquo; This allows us to use the set() function to set the productName to the desired value (in this case &ldquo;book&rdquo;).
Although you can set the hint to any name, we recommend that you use the name in the constructor parameter to avoid confusion. Also note that once the name has been changed using the parameter name hint, you can no longer set it using the field name &ldquo;productName&rdquo;.
Using default arguments (Kotlin) # In Kotlin, you have the flexibility to pass an additional value to a constructor parameter option, allowing you to decide whether to use the default argument if one is available.
@Test fun test() { class Product(val productName: String = &quot;defaultProductName&quot;) val product = fixtureMonkey.giveMeBuilder&lt;Product&gt;() .instantiateBy { constructor { parameter&lt;String&gt;(useDefaultArgument = true) } } .sample() then(product.productName).isEqualTo(&quot;defaultProductName&quot;) } Generic Objects # Generic Objects can also be instantiated in a similar way. Consider this sample class GenericObject:
Java Kotlin @Value public class GenericObject&lt;T&gt; { T value; public GenericObject(T value) { this.value = value; } } class GenericObject&lt;T&gt;(var value: T) Java Kotlin @Test void test() { ConstructorTestSpecs.GenericObject&lt;String&gt; genericObject = fixtureMonkey.giveMeBuilder( new TypeReference&lt;ConstructorTestSpecs.GenericObject&lt;String&gt;&gt;() { }) .instantiate( constructor() .parameter(String.class) ) .sample(); then(genericObject).isNotNull(); then(genericObject.getValue()).isNotNull(); } @Test fun test() { val genericObject = fixtureMonkey.giveMeBuilder&lt;GenericObject&lt;String&gt;&gt;() .instantiateBy { constructor() { parameter&lt;String&gt;() } } .sample() then(genericObject).isNotNull() then(genericObject.value).isNotNull() } You can specify to use the constructor with the actual type when working with generic objects.
Using Constructors with Nested Objects # In scenarios involving nested objects, where you wish to specify the creation of both objects using their constructors, you can designate each type and specify the constructor to be used.
For example, consider the ProductList class that uses the Product class:
Java Kotlin @Value public class ProductList { String listName; List&lt;Product&gt; list; public ProductList(List&lt;Product&gt; list) { this.listName = &#34;defaultProductListName&#34;; this.list = list; } } class ProductList(val listName: String, val list: List&lt;Product&gt;) { constructor(list: List&lt;Product&gt;) : this(&#34;defaultProductListName&#34;, list) } You can specify to use a certain constructor for both ProductList and Product with their constructors like the following:
Java Kotlin @Test void test() { ProductList productList = fixtureMonkey.giveMeBuilder(ProductList.class) .instantiate( ProductList.class, constructor() .parameter(new TypeReference&lt;List&lt;Product&gt;&gt;() {}, &#34;list&#34;) ) .instantiate( Product.class, constructor() .parameter(long.class) .parameter(long.class) .parameter(new TypeReference&lt;List&lt;String&gt;&gt;(){}) ) .size(&#34;list&#34;, 1) .sample(); then(productList.getListName()).isEqualTo(&#34;defaultProductListName&#34;); then(productList.getList()).hasSize(1); then(productList.getList().get(0).getProductName()).isEqualTo(&#34;defaultProductName&#34;); } @Test fun test() { val productList = fixtureMonkey.giveMeBuilder&lt;ProductList&gt;() .instantiateBy { constructor&lt;ProductList&gt; { parameter&lt;List&lt;Product&gt;&gt;(&#34;list&#34;) } constructor&lt;Product&gt; { parameter&lt;Long&gt;() parameter&lt;Long&gt;() parameter&lt;List&lt;String&gt;&gt;() } } .size(&#34;list&#34;, 1) .sample() then(productList.listName).isEqualTo(&#34;defaultProductListName&#34;) then(productList.list).hasSize(1) then(productList.list[0].productName).isEqualTo(&#34;defaultProductName&#34;) } 💡 It is also possible to combine both constructor and factory method approaches for different properties within the instantiate method. In the above example, the ProductList can be initialized with the factory method, while the Product can be instantiated using the constructor. Factory Method # The second way to create an object is by using its factory method.
Consider the same Product class above, which now includes a factory method called from.
Java Kotlin @Value public class Product { long id; String productName; long price; List&lt;String&gt; options; Instant createdAt; public Product( String productName, long id, long price ) { this.id = id; this.productName = productName; this.price = price; this.options = Collections.emptyList(); this.createdAt = Instant.now(); } public static Product from(long id, long price) { return new Product(&#34;product&#34;, id, price); } } class Product( val id: Long, val productName: String, val price: Long, val options: List&lt;String&gt; = emptyList(), val createdAt: Instant = Instant.now() ) { companion object { fun from(id: Long, price: Long): Product { return Product(&#34;product&#34;, id, price) } } } Specifying Factory Method # You can specify the factory method to be used by providing its name.
Java Kotlin @Test void test() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate( factoryMethod(&#34;from&#34;) ) .sample(); then(product.getProductName()).isEqualTo(&#34;product&#34;); } @Test fun test() { val product = fixtureMonkey.giveMeBuilder&lt;Product&gt;() .instantiateBy { factory&lt;Product&gt;(&#34;from&#34;) } .sample() then(product.productName).isEqualTo(&#34;product&#34;) } If there are multiple factory methods with the same name, you can differentiate them by specifying parameter type information, similar to how it&rsquo;s done in the constructor() method.
Java Kotlin factoryMethod(&#34;from&#34;) .parameter(String.class) .parameter(Long.class) factory&lt;Product&gt;(&#34;from&#34;) { parameter&lt;String&gt;() parameter&lt;Long&gt;() } Factory Method Parameter Hints # Parameter name hints can also be added when using factory(), and it works the same as the parameter name hint of constructor().
Java Kotlin @Test void test() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate( factoryMethod(&#34;from&#34;) .parameter(long.class, &#34;productId&#34;) .parameter(long.class) ) .set(&#34;productId&#34;, 100L) .sample(); then(product.getProductName()).isEqualTo(&#34;product&#34;); then(product.getId()).isEqualTo(100L); } @Test fun test() { val product = fixtureMonkey.giveMeBuilder&lt;Product&gt;() .instantiateBy { factory&lt;Product&gt;(&#34;from&#34;) { parameter&lt;String&gt;(&#34;productId&#34;) parameter&lt;Long&gt;() } } .set(&#34;productId&#34;, 100L) .sample() then(product.productName).isEqualTo(&#34;product&#34;) then(product.id).isEqualTo(100L) } Field &amp; JavaBeansProperty # For each instantiation method (constructor() and factory()), you can choose whether to generate properties based on the fields or the JavaBeans Property (getter &amp; setter).
Java Kotlin .instantiate(constructor().field()) // generate based on fields .instantiate(constructor().javaBeansProperty()) // generate based on JavaBeans Property .instantiateBy { constructor { javaField() } } .instantiateBy { constructor { javaBeansProperty() } } If you use field, the value for the fields will be generated. If you use javaBeans Property, having a getter and setter in your class is sufficient, and a random value will be generated.
Excluding properties # To exclude some properties from being generated, you can use the filter() method.
Java Kotlin .instantiate( constructor() .field(it -&gt; it.filter(field -&gt; !Modifier.isPrivate(field.getModifiers()))) ) .instantiate( constructor() .javaBeansProperty(it -&gt; it.filter(property -&gt; !&#34;string&#34;.equals(property.getName()))) ) .instantiateBy { constructor { javaField { filter { !Modifier.isPrivate(it.modifiers) } } } } .instantiateBy { constructor { javaBeansProperty { filter { &#34;string&#34; != it.name } } } } For example, you can exclude private fields from being generated as shown in the first example, or you can filter out certain properties by name, as demonstrated in the second example.
`}),e.add({id:14,href:"/v1-1-0/docs/generating-objects/introspector/",title:"Introspector",description:`While you can change the way an object is created in the ArbitraryBuilder with instantiate, there may be cases where you want to change the way objects are created globally. Fixture Monkey lets you choose the way you want to create your object by providing different Introspectors.
An Introspector defines the default way of how Fixture Monkey creates objects. Each introspector has some kind of restrictions that the class must have in order for the introspector to generate instances of that class.
`,content:`While you can change the way an object is created in the ArbitraryBuilder with instantiate, there may be cases where you want to change the way objects are created globally. Fixture Monkey lets you choose the way you want to create your object by providing different Introspectors.
An Introspector defines the default way of how Fixture Monkey creates objects. Each introspector has some kind of restrictions that the class must have in order for the introspector to generate instances of that class.
You can change the introspector you use by using the objectIntrospector option of Fixture Monkey.
BeanArbitraryIntrospector # The BeanArbitraryIntrospector is the default introspector that fixture monkey uses for object creation. It creates new instances using reflection and the setter method, so the class it creates must have a no-args constructor and setters.
FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(BeanArbitraryIntrospector.INSTANCE) .build(); ConstructorPropertiesArbitraryIntrospector # To generate an object with its given constructor, you can use ConstructorPropertiesArbitraryIntrospector.
For ConstructorPropertiesArbitraryIntrospector, the generated class should have a constructor with @ConstructorProperties or the class should be a record type. (Or, if you are using Lombok, you can add lombok.anyConstructor.addConstructorProperties=true to the lombok.config file.)
When you create a record class and have multiple constructors, the constructor with the @ConstructorProperties annotation has priority.
FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build(); FieldReflectionArbitraryIntrospector # FieldReflectionArbitraryIntrospector creates new instances with reflection and also sets the fields with reflection. So the class to be generated must have a no-args constructor and one of the getters or setters.
FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(FieldReflectionArbitraryIntrospector.INSTANCE) .build(); 💡 If there are non-final variables declared, they can be instantiated without the need for getters or setters. BuilderArbitraryIntrospector # To generate a class using the class&rsquo;s builder, you can use BuilderArbitraryIntrospector. It requires that the class has a builder.
FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(BuilderArbitraryIntrospector.INSTANCE) .build(); FailoverArbitraryIntrospector # Sometimes your production code may contain several classes with different configurations, making it difficult to generate all objects with a single introspector. In this case, you can use the FailoverArbitraryIntrospector. This introspector allows you to use multiple introspectors, and it will continue the introspection even if one of the introspectors fails to generate.
FixtureMonkey sut = FixtureMonkey.builder() .objectIntrospector(new FailoverIntrospector( Arrays.asList( FieldReflectionArbitraryIntrospector.INSTANCE, ConstructorPropertiesArbitraryIntrospector.INSTANCE ) )) .build(); If you want to disable the fail log, you should set the constructor argument enableLoggingFail to false.
FailoverIntrospector failoverIntrospector = new FailoverIntrospector(introspectors, false); PriorityConstructorArbitraryIntrospector # Types that Fixture Monkey does not support creating by default can be created using a custom ArbitraryIntrospector. However, creating your own ArbitraryIntrospector can be difficult if you are not familiar with Fixture Monkey. To solve this difficulty, we provide a PriorityConstructorArbitraryIntrospector that uses a constructor to create the type.
Timestamp actual = FixtureMonkey.builder() .objectIntrospector(PriorityConstructorArbitraryIntrospector.INSTANCE) .build() .giveMeOne(Timestamp.class); Differences from ConstructorPropertiesArbitraryIntrospector # The ConstructorPropertiesArbitraryIntrospector is also an ArbitraryIntrospector that uses a constructor to create an object. The differences from PriorityConstructorArbitraryIntrospector are as follows.
PriorityConstructorArbitraryIntrospector ConstructorPropertiesArbitraryIntrospector Need @ConstructorProperties No Yes Can customize the parameters of constructor Optional (need withParameterNamesResolver ) Yes Criteria for choosing a constructor By the constructorFilter, sortingCriteria The first constructor with @ConstructorProperties constructorFilter # The PriorityConstructorArbitraryIntrospector uses the constructorFilter condition to determine which constructor to use for generation.
The constructorFilter can be changed using withConstructorFilter. By default, it is constructor -&gt; !Modifier.isPrivate(constructor.getModifiers()).
sortingCriteria # If there are multiple constructors that satisfy the constructorFilter condition, an additional sortingCriteria condition is used to determine the constructor.
Use the first constructor when sorted by Comparator&lt;Constructor&lt;?&gt;&gt;.
The sortingCriteria can be changed using withSortingCriteria. The default setting is the constructor with the least number of constructors. Comparator.comparing(Constructor::getParameterCount)
parameterNamesResolver # Fixture Monkey cannot recognise constructor parameter names if any of the following three conditions are not met.
record type Enable JVM option -parameters Existence of @ConstructorProperties in the constructor If you do not recognise constructor parameter names, you cannot use the ArbitraryBuilder API to control constructor parameters.
The PriorityConstructorArbitraryIntrospector uses the parameterNamesResolver to recognise parameter names. The parameterNamesResolver can be changed using withParameterNamesResolver. The entered parameter names must always be the same as the parameter order.
Additional introspectors have been introduced inside plugins, such as JacksonObjectArbitraryIntrospector or PrimaryConstructorArbitraryIntrospector
`}),e.add({id:15,href:"/v1-1-0/docs/generating-objects/generating-interface/",title:"Generating Interface Type",description:`Fixture Monkey is able to generate complex interface objects consisting of interface, generic interface, sealed interface.
Fixture Monkey provides the default implementations of certain interfaces. For example, ArrayList is for the List interface, HashSet is for the Set interface.
Except in those cases, you should specify the implementations of the interface. If you do not, Fixture Monkey will generate an anonymous object for you. You do not need to specify the implementations in the case of sealed interface.
`,content:`Fixture Monkey is able to generate complex interface objects consisting of interface, generic interface, sealed interface.
Fixture Monkey provides the default implementations of certain interfaces. For example, ArrayList is for the List interface, HashSet is for the Set interface.
Except in those cases, you should specify the implementations of the interface. If you do not, Fixture Monkey will generate an anonymous object for you. You do not need to specify the implementations in the case of sealed interface.
Let&rsquo;s see how to create an interface with a detailed example.
Simple Interface # public interface StringSupplier { String getValue(); } public class DefaultStringSupplier implements StringSupplier { private final String value; @ConstructorProperties(&quot;value&quot;) // It is not needed if you are using Lombok. public DefaultStringSupplier(String value) { this.value = value; } @Override public String getValue() { return &quot;default&quot; + value; } } Without options # Without options, Fixture Monkey will generate an anonymous object of StringSupplier.
FixtureMonkey fixture = FixtureMonkey.create(); StringSupplier result = fixtureMonkey.giveMeOne(StringSupplier.class); The generated instance result is an anonymous object of StringSupplier. The getter getValue returns the arbitrary String value. It can be null just like the property of Clsas. You need to know that it works same as DefaultStringSupplier, but it is not type of DefaultStringSupplier.
💡 Fixture Monkey only generates the properties of the anonymous object listed below.
Methods follows the naming convention of getter No parameter methods The generated properties can be customized just like the properties of Class.
FixtureMonkey fixture = FixtureMonkey.create(); String result = fixture.giveMeBuilder(StringSupplier.class) .set(&quot;value&quot;, &quot;fix&quot;) .sample() .getValue(); The result is now set to fix. You can use all the APIs in ArbitraryBuilder.
With options # You can extend the implementations of the interface by using the InterfacePlugin#interfaceImplements option.
💡 All the options related to interface or abstract class are in InterfacePlugin FixtureMonkey fixture = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) // used for instantiate DefaultStringSupplier .plugin( new InterfacePlugin() .interfaceImplements(StringSupplier.class, List.of(DefaultStringSupplier.class)) ) .build(); DefaultStringSupplier stringSupplier = (DefaultStringSupplier)fixture.giveMeOne(StringSupplier.class); The InterfacePlugin#interfaceImplements option can be used multiple times. For example, the default implementation of List is ArrayList. What if you use Interface#interfaceImplements to implement LinkedList like this?
FixtureMonkey fixture = FixtureMonkey.builder() .plugin( new InterfacePlugin() .interfaceImplements(List.class, List.of(LinkedList.class)) ) .build(); List&lt;String&gt; list = fixture.giveMeOne(new TypeReference&lt;List&lt;String&gt;&gt;() { }); // list will be an instance of ArrayList or LinkedList The implementations of List are ArrayList and LinkedList.
The InterfacePlugin#interfaceImplements option can also be resolved as an interface.
Without options, Fixture Monkey will not generate an implementation of the Collection interface. Let Collection be List through the InterfacePlugin#interfaceImplements option. The implementations of the List interface propagate to the Collection interface. In detail, the List interface is generated as an implementation of ArrayList, the Collection interface is also be ArrayList.
FixtureMonkey fixture = FixtureMonkey.builder() .plugin( new InterfacePlugin() .interfaceImplements(Collection.class, List.of(List.class)) ) .build(); ArrayList&lt;String&gt; collection = (ArrayList&lt;String&gt;)fixture.giveMeOne(new TypeReference&lt;Collection&lt;String&gt;&gt;() { }); // collection will be an instance of ArrayList You can use this option below if there are too many implementations to add using the options, but they have a similar pattern.
interface ObjectValueSupplier { Object getValue(); } interface StringValueSupplier extends ObjectValueSupplier { String getValue(); } public class DefaultStringValueSupplier implements StringValueSupplier { private final String value; @ConstructorProperties(&quot;value&quot;) // It is not needed if you are using Lombok. public DefaultStringValueSupplier(String value) { this.value = value; } @Override public String getValue() { return this.value; } } interface IntegerValueSupplier extends ObjectValueSupplier { Integer getValue(); } public class DefaultIntegerValueSupplier implements IntegerValueSupplier { private final Integer value; @ConstructorProperties(&quot;value&quot;) // It is not needed if you are using Lombok. public DefaultIntegerValueSupplier(Integer value) { this.value = value; } @Override public Integer getValue() { return this.value; } } FixtureMonkey fixture = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) // used for instantiate implementations of ObjectValueSupplier .plugin( new InterfacePlugin() .interfaceImplements( new AssignableTypeMatcher(ObjectValueSupplier.class), property -&gt; { Class&lt;?&gt; actualType = Types.getActualType(property.getType()); if (StringValueSupplier.class.isAssignableFrom(actualType)) { return List.of(PropertyUtils.toProperty(DefaultStringValueSupplier.class)); } if (IntegerValueSupplier.class.isAssignableFrom(actualType)) { return List.of(PropertyUtils.toProperty(DefaultIntegerValueSupplier.class)); } return List.of(); } ) ) .build(); DefaultStringValueSupplier stringValueSupplier = (DefaultStringValueSupplier)fixture.giveMeOne(StringValueSupplier.class); DefaultIntegerValueSupplier integerValueSupplier = (DefaultIntegerValueSupplier)fixture.giveMeOne(IntegerValueSupplier.class); Generic Interfaces # What if we need to generate some complex generic interface? All you have to do is do what you did with the simple interface above.
public interface ObjectValueSupplier&lt;T&gt; { T getValue(); } public class StringValueSupplier implements ObjectValueSupplier&lt;String&gt; { private final String value; @ConstructorProperties(&quot;value&quot;) // It is not needed if you are using Lombok. public StringValueSupplier(String value) { this.value = value; } @Override public String getValue() { return value; } } FixtureMonkey fixture = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) // used for instantiate StringValueSupplier .plugin( new InterfacePlugin() .interfaceImplements(ObjectValueSupplier.class, List.of(StringValueSupplier.class)) ) .build(); StringValueSupplier stringSupplier = (StringValueSupplier)fixture.giveMeOne(ObjectValueSupplier.class); Sealed Interface # Sealed interface is simpler. You do not need options.
sealed interface SealedStringSupplier { String getValue(); } public static final class SealedDefaultStringSupplier implements SealedStringSupplier { private final String value; @ConstructorProperties(&quot;value&quot;) // It is not needed if you are using Lombok. public SealedDefaultStringSupplier(String value) { this.value = value; } @Override public String getValue() { return &quot;sealed&quot; + value; } } FixtureMonkey fixture = FixtureMonkey.builder() .objectIntrospector( ConstructorPropertiesArbitraryIntrospector.INSTANCE) // used for instantiate SealedDefaultStringSupplier .build(); SealedDefaultStringSupplier stringSupplier = (SealedDefaultStringSupplier)fixture.giveMeOne(SealedStringSupplier.class); For advanced users # If there are too many implementations of an interface, you can add interface implementations programmatically. All you have to do is create a class that implements the CandidateConcretePropertyResolver interface and add it to the InterfacePlugin.
class YourCustomCandidateConcretePropertyResolver implements CandidateConcretePropertyResolver { @Override public List&lt;Property&gt; resolveCandidateConcreteProperties(Property property) { // resolve your implementations return List.of(...); } } If you have a trouble creating List&lt;Property&gt;, you can delegate the creation logic to ConcreteTypeCandidateConcretePropertyResolver.
ConcreteTypeCandidateConcretePropertyResolver is a class that implements the CandidateConcretePropertyResolver interface. It converts the types and property information provided in the constructor to List&lt;Property&gt;. The property information is used when inferring type parameters.
In the case below, the ConcreteTypeCandidateConcretePropertyResolver is used to resolve the implementations of List and Set. Collection&lt;String&gt; is resolved as either List&lt;String&gt; or Set&lt;String&gt;. You can resolve the actual implementations programmatically or delegate the creation logic to Fixture Monkey. By default, Fixture Monkey resolves List&lt;String&gt; as ArrayList&lt;String&gt; and Set&lt;String&gt; as HashSet&lt;String&gt;.
💡 You should be careful when setting the type condition to apply the options as the first parameter. For example, using AssignableTypeMatcher in the example below will cause an infinite loop because the implementations also satisfy the condition. FixtureMonkey sut = FixtureMonkey.builder() .plugin(new InterfacePlugin() .interfaceImplements( new ExactTypeMatcher(Collection.class), new ConcreteTypeCandidateConcretePropertyResolver&lt;&gt;(List.of(List.class, Set.class)) ) ) .build(); Collection&lt;String&gt; actual = sut.giveMeOne(new TypeReference&lt;&gt;() { }); then(actual).isInstanceOfAny(List.class, Set.class); This chapter illustrates how to create an interface type. If you get stuck, all you need to remember is the \`InterfacePlugin&rsquo; plugin. If the plugin doesn&rsquo;t solve your problem, please post a bug with a reproducible example.
`}),e.add({id:16,href:"/v1-1-0/docs/customizing-objects/",title:"Customizing Objects",description:"",content:""}),e.add({id:17,href:"/v1-1-0/docs/customizing-objects/apis/",title:"Fixture Customization APIs",description:`Fixture Monkey offers a range of APIs within the ArbitraryBuilder class that enable customization of objects created by it.
Customizing Fixtures # set() # The set() method is used to assign values to one or more properties referenced by the expression.
Different types, including Supplier, Arbitrary, ArbitraryBuilder, NOT_NULL, NULL, or Just can be used as the value. Additionally, a certain instance of an object can also be used as the value.
Java Kotlin fixtureMonkey.giveMeBuilder(Product.class) .set(&#34;id&#34;, 1000); fixtureMonkey.giveMeBuilder&lt;Product&gt;() .setExp(Product::id, 1000) Just # Using an instance wrapped by Just when using set() makes you set the value directly instead of decomposing. Normally, when you set() a property in ArbitraryBuilder it does not use an instance of the given value, it does a deep copy instead. So, if you need to set with an instance, you can use Values.just(instance) This feature can be useful in cases where you need to set a property to a mock instance when using a mocking framework.
`,content:`Fixture Monkey offers a range of APIs within the ArbitraryBuilder class that enable customization of objects created by it.
Customizing Fixtures # set() # The set() method is used to assign values to one or more properties referenced by the expression.
Different types, including Supplier, Arbitrary, ArbitraryBuilder, NOT_NULL, NULL, or Just can be used as the value. Additionally, a certain instance of an object can also be used as the value.
Java Kotlin fixtureMonkey.giveMeBuilder(Product.class) .set(&#34;id&#34;, 1000); fixtureMonkey.giveMeBuilder&lt;Product&gt;() .setExp(Product::id, 1000) Just # Using an instance wrapped by Just when using set() makes you set the value directly instead of decomposing. Normally, when you set() a property in ArbitraryBuilder it does not use an instance of the given value, it does a deep copy instead. So, if you need to set with an instance, you can use Values.just(instance) This feature can be useful in cases where you need to set a property to a mock instance when using a mocking framework.
Note that you cannot set a child property after setting with Just.
Product product = fixture.giveMeBuilder(Product.class) .set(&quot;options&quot;, Values.just(List.of(&quot;red&quot;, &quot;medium&quot;, &quot;adult&quot;)) .set(&quot;options[0]&quot;, &quot;blue&quot;) .sample(); For example, the product instance created above, will not have the value &ldquo;blue&rdquo; for the first element of options. It will remain the list given with Just.
size(), minSize(), maxSize() # The size() method lets you specify the size of container properties. You have the flexibility to either set a precise size or specify a range using the minimum and maximum values.
Alternatively, you can use minSize() or maxSize() to set only the minimum or maximum container size. (By default, the size range is from 0 to 3 elements.)
Java Kotlin fixtureMonkey.giveMeBuilder(Product.class) .size(&#34;options&#34;, 5); // size:5 fixtureMonkey.giveMeBuilder(Product.class) .size(&#34;options&#34;, 3, 5); // minSize:3, maxSize:5 fixtureMonkey.giveMeBuilder(Product.class) .minSize(&#34;options&#34;, 3); // minSize:3 fixtureMonkey.giveMeBuilder(Product.class) .maxSize(&#34;options&#34;, 5); // maxSize:5 fixtureMonkey.giveMeBuilder&lt;Product&gt;() .sizeExp(Product::options, 5) // size:5 fixtureMonkey.giveMeBuilder&lt;Product&gt;() .sizeExp(Product::options, 3, 5) // minSize:3, maxSize:5 fixtureMonkey.giveMeBuilder&lt;Product&gt;() .minSizeExp(Product::options, 3) // minSize:3 fixtureMonkey.giveMeBuilder&lt;Product&gt;() .maxSizeExp(Product::options, 5) // maxSize:5 setNull(), setNotNull() # At times, you might want to ensure that a property is either always set to null or always has a value. In such situations, you can use setNull() or setNotNull().
Java Kotlin fixtureMonkey.giveMeBuilder(Product.class) .setNull(&#34;id&#34;); fixtureMonkey.giveMeBuilder(Product.class) .setNotNull(&#34;id&#34;); fixtureMonkey.giveMeBuilder&lt;Product&gt;() .setNullExp(Product::id) fixtureMonkey.giveMeBuilder&lt;Product&gt;() .setNotNullExp(Product::id) setInner() # With setInner() you can apply customizations defined within an InnerSpec instance to your builder. An InnerSpec is a type-independent specification for the customizations to be applied.
Instances of InnerSpec can be reused to consistently and easily configure nested properties. This feature is particularly beneficial when customizing map properties.
For additional guidance, refer to InnerSpec
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(&#34;merchantInfo&#34;, it -&gt; it.entry(1000, &#34;ABC Store&#34;)); fixtureMonkey.giveMeBuilder(Product.class) .setInner(innerSpec) val innerSpec = InnerSpec() .property(&#34;merchantInfo&#34;) { it.entry(1000, &#34;ABC Store&#34;) } fixtureMonkey.giveMeBuilder(Product.class) .setInner(innerSpec) setLazy() # The setLazy() function assigns the property a value obtained from the provided Supplier. The Supplier will run every time the ArbitraryBuilder is sampled.
This can be particularly useful when you need to generate unique sequential IDs or set the most recent value.
Java Kotlin AtomicReference&lt;Long&gt; variable = new AtomicReference&lt;&gt;(0L); ArbitraryBuilder&lt;Long&gt; builder = fixtureMonkey.giveMeBuilder(Long.class) .setLazy(&#34;$&#34;, () -&gt; variable.getAndSet(variable.get() + 1)); Long actual1 = builder.sample(); // actual1 == 0 Long actual2 = builder.sample(); // actual2 == 1 var variable = 0L val builder = fixtureMonkey.giveMeBuilder(Long::class.java) .setLazy(&#34;$&#34;) { variable++ } val actual1 = builder.sample() // actual1 == 0 val actual2 = builder.sample() // actual2 == 1 setPostCondition() # setPostCondition() can be used when your fixture needs to adhere to a specific condition. This condition can be defined by passing a predicate.
🚨 Using setPostCondition can incur higher costs for narrow conditions. In such cases, it's recommended to use set instead. Java Kotlin fixtureMonkey.giveMeBuilder(Product.class) .setPostCondition(&#34;id&#34;, Long.class, it -&gt; it &gt; 0) fixtureMonkey.giveMeBuilder(Product::class.java) .setPostConditionExp(Product::id, Long::class.java) { it: Long -&gt; it &gt; 0 } fixed() # fixed() can be used when you want your arbitrary builder to consistently return instances with the same values every time it is sampled.
Java Kotlin fixtureMonkey.giveMeBuilder(Product.class) .fixed() fixtureMonkey.giveMeBuilder&lt;Product&gt;() .fixed() limit # For the set(), setLazy(), and setPostCondition() methods, you can include an additional parameter that determines the number of times the customization will be applied. This can be advantageous when the expression refers to multiple properties.
Java Kotlin fixtureMonkey.giveMeBuilder(Product.class) .set(&#34;options[*]&#34;, &#34;red&#34;, 2); // up to 2 elements in options will be set to &#34;red&#34; fixtureMonkey.giveMeBuilder&lt;Product&gt;() .set(&#34;options[*]&#34;, &#34;red&#34;, 2) // up to 2 elements in options will be set to &#34;red&#34; Expanding Customization using Sampled Results # thenApply() # The thenApply() method becomes handy when you need to customize a field based on the sampled result of the builder. For instance, let&rsquo;s assume you want the &ldquo;productName&rdquo; field to match the generated &ldquo;id&rdquo; of the Product. You can use thenApply() as follows:
Java Kotlin fixtureMonkey.giveMeBuilder(Product.class) .thenApply((it, builder) -&gt; builder.set(&#34;productName&#34;, it.getId().toString())) fixtureMonkey.giveMeBuilder(Product::class.java) .thenApply{it, builder -&gt; builder.setExp(Product::productName, it.id.toString())} acceptIf() # You might also find the need to perform additional customization based on a specific condition. In such cases, you can utilize the acceptIf() method, which applies the customization only when the predicate is satisfied.
Java Kotlin fixtureMonkey.giveMeBuilder(Product.class) .acceptIf( it -&gt; it.getProductType() == ProductType.CLOTHING, builder -&gt; builder.set(&#34;price&#34;, 1000) ) fixtureMonkey.giveMeBuilder&lt;Product&gt;() .acceptIf( { it.productType == ProductType.CLOTHING }, { builder -&gt; builder.setExp(Product::price, 1000) } ) Transforming the Type of ArbitraryBuilder # map() # The map() function is used to convert the ArbitraryBuilder type into another type.
Java Kotlin fixtureMonkey.giveMeBuilder(Product.class) .map(Product::getId); // transforms to ArbitraryBuilder&lt;Long&gt; fixtureMonkey.giveMeBuilder(Product::class.java) .map(Product::id) // transforms to ArbitraryBuilder&lt;Long&gt; zipWith() # zipWith() becomes useful when you want to merge multiple ArbitraryBuilders to create an ArbitraryBuilder of a different type. You have to define how you intend to combine the builders.
Java Kotlin ArbitraryBuilder&lt;String&gt; stringBuilder = fixtureMonkey.giveMeBuilder(String.class); ArbitraryBuilder&lt;String&gt; zipped = fixtureMonkey.giveMeBuilder(Integer.class) .zipWith(stringBuilder, (integer, string) -&gt; integer + &#34;&#34; + string); val stringBuilder = fixtureMonkey.giveMeBuilder&lt;String&gt;() val zipped = fixtureMonkey.giveMeBuilder&lt;Int&gt;() .zipWith(stringBuilder) { int, string -&gt; int.toString() + &#34;&#34; + string } `}),e.add({id:18,href:"/v1-1-0/docs/customizing-objects/expressions/",title:"Expressions",description:`When using Fixture Monkey, you have the flexibility to select one or more properties of an object using Fixture Monkey expressions.
Let&rsquo;s consider an example object structure:
@Value public class JavaClass { String field; String[] array; List&lt;String&gt; list; Nested object; List&lt;Nested&gt; objectList; @Value public static class Nested { String nestedField; } } Selecting Properties Using String Expressions # Selecting the root object: # &quot;$&quot; Selecting a specific field: # &quot;field&quot; Selecting a nested field: # &quot;object.nestedField&quot; Selecting the n-th element of a collection: # &quot;list[n]&quot; Selecting all elements of a collection: # &quot;list[*]&quot; Selecting the n-th element of an array: # &quot;array[n]&quot; Selecting all elements of an array: # &quot;array[*]&quot; Combining expressions to select a nested field: # &quot;objectList[0].nestedField&quot; Selecting Properties Using JavaGetter Selector # There is a type-safe way to select properties using a javaGetter() property selector. This selector is designed to choose and represent a property through a getter method reference in Java.
`,content:`When using Fixture Monkey, you have the flexibility to select one or more properties of an object using Fixture Monkey expressions.
Let&rsquo;s consider an example object structure:
@Value public class JavaClass { String field; String[] array; List&lt;String&gt; list; Nested object; List&lt;Nested&gt; objectList; @Value public static class Nested { String nestedField; } } Selecting Properties Using String Expressions # Selecting the root object: # &quot;$&quot; Selecting a specific field: # &quot;field&quot; Selecting a nested field: # &quot;object.nestedField&quot; Selecting the n-th element of a collection: # &quot;list[n]&quot; Selecting all elements of a collection: # &quot;list[*]&quot; Selecting the n-th element of an array: # &quot;array[n]&quot; Selecting all elements of an array: # &quot;array[*]&quot; Combining expressions to select a nested field: # &quot;objectList[0].nestedField&quot; Selecting Properties Using JavaGetter Selector # There is a type-safe way to select properties using a javaGetter() property selector. This selector is designed to choose and represent a property through a getter method reference in Java.
Selecting the root object: # Currently Not Supported Selecting a specific field: # javaGetter(JavaClass::getField) Selecting a nested field: # javaGetter(JavaClass::getObject).into(Nested::getNestedField) Selecting the n-th element of a collection: # javaGetter(JavaClass::getList).index(String.class, n) Selecting all elements of a collection: # javaGetter(JavaClass::getList).allIndex(String.class) Selecting the n-th element of an array: # javaGetter(JavaClass::getArray).index(String.class, n) Selecting all elements of an array: # javaGetter(JavaClass::getArray).allIndex(String.class) Combining expressions to select a nested field: # javaGetter(JavaClass::getObjectList) .index(Nested.class, 0) .into(Nested::getNestedField) Selecting Collections # Note that for collections, a property will only be selected if it exists within the collection size. For instance, if the list has a size of 2 but the expression references &quot;list[3]&quot;, which is outside the bounds of the list, it will not be selected.
While Fixture Monkey supports selecting elements from lists and sets, there are currently no dedicated expressions for directly setting the elements of a map. However, if you need to customize a map, consider using the InnerSpec method.
Expression Strict Mode # This option can be turned on to ensure applied expressions strictly match the structure. If any part of an expression is out of bounds or invalid, Fixture Monkey will raise an exception.
Kotlin EXP # By adding the Kotlin plugin, you can select properties using Kotlin&rsquo;s property reference syntax. In Fixture Monkey, this feature is referred to as Kotlin EXP or the Fixture Monkey Kotlin DSL. For further details on its usage, refer to the Kotlin DSL Exp page.
`}),e.add({id:19,href:"/v1-1-0/docs/customizing-objects/arbitrary/",title:"Customizing random values with Arbitrary",description:`Jqwik is a Property-Based Testing library for the JVM environment. Fixture Monkey relies on Jqwik&rsquo;s Arbitrary to generate random values for primitive types such as characters, strings, and integers.
In Jqwik, Arbitrary is the core interface used to represent objects that can be generated and shrunk. At times, we might desire our fixture properties to have random values while adhering to certain constraints.
In such scenarios, you can achieve this by customizing properties using Fixture Monkey&rsquo;s set() method and assigning an Arbitrary as the value. You can generate an Arbitrary that matches certain conditions, simply by calling static methods in Jqwik&rsquo;s Arbitraries class.
`,content:`Jqwik is a Property-Based Testing library for the JVM environment. Fixture Monkey relies on Jqwik&rsquo;s Arbitrary to generate random values for primitive types such as characters, strings, and integers.
In Jqwik, Arbitrary is the core interface used to represent objects that can be generated and shrunk. At times, we might desire our fixture properties to have random values while adhering to certain constraints.
In such scenarios, you can achieve this by customizing properties using Fixture Monkey&rsquo;s set() method and assigning an Arbitrary as the value. You can generate an Arbitrary that matches certain conditions, simply by calling static methods in Jqwik&rsquo;s Arbitraries class.
The following code example demonstrates ways to customize random values using set() with Arbitrary: Java Kotlin Product actual = fixtureMonkey.giveMeBuilder(Product.class) .set(&#34;id&#34;, Arbitraries.longs().greaterOrEqual(1000)) .set(&#34;productName&#34;, Arbitraries.strings().withCharRange(&#39;a&#39;, &#39;z&#39;).ofMaxLength(10)) .set(&#34;productType&#34;, Arbitraries.of(ProductType.CLOTHING, ProductType.ELECTRONICS)) .sample(); then(actual.getId()).isGreaterThanOrEqualTo(1000); then(actual.getProductName()).matches(&#34;^[a-z]+$&#34;); then(actual.getProductName().length()).isLessThanOrEqualTo(10); then(actual.getProductType()).matches(it -&gt; it == ProductType.CLOTHING || it == ProductType.ELECTRONICS); val actual = fixtureMonkey.giveMeBuilder&lt;Product&gt;() .setExp(Product::id, Arbitraries.longs().greaterOrEqual(1000)) .setExp(Product::productName, Arbitraries.strings().withCharRange(&#39;a&#39;, &#39;z&#39;).ofMaxLength(10)) .setExp(Product::productType, Arbitraries.of(ProductType.CLOTHING, ProductType.ELECTRONICS)) .sample() then(actual.id).isGreaterThanOrEqualTo(1000) then(actual.productName).matches(&#34;^[a-z]+$&#34;) then(actual.productName.length).isLessThanOrEqualTo(10) then(actual.productType).matches { it -&gt; it === ProductType.CLOTHING || it === ProductType.ELECTRONICS } For further details about Jqwik and Arbitrary, check out Jqwik User Guide
`}),e.add({id:20,href:"/v1-1-0/docs/customizing-objects/innerspec/",title:"InnerSpec",description:`An InnerSpec is a type-independent specification for the customizations you wish to apply. Using the setInner() method within ArbitraryBuilder, you can apply customizations defined within an InnerSpec instance into your builder.
InnerSpec holds customization details and can be reused on ArbitraryBuilders. Unlike using expressions used in ArbitraryBuilder, InnerSpec enables a more nested and structured approach.
An added advantage of InnerSpec is its ability to customize map properties, unlike normal expressions.
`,content:`An InnerSpec is a type-independent specification for the customizations you wish to apply. Using the setInner() method within ArbitraryBuilder, you can apply customizations defined within an InnerSpec instance into your builder.
InnerSpec holds customization details and can be reused on ArbitraryBuilders. Unlike using expressions used in ArbitraryBuilder, InnerSpec enables a more nested and structured approach.
An added advantage of InnerSpec is its ability to customize map properties, unlike normal expressions.
💡 Kotlin EXP is not supported for InnerSpec, as it is designed to be type-independent. Instead, you need to specify the property by its name. Applying InnerSpec to the ArbitraryBuilder # To apply your pre-defined InnerSpec to the builder, use the setInner() method as shown below:
Java Kotlin InnerSpec innerSpec = new InnerSpec().property(&#34;id&#34;, 1000); fixtureMonkey.giveMeBuilder(Product.class) .setInner(innerSpec); val innerSpec = InnerSpec().property(&#34;id&#34;, 1000) fixtureMonkey.giveMeBuilder&lt;Product&gt;() .setInner(innerSpec) Customizing properties # property() # Similar to the set() method in ArbitraryBuilder, you can customize a property by specifying its name and providing the desired value.
🚨 Fixture Monkey expressions such as refering elements (\`[]\`) or nested fields(\`.\`) are not allowed as the property name. Only the property name itself is allowed. Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(&#34;id&#34;, 1000); val innerSpec = InnerSpec() .property(&#34;id&#34;, 1000) size(), minSize(), maxSize() # size(), minSize(), and maxSize() can be used to specify the size of the property.
As previously mentioned, InnerSpec defines customizations in a nested manner. You can first select the container property using property() and then proceed to define an innerSpec consumer to set the size.
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(&#34;options&#34;, options -&gt; options.size(5)); // size:5 InnerSpec innerSpec = new InnerSpec() .property(&#34;options&#34;, options -&gt; options.size(3, 5)); // minSize:3, maxSize:5 InnerSpec innerSpec = new InnerSpec() .property(&#34;options&#34;, options -&gt; options.minSize(3)); // minSize:3 InnerSpec innerSpec = new InnerSpec() .property(&#34;options&#34;, options -&gt; options.maxSize(5)); // maxSize:5 val innerSpec = InnerSpec() .property(&#34;options&#34;) { it.size(5) } // size:5 val innerSpec = InnerSpec() .property(&#34;options&#34;) { it.size(3, 5) } // minSize:3, maxSize:5 val innerSpec = InnerSpec() .property(&#34;options&#34;) { it.minSize(3) } // minSize:3 val innerSpec = InnerSpec() .property(&#34;options&#34;) { it.maxSize(5) } // maxSize:5 postCondition() # postCondition() can be used when you require your property to match a specific condition.
🚨 Using setPostCondition can incur higher costs for narrow conditions. In such cases, it's recommended to use set instead. Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(&#34;id&#34;, id -&gt; id.postCondition(Long.class, it -&gt; it &gt; 0)); val innerSpec = InnerSpec() .property(&#34;id&#34;) { it.postCondition(Long::class.java) { it &gt; 0 }} inner() # You can also customize a property using another pre-defined InnerSpec with the help of inner().
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(&#34;id&#34;, 1000L); fixtureMonkey.giveMeBuilder(Product.class) .setInner( new InnerSpec() .property(&#34;nestedObject&#34;, nestedObject -&gt; nestedObject.inner(innerSpec)) ); val innerSpec = InnerSpec() .property(&#34;id&#34;, 1000L) fixtureMonkey.giveMeBuilder&lt;Product&gt;() .setInner( InnerSpec() .property(&#34;nestedObject&#34;) { it.inner(innerSpec) } ) Customizing list properties # listElement() # Individual elements within lists can be selected using listElement(). This is equivalent to referencing elements with &ldquo;[n]&rdquo; using expressions.
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(&#34;options&#34;, options -&gt; options.listElement(0, &#34;red&#34;)); val innerSpec = InnerSpec() .property(&#34;options&#34;) { it.listElement(0, &#34;red&#34;) } allListElement() # If you wish to set all elements of the list simultaneously, you can use allListElement(). This is equivalent to referencing elements with &ldquo;[*]&rdquo; using expressions.
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(&#34;options&#34;, options -&gt; options.allListElement(&#34;red&#34;)); val innerSpec = InnerSpec() .property(&#34;options&#34;) { it.allListElement(&#34;red&#34;) } Customizing map properties # InnerSpec provides special methods for customizing map property entries.
🚨 Similar to lists, setting a map entry without specifying the size first might lead to no change. Prior to setting a value, ensure that the map property has the intended size. key(), value(), entry() # You can customize map property entries using key(), value(), and entry() methods. Using key() assigns a specified value to the key of a map entry, while the entry&rsquo;s value remains randomized. Similarly, value() assigns a specified value to the map entry&rsquo;s value, while the key becomes randomized. If you want to specify both the key and value at once, you can use entry().
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(&#34;merchantInfo&#34;, merchantInfo -&gt; merchantInfo.key(1000)); InnerSpec innerSpec = new InnerSpec() .property(&#34;merchantInfo&#34;, merchantInfo -&gt; merchantInfo.value(&#34;ABC Store&#34;)); InnerSpec innerSpec = new InnerSpec() .property(&#34;merchantInfo&#34;, merchantInfo -&gt; merchantInfo.entry(1000, &#34;ABC Store&#34;)); val innerSpec = InnerSpec() .property(&#34;merchantInfo&#34;) { it.key(1000) } val innerSpec = InnerSpec() .property(&#34;merchantInfo&#34;) { it.value(&#34;ABC Store&#34;) } val innerSpec = InnerSpec() .property(&#34;merchantInfo&#34;) { it.entry(1000, &#34;ABC Store&#34;) } keys(), values(), entries() # When setting multiple entries within a map, you can use keys(), values(), and entries() to pass multiple values.
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(&#34;merchantInfo&#34;, merchantInfo -&gt; merchantInfo.keys(1000, 1001, 1002)); InnerSpec innerSpec = new InnerSpec() .property(&#34;merchantInfo&#34;, merchantInfo -&gt; merchantInfo.values(&#34;ABC Store&#34;, &#34;123 Convenience&#34;, &#34;XYZ Mart&#34;)); InnerSpec innerSpec = new InnerSpec() .property(&#34;merchantInfo&#34;, merchantInfo -&gt; merchantInfo.entries(1000, &#34;ABC Store&#34;, 1001, &#34;123 Convenience&#34;, 1002, &#34;XYZ Mart&#34;)); val innerSpec = InnerSpec() .property(&#34;merchantInfo&#34;) { it.keys(1000, 1001, 1002) } val innerSpec = InnerSpec() .property(&#34;merchantInfo&#34;) { it.values(&#34;ABC Store&#34;, &#34;123 Convenience&#34;, &#34;XYZ Mart&#34;) } val innerSpec = InnerSpec() .property(&#34;merchantInfo&#34;) { it.entries(1000, &#34;ABC Store&#34;, 1001, &#34;123 Convenience&#34;, 1002, &#34;XYZ Mart&#34;) } allKey(), allValue(), allEntry() # Similar to allListElement(), it is possible to set every entry within the map to the specified value with allKey(), allValue(), and allEntry().
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(&#34;merchantInfo&#34;, merchantInfo -&gt; merchantInfo.allKey(1000)); InnerSpec innerSpec = new InnerSpec() .property(&#34;merchantInfo&#34;, merchantInfo -&gt; merchantInfo.allValue(&#34;ABC Store&#34;)); InnerSpec innerSpec = new InnerSpec() .property(&#34;merchantInfo&#34;, merchantInfo -&gt; merchantInfo.allEntry(1000, &#34;ABC Store&#34;)); val innerSpec = InnerSpec() .property(&#34;merchantInfo&#34;) { it.allKey(1000) } val innerSpec = InnerSpec() .property(&#34;merchantInfo&#34;) { it.allValue(&#34;ABC Store&#34;) } val innerSpec = InnerSpec() .property(&#34;merchantInfo&#34;) { it.allEntry(1000, &#34;ABC Store&#34;) } keyLazy(), valueLazy(), entryLazy() # Similar to the setLazy() method in ArbitraryBuilder, you can pass a Supplier to assign the value. The Supplier will run every time the ArbitraryBuilder with the InnerSpec applied is sampled.
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(&#34;merchantInfo&#34;, merchantInfo -&gt; merchantInfo.keyLazy(this::generateMerchantKey)); InnerSpec innerSpec = new InnerSpec() .property(&#34;merchantInfo&#34;, merchantInfo -&gt; merchantInfo.valueLazy(this::generateMerchantValue)); InnerSpec innerSpec = new InnerSpec() .property(&#34;merchantInfo&#34;, merchantInfo -&gt; merchantInfo.entryLazy(this::generateMerchantKey, this::generateMerchantValue)); val innerSpec = InnerSpec() .property(&#34;merchantInfo&#34;) { it.keyLazy(this::generateMerchantKey) } val innerSpec = InnerSpec() .property(&#34;merchantInfo&#34;) { it.valueLazy(this::generateMerchantValue) } val innerSpec = InnerSpec() .property(&#34;merchantInfo&#34;) { it.entryLazy(this::generateMerchantKey, this::generateMerchantValue) } allKeyLazy(), allValueLazy(), allEntryLazy() # Just as with the allKey() method, you can use allKeyLazy() to apply keyLazy() to every entry within the map. Both allValueLazy() and allEntryLazy() function similarly.
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(&#34;merchantInfo&#34;, merchantInfo -&gt; merchantInfo.allKeyLazy(this::generateMerchantKey)); InnerSpec innerSpec = new InnerSpec() .property(&#34;merchantInfo&#34;, merchantInfo -&gt; merchantInfo.allValueLazy(this::generateMerchantValue)); InnerSpec innerSpec = new InnerSpec() .property(&#34;merchantInfo&#34;, merchantInfo -&gt; merchantInfo.allEntryLazy(this::generateMerchantKey, this::generateMerchantValue)); val innerSpec = InnerSpec() .property(&#34;merchantInfo&#34;) { it.allKeyLazy(this::generateMerchantKey) } val innerSpec = InnerSpec() .property(&#34;merchantInfo&#34;) { it.allValueLazy(this::generateMerchantValue) } val innerSpec = InnerSpec() .property(&#34;merchantInfo&#34;) { it.allEntryLazy(this::generateMerchantKey, this::generateMerchantValue) } Customizing nested Maps # By combining methods within InnerSpec, you can effectively customize maps with map-type keys, map-type values, or both.
Consider the scenario of a nested map structure like the following:
public class Example { Map&lt;Map&lt;String, String&gt;, String&gt; mapByString; Map&lt;String, Map&lt;String, String&gt;&gt; stringByMap; } Setting map-type key # To set a map with a map-type key, you can access the map key using key(), and then further customize it.
general expression Kotlin Exp InnerSpec().property(&#34;mapByString&#34;, m -&gt; m.key(k -&gt; k.entry(&#34;key&#34;, &#34;value&#34;))); InnerSpec().property(&#34;mapByString&#34;) { m -&gt; m.key { k -&gt; k.entry(&#34;key&#34;, &#34;value&#34;) } } If you need to set the entry itself, access the entry with entry() and further customize the key using InnerSpec, then set the specific value.
general expression Kotlin Exp InnerSpec().property(&#34;mapByString&#34;, m -&gt; m.entry(k -&gt; k.entry(&#34;innerKey&#34;, &#34;innerValue&#34;)), &#34;value&#34;) InnerSpec().property(&#34;mapByString&#34;) { m -&gt; m.entry({ k -&gt; k.entry(&#34;innerKey&#34;, &#34;innerValue&#34;) }, &#34;value&#34;) } Setting map-type value # For a map with a map-type value, access the map value using value(), and then further customize it.
general expression Kotlin Exp InnerSpec().property(&#34;stringByMap&#34;, m -&gt; m.value(v -&gt; v.entry(&#34;key&#34;, &#34;value&#34;))) InnerSpec().property(&#34;stringByMap&#34;) { m -&gt; m.value { v -&gt; v.entry(&#34;key&#34;, &#34;value&#34;) } } If you need to set the entry itself, access the entry with entry() and further customize the value using InnerSpec, then set the specific key.
general expression Kotlin Exp InnerSpec().property(&#34;stringByMap&#34;, m -&gt; m.entry(&#34;key&#34;, v -&gt; v.entry(&#34;innerKey&#34;, &#34;innerValue&#34;))) InnerSpec().property(&#34;stringByMap&#34;) { m -&gt; m.entry(&#34;key&#34;) {v -&gt; v.entry(&#34;innerKey&#34;, &#34;innerValue&#34;)} } `}),e.add({id:21,href:"/v1-1-0/docs/customizing-objects/interface/",title:"Customizing Interface",description:`The ArbitraryBuilder API is also valid within the interface. You can customize the interface properties regardless of the interface type as said in Generating Interface Type The interface type refers to interface, generic interface ,selaed interface.
public interface StringSupplier { String getValue(); } FixtureMonkey fixture = FixtureMonkey.create(); String result = fixture.giveMeBuilder(StringSupplier.class) .set(&quot;value&quot;, &quot;fix&quot;) .sample() .getValue(); The properties of the interface in ArbitraryBuilder differ in the implementation. Unfortunately, there is currently no ArbitraryBuilder API that resolves the implementation of the interface. Unless the interface has only one implementation, you can customize the properties of the interface, not the implementation.
`,content:`The ArbitraryBuilder API is also valid within the interface. You can customize the interface properties regardless of the interface type as said in Generating Interface Type The interface type refers to interface, generic interface ,selaed interface.
public interface StringSupplier { String getValue(); } FixtureMonkey fixture = FixtureMonkey.create(); String result = fixture.giveMeBuilder(StringSupplier.class) .set(&quot;value&quot;, &quot;fix&quot;) .sample() .getValue(); The properties of the interface in ArbitraryBuilder differ in the implementation. Unfortunately, there is currently no ArbitraryBuilder API that resolves the implementation of the interface. Unless the interface has only one implementation, you can customize the properties of the interface, not the implementation.
You cannot generate the randomly populated intended implementation, but you can generate the fixed implementation by using the set API. There are two cases, with the interfaceImplements option and without the interfaceImplements option.
With the option # The interface type is resolved to the implementation when you use the set API with the option.
public interface ObjectValueSupplier { Object getValue(); } public class StringValueSupplier implements ObjectValueSupplier { private final String value; @ConstructorProperties(&quot;value&quot;) // It is not needed if you are using Lombok. public StringValueSupplier(String value) { this.value = value; } @Override public String getValue() { return value; } } public class IntegerValueSupplier implements ObjectValueSupplier { private final int value; private final int implementationValue; @ConstructorProperties({&quot;value&quot;, &quot;implementationValue&quot;}) // It is not needed if you are using Lombok. public IntegerValueSupplier(int value, int implementationValue) { this.value = value; this.implementationValue = implementationValue; } @Override public Integer getValue() { return value; } public int getImplementationValue() { return implementationValue; } } FixtureMonkey fixture = FixtureMonkey.builder() .objectIntrospector( ConstructorPropertiesArbitraryIntrospector.INSTANCE) // used for instantiate implementations of ObjectValueSupplier .plugin( new InterfacePlugin() .interfaceImplements( ObjectValueSupplier.class, List.of(StringValueSupplier.class, IntegerValueSupplier.class) ) ) .build(); IntegerValueSupplier integerValueSupplier = (IntegerValueSupplier)fixture.giveMeBuilder(ObjectValueSupplier.class) .set(&quot;$&quot;, new IntegerValueSupplier(-1203)) .sample(); You can also change the properties of the implementation.
IntegerValueSupplier integerValueSupplier = (IntegerValueSupplier)fixture.giveMeBuilder(ObjectValueSupplier.class) .set(&quot;$&quot;, new IntegerValueSupplier(-1203, 1203)) .set(&quot;implementationValue&quot;, 1) // it works. .sample(); Without the option # You have to use the set API in a specific way with Values.just.
public interface ObjectValueSupplier { Object getValue(); } public class StringValueSupplier implements ObjectValueSupplier { private final String value; @ConstructorProperties(&quot;value&quot;) // It is not needed if you are using Lombok. public StringValueSupplier(String value) { this.value = value; } @Override public String getValue() { return value; } } public class IntegerValueSupplier implements ObjectValueSupplier { private final int value; @ConstructorProperties(&quot;value&quot;) // It is not needed if you are using Lombok. public IntegerValueSupplier(int value) { this.value = value; } @Override public Integer getValue() { return value; } } FixtureMonkey fixture = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) // used for instantiate implementations of ObjectValueSupplier .build(); IntegerValueSupplier integerValueSupplier = (IntegerValueSupplier)fixture.giveMeBuilder(ObjectValueSupplier.class) .set(&quot;$&quot;, Values.just(new IntegerValueSupplier(-1203))) .sample(); The implementation is not used by interfaceImplements, Fixture Monkey does not know the properties of the implementation. You cannot set the properties of the implementation.
IntegerValueSupplier integerValueSupplier = (IntegerValueSupplier)fixture.giveMeBuilder(ObjectValueSupplier.class) .set(&quot;$&quot;, Values.just(new IntegerValueSupplier(-1203))) .set(&quot;value&quot;, 1) // not works .sample(); `}),e.add({id:22,href:"/v1-1-0/docs/fixture-monkey-options/",title:"Fixture Monkey Options",description:"",content:""}),e.add({id:23,href:"/v1-1-0/docs/plugins/simple-value-plugin/",title:"Simple Value Plugin",description:"",content:""}),e.add({id:24,href:"/v1-1-0/docs/fixture-monkey-options/concepts/",title:"Concepts",description:`Before you learn about the options Fixture Monkey provides, there are a few things you need to know.
Property # In the documentation, the term property is consistently used instead of field when referring to the characteristics of a class&rsquo;s object. While it has the same name as &lsquo;property&rsquo; in Kotlin, the concept is different in Fixture Monkey.
Fixture Monkey&rsquo;s initial structure was primarily based on fields, which imposed limitations on configuration and control through methods and other mechanisms. For example, when relying solely on fields, it&rsquo;s not possible to access annotations on setter methods. To address this limitation, the Property interface was introduced, which extends support beyond just fields.
`,content:`Before you learn about the options Fixture Monkey provides, there are a few things you need to know.
Property # In the documentation, the term property is consistently used instead of field when referring to the characteristics of a class&rsquo;s object. While it has the same name as &lsquo;property&rsquo; in Kotlin, the concept is different in Fixture Monkey.
Fixture Monkey&rsquo;s initial structure was primarily based on fields, which imposed limitations on configuration and control through methods and other mechanisms. For example, when relying solely on fields, it&rsquo;s not possible to access annotations on setter methods. To address this limitation, the Property interface was introduced, which extends support beyond just fields.
A property in Fixture Monkey, functions as a fundamental component within a class and can represent a Field, Method, or Kotlin Property. It contains information about its Type, Annotations on it, and its name.
Moreover, in Fixture Monkey, the characteristics of both Objects and Containers are also expressed through the concept of property.
ObjectProperty # An ObjectProperty is a property that represents immutable object information. It includes:
property: The property of the object itself. propertyNameResolver: Determines how the property name is resolved. elementIndex: If the object is an element of a Container, it indicates the index. public final class ObjectProperty { private final Property property; private final PropertyNameResolver propertyNameResolver; @Nullable private final Integer elementIndex; } ContainerProperty # The property of a container type is represented by ContainerProperty, which describes immutable container information. It includes:
elementProperties: A list of element properties. containerInfo: TheArbitraryContainerInfo that determines the container&rsquo;s size. public final class ContainerProperty { private final List&lt;Property&gt; elementProperties; private final ArbitraryContainerInfo containerInfo; } Options # In Fixture Monkey, several options share common characteristics. For example, let&rsquo;s take a look at the options related to modifying the ObjectPropertyGenerator
defaultObjectPropertyGenerator, pushObjectPropertyGenerator, pushAssignableTypeObjectPropertyGenerator, pushExactTypeObjectPropertyGenerator
Options with the prefix default are applied as defaults to all properties generated by Fixture Monkey. These defaults set a basic behavior that affects all property types uniformly.
However, if you need to apply specific options for a particular type, you can make use of the options that start with push. There are three variations of these push options.
push~ : Accepts a MatcherOperator as a parameter. pushAssignableType~: This option applies the specified setting to every property type for which the given type (associated with the option) is assignable. This means that the option is applied not only to the exact given type but also to any type that can be assigned to the property type, including superclasses or superinterfaces. pushExactType~: This option limits the setting to properties with the exact same type. It does not impact properties with subtype or supertype relationships. It&rsquo;s important to note that options set using the push variants take precedence over the default options. This means that when a push option is defined for a specific type, it will override any corresponding default option for that type.
`}),e.add({id:25,href:"/v1-1-0/docs/plugins/simple-value-plugin/features/",title:"Features",description:`Fixture Monkey generates an arbitrary value to avoid edge case that could cause the problem. It may be useful in some situations, but it is useless in most situations. Especially it is embarrassing for beginners, who expect the readable and valid data.
Fixture Monkey provides a new Plugin SimpleValueJqwikPlugin for beginners, who expect the readable and valid value. It generates a readable and short String and narrow range of Number and Date value.
`,content:`Fixture Monkey generates an arbitrary value to avoid edge case that could cause the problem. It may be useful in some situations, but it is useless in most situations. Especially it is embarrassing for beginners, who expect the readable and valid data.
Fixture Monkey provides a new Plugin SimpleValueJqwikPlugin for beginners, who expect the readable and valid value. It generates a readable and short String and narrow range of Number and Date value.
It is compatible with other plugins such as JavaxValidationPlugin, JakartaValidationPlugin. It applies XXValidationPlugin if the property has the validation annotation, applies SimpleValueJqwikPlugin without it.
If you use the custom Plugin to constrain the generated value, the latter plugin would work.
For beginners who want to restrict the generated value, looking at the code of SimpleValueJqwikPlugin is a good start.
Default value # String # The plugin generates a short size of limited String whose length is 0 to 5.
alphabet number some special symbols allowed in HTTP query parameter ., -, _, ~ It can be customised by the options below.
minStringLength maxStringLength characterPredicate Number # The plugin generates a numeric number and decimal number in the range -10000 to 10000.
It can be customised, whether negative or positive, using the options below.
minNumberValue maxNumberValue Date # The plugin generates a Date in the range of last year to next year from today.
It can be customised on a per date basis, using the options below.
minusDaysFromToday plusDaysFromToday Container # The term of Container refers to the implementations of Collection such as List, Set, Iterator Iterable, and Map, Entry. The plugin generates a Container whose size is in the range of 0 to 3.
It can be customised by the options below.
minContainerSize maxContainerSize Plugin # val fixtureMonkey = FixtureMonkey.builder() .plugin(SimpleValueJqwikPlugin()) .build() `}),e.add({id:26,href:"/v1-1-0/docs/fixture-monkey-options/generation-options/",title:"Generation Options",description:`To create a complex object that matches your desired configurations, Fixture Monkey provides a variety of options for creating objects.
These options are accessible through the FixtureMonkeyBuilder.
Implement your own Object Generator # ObjectIntrospector # objectIntrospector
An ObjectIntrospector determines how Fixture Monkey creates objects. The objectIntrospector option allows you to specify the default behavior when generating an object.
As discussed in the introspector section, you can use predefined introspectors provided by Fixture Monkey or create your own custom introspector.
`,content:`To create a complex object that matches your desired configurations, Fixture Monkey provides a variety of options for creating objects.
These options are accessible through the FixtureMonkeyBuilder.
Implement your own Object Generator # ObjectIntrospector # objectIntrospector
An ObjectIntrospector determines how Fixture Monkey creates objects. The objectIntrospector option allows you to specify the default behavior when generating an object.
As discussed in the introspector section, you can use predefined introspectors provided by Fixture Monkey or create your own custom introspector.
📖 Notable implementations: 'BeanArbitraryIntrospector', 'BuilderArbitraryIntrospector' ArbitraryIntrospector # pushArbitraryIntrospector, pushAssignableTypeArbitraryIntrospector, pushExactTypeArbitraryIntrospector The ArbitraryIntrospector is responsible for defining how Fixture Monkey chooses the appropriate arbitrary generation strategy and generates an arbitrary. The object is then generated based on the generated arbitrary. You have the flexibility to create a custom introspector by implementing your own ArbitraryIntrospector.
If you need to change the ArbitraryIntrospector for a specific type, you can use the above options.
📖 Notable implementations: 'BooleanIntrospector', 'EnumIntrospector' ContainerIntrospector # pushContainerIntrospector
Especially for container types, you can change the ArbitraryIntrospector using the pushContainerIntrospector option.
📖 Notable implementations: 'ListIntrospector', 'MapIntrospector' ArbitraryGenerator # defaultArbitraryGenerator
Although the ArbitraryIntrospector determines the appropriate arbitrary generation strategy, the actual creation of the final arbitrary(CombinableArbitrary) is done by the ArbitraryGenerator. It handles the request by delegating to the ArbitraryIntrospector. By using the defaultArbitraryGenerator option, you have the capability to customize the behavior of the ArbitraryGenerator.
For instance, you can create an arbitrary generator that produces unique values, as shown in the example below:
Java Kotlin public static class UniqueArbitraryGenerator implements ArbitraryGenerator { private static final Set&lt;Object&gt; UNIQUE = new HashSet&lt;&gt;(); private final ArbitraryGenerator delegate; public UniqueArbitraryGenerator(ArbitraryGenerator delegate) { this.delegate = delegate; } @Override public CombinableArbitrary generate(ArbitraryGeneratorContext context) { return delegate.generate(context) .filter( obj -&gt; { if (!UNIQUE.contains(obj)) { UNIQUE.add(obj); return true; } return false; } ); } } FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .defaultArbitraryGenerator(UniqueArbitraryGenerator::new) .build(); class UniqueArbitraryGenerator(private val delegate: ArbitraryGenerator) : ArbitraryGenerator { companion object { private val UNIQUE = HashSet&lt;Any&gt;() } override fun generate(context: ArbitraryGeneratorContext): CombinableArbitrary { return delegate.generate(context) .filter { obj -&gt; if (!UNIQUE.contains(obj)) { UNIQUE.add(obj) true } else { false } } } } val fixtureMonkey = FixtureMonkey.builder() .defaultArbitraryGenerator { UniqueArbitraryGenerator(it) } .build() 📖 Notable implementations: 'IntrospectedArbitraryGenerator', 'CompositeArbitraryGenerator' Implement your own Property # PropertyGenerator # defaultPropertyGenerator, pushPropertyGenerator, pushAssignableTypePropertyGenerator, pushExactTypePropertyGenerator
PropertyGenerator creates child properties of the given ObjectProperty. The child property can be a field, JavaBeans property, method or constructor parameter within the parent ObjectProperty. There are scenarios where you might want to customize how these child properties are generated.
The PropertyGenerator options allow you to specify how child properties of each type are generated. This option is mainly used when you want to exclude generating some properties when the parent property has abnormal child properties.
📖 Notable implementations: 'FieldPropertyGenerator', 'JavaBeansPropertyGenerator' ObjectPropertyGenerator # defaultObjectPropertyGenerator, pushObjectPropertyGenerator, pushAssignableTypeObjectPropertyGenerator, pushExactTypeObjectPropertyGenerator
ObjectPropertyGenerator generates the ObjectProperty based on a given context. With options related to ObjectPropertyGenerator you can customize how the ObjectProperty is generated.
📖 Notable implementations: 'DefaultObjectPropertyGenerator' ContainerPropertyGenerator # pushContainerPropertyGenerator, pushAssignableTypeContainerPropertyGenerator, pushExactTypeContainerPropertyGenerator
The ContainerPropertyGenerator determines how to generate ContainerProperty within a given context. With options related to ContainerPropertyGenerator you can customize how the ContainerProperty is generated.
📖 Notable implementations: 'ArrayContainerPropertyGenerator', 'MapContainerPropertyGenerator' Exclude Classes or Packages from Generation # pushExceptGenerateType, addExceptGenerateClass, addExceptGenerateClasses, addExceptGeneratePackage, addExceptGeneratePackages
If you want to exclude the generation of certain types or packages, you can use these options.
Java Kotlin @Test void testExcludeClass() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .addExceptGenerateClass(String.class) .build(); String actual = sut.giveMeOne(Product.class) .getProductName(); then(actual).isNull(); } @Test void testExcludePackage() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .addExceptGeneratePackage(&#34;java.lang&#34;) .build(); String actual = sut.giveMeOne(String.class); then(actual).isNull(); } @Test fun testExcludeClass() { val fixtureMonkey = FixtureMonkey.builder() .addExceptGenerateClass(String::class.java) .build() val actual = fixtureMonkey.giveMeOne&lt;Product&gt;() .productName then(actual).isNull() } @Test fun testExcludePackage() { val fixtureMonkey = FixtureMonkey.builder() .addExceptGeneratePackage(&#34;java.lang&#34;) .build() val actual = fixtureMonkey.giveMeOne&lt;String&gt;() then(actual).isNull() } Modify Containers # Container Size # defaultArbitraryContainerInfoGenerator, pushArbitraryContainerInfoGenerator
ArbitraryContainerInfo holds information about the minimum and maximum sizes of a Container type. You can change the behavior by modifying the ArbitraryContainerInfoGenerator using related options.
The following example demonstrates how to customize ArbitraryContainerInfo to set the size of all container types to 3.
Java Kotlin @Test void test() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .defaultArbitraryContainerInfoGenerator(context -&gt; new ArbitraryContainerInfo(3, 3)) .build(); List&lt;String&gt; actual = fixtureMonkey.giveMeOne(); then(actual).hasSize(3); } @Test fun test() { val fixtureMonkey = FixtureMonkey.builder() .defaultArbitraryContainerInfoGenerator { context -&gt; ArbitraryContainerInfo(3, 3) } .build() val actual: List&lt;String&gt; = fixtureMonkey.giveMeOne() then(actual).hasSize(3) } Adding Container type # addContainerType
You can add a new custom Container type using the addContainerType option.
Let&rsquo;s say you made a new custom Pair class in Java.
You can use this container type by implementing a custom ContainerPropertyGenerator, Introspector and DecomposedContainerValueFactory.
FixtureMonkey fixtureMonkey=FixtureMonkey.builder() .addContainerType( Pair.class, new PairContainerPropertyGenerator(), new PairIntrospector(), new PairDecomposedContainerValueFactory() ) .build(); custom Introspector:
public class PairIntrospector implements ArbitraryIntrospector, Matcher { private static final Matcher MATCHER = new AssignableTypeMatcher(Pair.class); @Override public boolean match(Property property) { return MATCHER.match(property); } @Override public ArbitraryIntrospectorResult introspect(ArbitraryGeneratorContext context) { ArbitraryProperty property = context.getArbitraryProperty(); ArbitraryContainerInfo containerInfo = property.getContainerProperty().getContainerInfo(); if (containerInfo == null) { return ArbitraryIntrospectorResult.EMPTY; } List&lt;Arbitrary&lt;?&gt;&gt; childrenArbitraries = context.getChildrenArbitraryContexts().getArbitraries(); BuilderCombinator&lt;List&lt;Object&gt;&gt; builderCombinator = Builders.withBuilder(ArrayList::new); for (Arbitrary&lt;?&gt; childArbitrary : childrenArbitraries) { builderCombinator = builderCombinator.use(childArbitrary).in((list, element) -&gt; { list.add(element); return list; }); } return new ArbitraryIntrospectorResult( builderCombinator.build(it -&gt; new Pair&lt;&gt;(it.get(0), it.get(1))) ); } } custom ContainerPropertyGenerator:
public class PairContainerPropertyGenerator implements ContainerPropertyGenerator { @Override public ContainerProperty generate(ContainerPropertyGeneratorContext context) { com.navercorp.fixturemonkey.api.property.Property property = context.getProperty(); List&lt;AnnotatedType&gt; elementTypes = Types.getGenericsTypes(property.getAnnotatedType()); if (elementTypes.size() != 2) { throw new IllegalArgumentException( &quot;Pair elementsTypes must be have 1 generics type for element. &quot; + &quot;propertyType: &quot; + property.getType() + &quot;, elementTypes: &quot; + elementTypes ); } AnnotatedType firstElementType = elementTypes.get(0); AnnotatedType secondElementType = elementTypes.get(1); List&lt;com.navercorp.fixturemonkey.api.property.Property&gt; elementProperties = new ArrayList&lt;&gt;(); elementProperties.add( new ElementProperty( property, firstElementType, 0, 0 ) ); elementProperties.add( new ElementProperty( property, secondElementType, 1, 1 ) ); return new ContainerProperty( elementProperties, new ArbitraryContainerInfo(1, 1, false) ); } } custom DecomposedContainerValueFactory:
public class PairDecomposedContainerValueFactory implements DecomposedContainerValueFactory { @Override public DecomposedContainerValue from(Object object) { Pair&lt;?, ?&gt; pair = (Pair&lt;?, ?&gt;)obj; List&lt;Object&gt; list = new ArrayList&lt;&gt;(); list.add(pair.getFirst()); list.add(pair.getSecond()); return new DecomposableContainerValue(list, 2); } } Customize Arbitrary Validation # arbitraryValidator
The arbitraryValidator option allows you to replace the default arbitraryValidator with your own custom arbitrary validator.
When an instance is sampled, the arbitraryValidator validates the arbitrary, and if it is invalid, it throws an exception. This process is repeated 1,000 times, and if the instance is still invalid, a TooManyFilterMissesException would be thrown.
📖 Notable implementations: 'JakartaArbitraryValidator', 'JavaxArbitraryValidator' Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .arbitraryValidator(obj -&gt; { throw new ValidationFailedException(&#34;thrown by custom ArbitraryValidator&#34;, new HashSet&lt;&gt;()); }) .build(); thenThrownBy(() -&gt; fixtureMonkey.giveMeOne(String.class)) .isExactlyInstanceOf(FilterMissException.class); val fixtureMonkey = FixtureMonkey.builder() .arbitraryValidator { obj -&gt; throw ValidationFailedException(&#34;thrown by custom ArbitraryValidator&#34;, HashSet()) } .build() assertThatThrownBy { fixtureMonkey.giveMeOne&lt;String&gt;() } .isExactlyInstanceOf(FilterMissException::class.java) Modify Arbitrary Generation Retry Limits # generateMaxTries, generateUniqueMaxTries
The generateMaxTries option allows you to control the maximum number of attempts to generate a valid object from an arbitrary. If an object cannot be generated successfully after exceeding this limit (default is 1,000 attempts), a TooManyFilterMissesException will be thrown.
Additionally, Fixture Monkey ensures the generation of unique values for map keys and set elements. The generateUniqueMaxTries option allows you to specify the maximum number of attempts (also defaults to 1,000) that will be made to generate this unique value.
Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .generateMaxTries(100) .generateUniqueMaxTries(100) .build(); val fixtureMonkey = FixtureMonkey.builder() .generateMaxTries(100) .generateUniqueMaxTries(100) .build() Implement Interfaces # 🔔 The following options are provided by InterfacePlugin interfaceImplements
interfaceImplements is an option used to specify the available implementations for an interface.
When you don&rsquo;t specify this option, an ArbitraryBuilder for an interface will always result in a null value when sampled. However, when you do specify this option, Fixture Monkey will randomly generate one of the specified implementations whenever an ArbitraryBuilder for the interface is sampled.
Java Kotlin interface FixedValue { Object get(); } class IntegerFixedValue implements FixedValue { @Override public Object get() { return 1; } } class StringFixedValue implements FixedValue { @Override public Object get() { return &#34;fixed&#34;; } } class GenericFixedValue&lt;T&gt; { T value; } @Test void sampleGenericInterface() { // given List&lt;Class&lt;? extends FixedValue&gt;&gt; implementations = new ArrayList&lt;&gt;(); implementations.add(IntegerFixedValue.class); implementations.add(StringFixedValue.class); FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new InterfacePlugin().interfaceImplements(FixedValue.class, implementations)) .build(); // when Object actual = fixtureMonkey.giveMeBuilder(new TypeReference&lt;GenericGetFixedValue&lt;FixedValue&gt;&gt;() {}) .setNotNull(&#34;value&#34;) .sample() .getValue() .get(); // then then(actual).isIn(1, &#34;fixed&#34;); } interface FixedValue { fun get(): Any } class IntegerFixedValue : FixedValue { override fun get(): Any { return 1 } } class StringFixedValue : FixedValue { override fun get(): Any { return &#34;fixed&#34; } } class GenericFixedValue&lt;T&gt; { val value: T } @Test fun sampleGenericInterface() { // given val implementations: MutableList&lt;Class&lt;out FixedValue&gt;&gt; = List.of(IntegerFixedValue::class.java, StringFixedValue::class.java) val fixtureMonkey = FixtureMonkey.builder() .plugin(InterfacePlugin().interfaceImplements(FixedValue::class.java, implementations)) .build() // when val actual = fixtureMonkey.giveMeBuilder&lt;GenericGetFixedValue&lt;FixedValue&gt;&gt;() .sample() .getValue() .get() // then then(actual).isIn(1, &#34;fixed&#34;) } `}),e.add({id:27,href:"/v1-1-0/docs/fixture-monkey-options/customization-options/",title:"Customization Options",description:`Fixture Monkey also provides options through the FixtureMonkeyBuilder to customize objects to have the desired values or to use custom property names.
Change how property names are resolved # defaultPropertyNameResolver, pushPropertyNameResolver, pushAssignableTypePropertyNameResolver, pushExactTypePropertyNameResolver
Options related to the PropertyNameResolver allow you to customize how you refer to your properties.
The defaultPropertyNameResolver option is used to change the way property names are figured out for all types. If you want to make specific changes for certain types, you can use pushPropertyNameResolver, pushAssignableTypePropertyNameResolver, or pushExactTypePropertyNameResolver.
`,content:`Fixture Monkey also provides options through the FixtureMonkeyBuilder to customize objects to have the desired values or to use custom property names.
Change how property names are resolved # defaultPropertyNameResolver, pushPropertyNameResolver, pushAssignableTypePropertyNameResolver, pushExactTypePropertyNameResolver
Options related to the PropertyNameResolver allow you to customize how you refer to your properties.
The defaultPropertyNameResolver option is used to change the way property names are figured out for all types. If you want to make specific changes for certain types, you can use pushPropertyNameResolver, pushAssignableTypePropertyNameResolver, or pushExactTypePropertyNameResolver.
By default, a property will be referenced by its original name. Let&rsquo;s take a look at the following example to see how we can customize the property name:
Java Kotlin @Data // getter, setter public class Product { String productName; } @Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .pushPropertyNameResolver(MatcherOperator.exactTypeMatchOperator(String.class, (property) -&gt; &#34;string&#34;)) .build(); String expected = &#34;test&#34;; // when String actual = fixtureMonkey.giveMeBuilder(Product.class) .set(&#34;string&#34;, expected) .sample() .getProductName(); // then then(actual).isEqualTo(expected); } data class Product ( val productName: String ) @Test fun test() { // given val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .pushPropertyNameResolver( MatcherOperator.exactTypeMatchOperator(String::class.java, PropertyNameResolver { &#34;string&#34; }) ) .build() val expected = &#34;test&#34; // when val actual: String = fixtureMonkey.giveMeBuilder&lt;Product&gt;() .set(&#34;string&#34;, expected) .sample() .productName // then then(actual).isEqualTo(expected) } Normally, the property name will resolve to the original property name &ldquo;productName&rdquo;. However, with pushPropertyNameResolver the String type properties are now referred to by the name &ldquo;string&rdquo;.
Register a default ArbitraryBuilder for a given type # register, registerGroup, registerExactType, registerAssignableType
Sometimes your class may need to consistently match certain constraints. It can be inconvenient and result in lengthy code if you always have to modify the ArbitraryBuilder using customization APIs. In such cases, you can set a default ArbitraryBuilder for a class that will satisfy all the basic constraints.
The register option helps to register an ArbitraryBuilder for a specific type.
For example, the following code demonstrates how to register an ArbitraryBuilder for a Product class. By doing so, all Product instances created by FixtureMonkey will have an id value greater than or equal to &ldquo;0&rdquo;.
Java Kotlin FixtureMonkey.builder() .register( Product.class, fixture -&gt; fixture.giveMeBuilder(Product.class) .set(&#34;id&#34;, Arbitraries.longs().greaterOrEqual(0)) ) .build(); FixtureMonkey.builder() .register(Product::class.java) { it.giveMeBuilder&lt;Product&gt;() .set(&#34;id&#34;, Arbitraries.longs().greaterOrEqual(0)) } .build() If you want to register several ArbitraryBuilders at once, you can use the registerGroup option. This can be done using either reflection or the ArbitraryBuilderGroup interface.
Using reflection: Java Kotlin public class GenerateGroup { public ArbitraryBuilder&lt;GenerateString&gt; generateString(FixtureMonkey fixtureMonkey) { return fixtureMonkey.giveMeBuilder(GenerateString.class) .set(&#34;value&#34;, Arbitraries.strings().numeric()); } public ArbitraryBuilder&lt;GenerateInt&gt; generateInt(FixtureMonkey fixtureMonkey) { return fixtureMonkey.giveMeBuilder(GenerateInt.class) .set(&#34;value&#34;, Arbitraries.integers().between(1, 100)); } } FixtureMonkey.builder() .registerGroup(GenerateGroup.class) .build(); class GenerateGroup { fun generateString(fixtureMonkey: FixtureMonkey): ArbitraryBuilder&lt;GenerateString&gt; { return fixtureMonkey.giveMeBuilder&lt;GenerateString&gt;() .set(&#34;value&#34;, Arbitraries.strings().numeric()) } fun generateInt(fixtureMonkey: FixtureMonkey): ArbitraryBuilder&lt;GenerateInt&gt; { return fixtureMonkey.giveMeBuilder&lt;GenerateInt&gt;() .set(&#34;value&#34;, Arbitraries.integers().between(1, 100)) } } FixtureMonkey.builder() .registerGroup(GenerateGroup::class.java) .build() Using ArbitraryBuilderGroup interface:
Java Kotlin public class GenerateBuilderGroup implements ArbitraryBuilderGroup { @Override public ArbitraryBuilderCandidateList generateCandidateList() { return ArbitraryBuilderCandidateList.create() .add( ArbitraryBuilderCandidateFactory.of(GenerateString.class) .builder( arbitraryBuilder -&gt; arbitraryBuilder .set(&#34;value&#34;, Arbitraries.strings().numeric()) ) ) .add( ArbitraryBuilderCandidateFactory.of(GenerateInt.class) .builder( builder -&gt; builder .set(&#34;value&#34;, Arbitraries.integers().between(1, 100)) ) ); } } FixtureMonkey.builder() .registerGroup(new GenerateBuilderGroup()) .build(); class GenerateBuilderGroup : ArbitraryBuilderGroup { override fun generateCandidateList(): ArbitraryBuilderCandidateList { return ArbitraryBuilderCandidateList.create() .add( ArbitraryBuilderCandidateFactory.of(GenerateString::class.java) .builder { it.set(&#34;value&#34;, Arbitraries.strings().numeric()) } ) .add( ArbitraryBuilderCandidateFactory.of(GenerateInt::class.java) .builder { it.set(&#34;value&#34;, Arbitraries.integers().between(1, 100)) } ) } } FixtureMonkey.builder() .registerGroup(GenerateBuilderGroup()) .build() Use expression strict mode # useExpressionStrictMode
When using expressions (especially String Expressions), it&rsquo;s hard to know if the expression you&rsquo;ve written has a matching property, and the property is correctly adjusted. Using the useExpressionStrictMode option will throw an IllegalArgumentException if the expression you wrote doesn&rsquo;t have a matching property.
Java Kotlin @Test void test() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder().useExpressionStrictMode().build(); thenThrownBy( () -&gt; fixtureMonkey.giveMeBuilder(String.class) .set(&#34;nonExistentField&#34;, 0) .sample() ).isExactlyInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&#34;No matching results for given NodeResolvers.&#34;); } @Test fun test() { val fixtureMonkey = FixtureMonkey.builder().useExpressionStrictMode().build() assertThatThrownBy { fixtureMonkey.giveMeBuilder&lt;String&gt;() .set(&#34;nonExistentField&#34;, 0) .sample() }.isExactlyInstanceOf(IllegalArgumentException::class.java) .hasMessageContaining(&#34;No matching results for given NodeResolvers.&#34;) } Constrain Java types # javaTypeArbitraryGenerator, javaTimeTypeArbitraryGenerator
You can modify the default values for Java primitive types (such as strings, integers, doubles, etc.) by implementing a custom JavaTypeArbitraryGenerator interface. This option can be applied through the JqwikPlugin.
For example, by default, string types generated with Fixture Monkey have unreadable data because it considers edge cases such as when control blocks are contained in strings.
If you prefer to generate strings consisting only of alphabetic characters, you can override the JavaTypeArbitraryGenerator as demonstrated below:
Java Kotlin FixtureMonkey.builder() .plugin( new JqwikPlugin() .javaTypeArbitraryGenerator(new JavaTypeArbitraryGenerator() { @Override public StringArbitrary strings() { return Arbitraries.strings().alpha(); } }) ) .build(); FixtureMonkey.builder() .plugin( JqwikPlugin() .javaTypeArbitraryGenerator(object : JavaTypeArbitraryGenerator { override fun strings(): StringArbitrary = Arbitraries.strings().alpha() }) ) .build() For Java time types, you can use javaTimeTypeArbitraryGenerator.
Constrain Java types with annotations # javaArbitraryResolver, javaTimeArbitraryResolver
Similar to using the javax-validation plugin and adding constraints to your Java typed properties, you can apply constraints to Java types using annotations. To do this, you can implement a JavaArbitraryResolver interface. This option can be applied through the JqwikPlugin.
For example, if you have a custom annotation named MaxLengthOf10, which means that the length of a property should be limited to a maximum of 10 characters, you can create a JavaArbitraryResolver as shown below:
Java Kotlin FixtureMonkey.builder() .plugin( new JqwikPlugin() .javaArbitraryResolver(new JavaArbitraryResolver() { @Override public Arbitrary&lt;String&gt; strings(StringArbitrary stringArbitrary, ArbitraryGeneratorContext context) { if (context.findAnnotation(MaxLengthof10.class).isPresent()) { return stringArbitrary.ofMaxLength(10); } return stringArbitrary; } }) ) .build(); FixtureMonkey.builder() .plugin( JqwikPlugin() .javaArbitraryResolver(object : JavaArbitraryResolver { override fun strings(stringArbitrary: StringArbitrary, context: ArbitraryGeneratorContext): Arbitrary&lt;String&gt; { if (context.findAnnotation(MaxLengthof10::class.java).isPresent) { return stringArbitrary.ofMaxLength(10) } return stringArbitrary } }) ) .build() Change Nullability # defaultNotNull # defaultNotNull, nullableContainer, nullableElement
When you want to ensure that the properties of your instance are not null, you can utilize the options mentioned below.
defaultNotNull determines whether a null property is generated. If true, property cannot be null nullableContainer determines whether a container property can be null. If true, container can be null nullableElement determines whether an element within a container property can be null. If true, element can be null. By default, these three options are set to false. You can modify them to true as needed.
🚨 These options only apply to properties that do not have a nullable marker, such as @Nullable in Java or ? in Kotlin. Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder().defaultNotNull(true).build(); FixtureMonkey fixtureMonkey = FixtureMonkey.builder().nullableContainer(true).build(); FixtureMonkey fixtureMonkey = FixtureMonkey.builder().nullableElement(true).build(); val fixtureMonkey = FixtureMonkey.builder().defaultNotNull(true).build() val fixtureMonkey = FixtureMonkey.builder().nullableContainer(true).build() val fixtureMonkey = FixtureMonkey.builder().nullableElement(true).build() NullInjectGenerator # defaultNullInjectGenerator, pushNullInjectGenerator, pushExactTypeNullInjectGenerator, pushAssignableTypeNullInjectGenerator
In cases where a property should be null regardless of any nullable markers, you can make use of the options associated with the NullInjectGenerator.
The defaultnullInjectGenerator option allows you to set the probability of properties being null.
By default, the probability of a property being null is set to 20%.
If you want it to always be null, you can set it to 1.0d. There are predefined values available in the DefaultNullInjectGenerator—NOT_NULL_INJECT(0.0d) and ALWAYS_NULL_INJECT(1.0d)—which you can import and use.
Alternatively, for more customized behavior, you can implement your own NullInjectGenerator.
Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .defaultNullInjectGenerator((context) -&gt; NOT_NULL_INJECT) // you can use NOT_NULL_INJECT or write your probability as 0.4 .build() val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .defaultNullInjectGenerator { NOT_NULL_INJECT } // you can use NOT_NULL_INJECT or write your probability as 0.4 .build() If you want to specifically change the probability of a certain type being null, you can use pushNullInjectGenerator.
Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .pushNullInjectGenerator(MatcherOperator.exactTypeMatchOperator(SimpleObject.class, (context) -&gt; NOT_NULL_INJECT)) .build(); val fixtureMonkey = FixtureMonkey.builder() .pushNullInjectGenerator( exactTypeMatchOperator( Product::class.java, NullInjectGenerator { context -&gt; NOT_NULL_INJECT } ) ) .build() Registering an ArbitraryBuilder of a specific class with register that has the .setNotNull(&quot;*&quot;) setting will have the same effect.
`}),e.add({id:28,href:"/v1-1-0/docs/fixture-monkey-options/other-options/",title:"Other Options",description:`This section explains some additional options that the FixtureMonkeyBuilder provide.
Add plugins # Fixture Monkey offers several additional features, including support for third-party libraries through plugins. You can use the plugin option to use these additional features.
For example, you can add the Jackson plugin as shown below. This will allow you to use Jackson features such as JacksonObjectArbitraryIntrospector and Jackson annotation support.
Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .build(); val fixtureMonkey = FixtureMonkey.builder() .plugin(JacksonPlugin()) .build() `,content:`This section explains some additional options that the FixtureMonkeyBuilder provide.
Add plugins # Fixture Monkey offers several additional features, including support for third-party libraries through plugins. You can use the plugin option to use these additional features.
For example, you can add the Jackson plugin as shown below. This will allow you to use Jackson features such as JacksonObjectArbitraryIntrospector and Jackson annotation support.
Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .build(); val fixtureMonkey = FixtureMonkey.builder() .plugin(JacksonPlugin()) .build() `}),e.add({id:29,href:"/v1-1-0/docs/plugins/kotlin-plugin/",title:"Kotlin Plugin",description:"",content:""}),e.add({id:30,href:"/v1-1-0/docs/plugins/",title:"Plugins",description:"",content:""}),e.add({id:31,href:"/v1-1-0/docs/plugins/kotlin-plugin/features/",title:"Features",description:`To help you take full advantage of the concise, safe, and pragmatic nature of Kotlin, Fixture Monkey provides a Kotlin plugin.
Using PrimaryConstructorArbitraryIntrospector as the default introspector to generate Kotlin classes with its primary constructor. Fixture Monkey Extension Functions Kotlin DSL Exp, Kotlin instantiateBy DSL Dependencies # fixture-monkey-kotlin # Gradle # testImplementation(&quot;com.navercorp.fixturemonkey:fixture-monkey-kotlin:1.1.10&quot;) Maven # &lt;dependency&gt; &lt;groupId&gt;com.navercorp.fixturemonkey&lt;/groupId&gt; &lt;artifactId&gt;fixture-monkey-kotlin&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; fixture-monkey-starter-kotlin # To help you get started using Fixture Monkey in a Kotlin environment, there is also a starter dependency fixture-monkey-starter-kotlin that comes with pre-configured dependencies such as fixture-monkey-starter or fixture-monkey-jakarta-validation.
`,content:`To help you take full advantage of the concise, safe, and pragmatic nature of Kotlin, Fixture Monkey provides a Kotlin plugin.
Using PrimaryConstructorArbitraryIntrospector as the default introspector to generate Kotlin classes with its primary constructor. Fixture Monkey Extension Functions Kotlin DSL Exp, Kotlin instantiateBy DSL Dependencies # fixture-monkey-kotlin # Gradle # testImplementation(&quot;com.navercorp.fixturemonkey:fixture-monkey-kotlin:1.1.10&quot;) Maven # &lt;dependency&gt; &lt;groupId&gt;com.navercorp.fixturemonkey&lt;/groupId&gt; &lt;artifactId&gt;fixture-monkey-kotlin&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; fixture-monkey-starter-kotlin # To help you get started using Fixture Monkey in a Kotlin environment, there is also a starter dependency fixture-monkey-starter-kotlin that comes with pre-configured dependencies such as fixture-monkey-starter or fixture-monkey-jakarta-validation.
Gradle # testImplementation(&quot;com.navercorp.fixturemonkey:fixture-monkey-starter-kotlin:1.1.10&quot;) Maven # &lt;dependency&gt; &lt;groupId&gt;com.navercorp.fixturemonkey&lt;/groupId&gt; &lt;artifactId&gt;fixture-monkey-starter-kotlin&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; Plugin # val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .build() `}),e.add({id:32,href:"/v1-1-0/docs/plugins/kotlin-plugin/introspectors-for-kotlin/",title:"Introspectors for Kotlin",description:`Fixture Monkey provides some additional introspectors that support the generation of Kotlin classes.
PrimaryConstructorArbitraryIntrospector # The PrimaryConstructorArbitraryIntrospector becomes the default introspector when the Kotlin plugin is added. It creates a Kotlin class with its primary constructor.
In the case of using PrimaryConstructorArbitraryIntrospector, it only contains the properties of the Kotlin constructor parameter.
If you use your own ArbitraryIntrospector instead of PrimaryConstructorArbitraryIntrospector, it will contain the properties of the Kotlin constructor parameter, Field, Getter. So it contains the properties of the parent Field and Getter. You can customize the all properties by ArbitraryBuilder APIs.
`,content:`Fixture Monkey provides some additional introspectors that support the generation of Kotlin classes.
PrimaryConstructorArbitraryIntrospector # The PrimaryConstructorArbitraryIntrospector becomes the default introspector when the Kotlin plugin is added. It creates a Kotlin class with its primary constructor.
In the case of using PrimaryConstructorArbitraryIntrospector, it only contains the properties of the Kotlin constructor parameter.
If you use your own ArbitraryIntrospector instead of PrimaryConstructorArbitraryIntrospector, it will contain the properties of the Kotlin constructor parameter, Field, Getter. So it contains the properties of the parent Field and Getter. You can customize the all properties by ArbitraryBuilder APIs.
For example, if you apply the JacksonPlugin after applying the KotlinPlugin, you can generate an instance of the Kotlin type by Jackson. In this case, you can customize the parent fields.
Example Kotlin Class :
data class Product ( val id: Long?, val productName: String, val price: Long, val options: List&lt;String&gt;, val createdAt: Instant ) Using PrimaryConstructorArbitraryIntrospector :
@Test fun test() { val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .build() val product: Product = fixtureMonkey.giveMeOne() } KotlinAndJavaCompositeArbitraryIntrospector # The KotlinAndJavaCompositeArbitraryIntrospector is an introspector designed to assist in the creation of Kotlin classes that reference Java classes.
Example Kotlin Class :
class KotlinClassWithJavaClass(val javaObject: JavaObject) Example Java Class :
public class JavaObject { private String value; private Map&lt;String, String&gt; map; public JavaObject() { } public String getValue() { return value; } public void setValue(String value) { this.value = value; } public Map&lt;String, String&gt; getMap() { return map; } public void setMap(Map&lt;String, String&gt; map) { this.map = map; } } Using PrimaryConstructorArbitraryIntrospector :
fun kotlinClassWithJavaClass() { // given val sut: FixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .objectIntrospector(KotlinAndJavaCompositeArbitraryIntrospector()) .build() // when val actual = sut.giveMeOne&lt;KotlinClassWithJavaClass&gt;() then(actual).isNotNull then(actual.javaObject).isNotNull } For Kotlin and Java classes respectively, it uses the PrimaryConstructorArbitraryIntrospector and the BeanArbitraryIntrospector by default.
If changes are desired, these can be injected as arguments.
// given val sut: FixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .objectIntrospector( KotlinAndJavaCompositeArbitraryIntrospector( kotlinArbitraryIntrospector = PrimaryConstructorArbitraryIntrospector.INSTANCE, javaArbitraryIntrospector = ConstructorPropertiesArbitraryIntrospector.INSTANCE ) ) .build() `}),e.add({id:33,href:"/v1-1-0/docs/plugins/kotlin-plugin/kotlin-exp/",title:"Kotlin DSL Exp",description:`Fixture Monkey utilizes Kotlin&rsquo;s DSL feature to ensure type-safety with expressions. Let&rsquo;s explore how we can employ Kotlin Exp instead of the standard Java String Expression.
Referencing a property # Suppose we have an object structure similar to the one described earlier, written in both Java and Kotlin:
@Value public class JavaClass { String field; List&lt;String&gt; list; Nested nestedObject; List&lt;Nested&gt; nestedObjectList; @Value public static class Nested { String nestedField; } } data class KotlinClass( val field: String, val list: List&lt;String&gt;, val nestedObject: Nested, val nestedObjectList: List&lt;Nested&gt; ) { data class Nested( val nestedField: String ) } To use Kotlin Exp to reference a property, you need to use the Exp or ExpGetter suffix to the normal Fixture Customization APIs.
`,content:`Fixture Monkey utilizes Kotlin&rsquo;s DSL feature to ensure type-safety with expressions. Let&rsquo;s explore how we can employ Kotlin Exp instead of the standard Java String Expression.
Referencing a property # Suppose we have an object structure similar to the one described earlier, written in both Java and Kotlin:
@Value public class JavaClass { String field; List&lt;String&gt; list; Nested nestedObject; List&lt;Nested&gt; nestedObjectList; @Value public static class Nested { String nestedField; } } data class KotlinClass( val field: String, val list: List&lt;String&gt;, val nestedObject: Nested, val nestedObjectList: List&lt;Nested&gt; ) { data class Nested( val nestedField: String ) } To use Kotlin Exp to reference a property, you need to use the Exp or ExpGetter suffix to the normal Fixture Customization APIs.
Let&rsquo;s look at the example of customizing properties with Kotlin Exp using setExp() and setExpGetter().
@Test fun test() { // given val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .plugin(JacksonPlugin()) .build() // when val javaClass = fixtureMonkey.giveMeBuilder&lt;JavaClass&gt;() .setExpGetter(JavaClass::getField, &quot;field&quot;) .sample() val kotlinClass = fixtureMonkey.giveMeBuilder&lt;KotlinClass&gt;() .setExp(KotlinClass::field, &quot;field&quot;) .sample() // then then(javaClass.field).isEqualTo(&quot;field&quot;) then(kotlinClass.field).isEqualTo(&quot;field&quot;) } In the code above, we can see that we are using Kotlin&rsquo;s method reference to select a property.
setExp() takes an argument of type KProperty, while setExpGetter() takes an argument of type KFunction.
If the class is defined in Java, the expression (e.g. JavaClass::getField) is of type KFunction because it is a reference to a Java getter. Therefore you can only use the setExpGetter() method.
If it is a Kotlin class, the expression (e.g. KotlinClass::field) is KProperty, so you should use setExp().
Referencing a nested property # To access a nested field, the infix functions into and intoGetter are used. into takes a parameter of type KProperty, while intoGetter takes a parameter of type KFunction.
@Test fun test() { // given val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .plugin(JacksonPlugin()) .build() // when val javaClass = fixtureMonkey.giveMeBuilder&lt;JavaClass&gt;() .setExp(JavaClass::getNestedObject intoGetter JavaClass.Nested::getNestedField, &quot;nestedField&quot;) .sample() val kotlinClass = fixtureMonkey.giveMeBuilder&lt;KotlinClass&gt;() .setExp(KotlinClass::nestedObject into KotlinClass.Nested::nestedField, &quot;nestedField&quot;) .sample() then(javaClass.nestedObject.nestedField).isEqualTo(&quot;nestedField&quot;) then(kotlinClass.nestedObject.nestedField).isEqualTo(&quot;nestedField&quot;) } An expression that contains an into or intoGetter operator becomes an ExpressionGenerator type in fixture monkey. Both setExp() and setExpGetter()) are defined to take ExpressionGenerator types as arguments, so you can use both.
Selecting Properties Using Kotlin DSL Expressions # Selecting the root object: # Currently Not Supported Selecting a specific field: # JavaClass::getField // java class KotlinClass::field // kotlin class Selecting a nested field: # JavaClass::getNestedObject intoGetter JavaClass.Nested::getNestedField // java class KotlinClass::nestedObject into KotlinClass.Nested::nestedField // kotlin class Selecting the n-th element of a collection: # JavaClass::getNestedObjectList[&quot;0&quot;] // java class KotlinClass::nestedObjectList[&quot;0&quot;] // kotlin class Selecting all elements of a collection: # JavaClass::getNestedObjectList[&quot;*&quot;] // java class KotlinClass::nestedObjectList[&quot;*&quot;] // kotlin class Combining expressions to select a nested field: # JavaClass::getNestedObject intoGetter JavaClass.Nested::getNestedField // java class KotlinClass::nestedObject into KotlinClass.Nested::nestedField // kotlin class `}),e.add({id:34,href:"/v1-1-0/docs/plugins/jackson-plugin/",title:"Jackson Plugin",description:"",content:""}),e.add({id:35,href:"/v1-1-0/docs/plugins/jackson-plugin/features/",title:"Features",description:`Fixture monkey supports Jackson with the Fixture Monkey Jackson plugin.
Supports the use of JacksonObjectArbitraryIntrospector as the default introspector to create objects using the Jackson object mapper. Supports Jackson Annotations such as, @JsonIgnore, @JsonProperty Dependencies # Gradle # testImplementation(&quot;com.navercorp.fixturemonkey:fixture-monkey-jackson:1.1.10&quot;) Maven # &lt;dependency&gt; &lt;groupId&gt;com.navercorp.fixturemonkey&lt;/groupId&gt; &lt;artifactId&gt;fixture-monkey-jackson&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; Plugin # Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .build(); val fixtureMonkey = FixtureMonkey.builder() .plugin(JacksonPlugin()) .build() Pass the object mapper to the JacksonPlugin constructor if you are using Jackson with a custom object mapper.
`,content:`Fixture monkey supports Jackson with the Fixture Monkey Jackson plugin.
Supports the use of JacksonObjectArbitraryIntrospector as the default introspector to create objects using the Jackson object mapper. Supports Jackson Annotations such as, @JsonIgnore, @JsonProperty Dependencies # Gradle # testImplementation(&quot;com.navercorp.fixturemonkey:fixture-monkey-jackson:1.1.10&quot;) Maven # &lt;dependency&gt; &lt;groupId&gt;com.navercorp.fixturemonkey&lt;/groupId&gt; &lt;artifactId&gt;fixture-monkey-jackson&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; Plugin # Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .build(); val fixtureMonkey = FixtureMonkey.builder() .plugin(JacksonPlugin()) .build() Pass the object mapper to the JacksonPlugin constructor if you are using Jackson with a custom object mapper.
Java Kotlin ObjectMapper objectMapper = JsonMapper.builder() .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES) .build() FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin(objectMapper)) .build(); val objectMapper = JsonMapper.builder() .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES) .build() val fixtureMonkey = FixtureMonkey.builder() .plugin(JacksonPlugin(objectMapper)) .build() `}),e.add({id:36,href:"/v1-1-0/docs/plugins/jackson-plugin/jackson-object-arbitrary-introspector/",title:"JacksonObjectArbitraryIntrospector",description:`JacksonObjectArbitraryIntrospector # The JacksonObjectArbitraryIntrospector becomes the default introspector when the Jackson plugin is added. It puts the created properties of the given class into a map and deserializes them using Jackson&rsquo;s object mapper.
Example Java Class :
@Value public class Product { long id; String productName; long price; List&lt;String&gt; options; Instant createdAt; } Using JacksonObjectArbitraryIntrospector : Java Kotlin @Test void test() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .build(); Product product = fixtureMonkey.giveMeOne(Product.class); } testImplementation(&#34;com.navercorp.fixturemonkey:fixture-monkey-starter-kotlin:1.1.10&#34;) testImplementation(&#34;com.fasterxml.jackson.module:jackson-module-kotlin&#34;) @Test fun test() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .plugin(JacksonPlugin()) .build(); val product: Product = fixtureMonkey.giveMeOne() } `,content:`JacksonObjectArbitraryIntrospector # The JacksonObjectArbitraryIntrospector becomes the default introspector when the Jackson plugin is added. It puts the created properties of the given class into a map and deserializes them using Jackson&rsquo;s object mapper.
Example Java Class :
@Value public class Product { long id; String productName; long price; List&lt;String&gt; options; Instant createdAt; } Using JacksonObjectArbitraryIntrospector : Java Kotlin @Test void test() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .build(); Product product = fixtureMonkey.giveMeOne(Product.class); } testImplementation(&#34;com.navercorp.fixturemonkey:fixture-monkey-starter-kotlin:1.1.10&#34;) testImplementation(&#34;com.fasterxml.jackson.module:jackson-module-kotlin&#34;) @Test fun test() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .plugin(JacksonPlugin()) .build(); val product: Product = fixtureMonkey.giveMeOne() } 💡 To generate Kotlin classes with JacksonObjectArbitraryIntrospector, both Kotlin plugin and Jackson plugin need to be added. In addition, fasterxml jackson-module-kotlin should be added to the dependency for serialization/deserialization of Kotlin classes. It has the advantage of being a general purpose introspector because it relies on the widely used Jackson for object creation. If your production code has both Kotlin and Java classes, it is recommended to use JacksonObjectArbitraryIntrospector.
However, it does have the disadvantage of potentially not performing as efficiently as other introspectors, as deserialization with Jackson can be more time-consuming.
`}),e.add({id:37,href:"/v1-1-0/docs/plugins/jackson-plugin/jackson-annotations/",title:"Jackson Annotations",description:`With the Jackson plugin, some Jackson annotations are also supported.
@JsonProperty, @JsonIgnore # We can use the property name specified by @JsonProperty when using the String Expression to customize this property.
The property with @JsonIgnore will have a null value when Fixture Monkey generates the object.
The following example shows how @JsonProperty, @JsonIgnore works with Fixture Monkey.
Example Java Class :
@Value // lombok getter, setter public class Product { long id; @JsonProperty(&quot;name&quot;) String productName; long price; @JsonIgnore List&lt;String&gt; options; Instant createdAt; } Java Kotlin @Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .build(); // when Product actual = fixtureMonkey.giveMeBuilder(Product.class) .set(&#34;name&#34;, &#34;book&#34;) .sample(); // then then(actual.getProductName()).isEqualTo(&#34;book&#34;); // @JsonProperty then(actual.getOptions()).isNull(); // @JsonIgnore } @Test fun test() { // given val fixtureMonkey = FixtureMonkey.builder() .plugin(JacksonPlugin()) .build() // when val actual = fixtureMonkey.giveMeBuilder&lt;Product&gt;() .set(&#34;name&#34;, &#34;book&#34;) .sample() // then then(actual.productName).isEqualTo(&#34;book&#34;) // @JsonProperty then(actual.options).isNull() // @JsonIgnore } @JsonTypeInfo, @JsonSubTypes # Fixture Monkey also supports Jackson&rsquo;s polymorphic type handling annotations @JsonTypeInfo and @JsonSubTypes.
`,content:`With the Jackson plugin, some Jackson annotations are also supported.
@JsonProperty, @JsonIgnore # We can use the property name specified by @JsonProperty when using the String Expression to customize this property.
The property with @JsonIgnore will have a null value when Fixture Monkey generates the object.
The following example shows how @JsonProperty, @JsonIgnore works with Fixture Monkey.
Example Java Class :
@Value // lombok getter, setter public class Product { long id; @JsonProperty(&quot;name&quot;) String productName; long price; @JsonIgnore List&lt;String&gt; options; Instant createdAt; } Java Kotlin @Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .build(); // when Product actual = fixtureMonkey.giveMeBuilder(Product.class) .set(&#34;name&#34;, &#34;book&#34;) .sample(); // then then(actual.getProductName()).isEqualTo(&#34;book&#34;); // @JsonProperty then(actual.getOptions()).isNull(); // @JsonIgnore } @Test fun test() { // given val fixtureMonkey = FixtureMonkey.builder() .plugin(JacksonPlugin()) .build() // when val actual = fixtureMonkey.giveMeBuilder&lt;Product&gt;() .set(&#34;name&#34;, &#34;book&#34;) .sample() // then then(actual.productName).isEqualTo(&#34;book&#34;) // @JsonProperty then(actual.options).isNull() // @JsonIgnore } @JsonTypeInfo, @JsonSubTypes # Fixture Monkey also supports Jackson&rsquo;s polymorphic type handling annotations @JsonTypeInfo and @JsonSubTypes.
We can generate an inheritance-implementation relationship object with the help of FixtureMonkey.
`}),e.add({id:38,href:"/v1-1-0/docs/plugins/jakarta-validation-plugin/",title:"Jakarta Validation Plugin",description:"",content:""}),e.add({id:39,href:"/v1-1-0/docs/plugins/jakarta-validation-plugin/features/",title:"Features",description:`Fixture monkey supports generating valid data based on Jakarta Bean Validation 3.0 annotations with the Fixture Monkey Jakarta Validation Plugin.
💡 Javax Bean Validation is also supported with the Fixture Monkey Javax Validation Plugin Dependencies # Gradle # testImplementation(&quot;com.navercorp.fixturemonkey:fixture-monkey-jakarta-validation:1.1.10&quot;) Maven # &lt;dependency&gt; &lt;groupId&gt;com.navercorp.fixturemonkey&lt;/groupId&gt; &lt;artifactId&gt;fixture-monkey-jakarta-validation&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; The jakarta validation API and the Hibernate validator are already provided as part of the dependency.
Plugin # Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JakartaValidationPlugin()) .build(); val fixtureMonkey = FixtureMonkey.builder() .plugin(JakartaValidationPlugin()) .build() `,content:`Fixture monkey supports generating valid data based on Jakarta Bean Validation 3.0 annotations with the Fixture Monkey Jakarta Validation Plugin.
💡 Javax Bean Validation is also supported with the Fixture Monkey Javax Validation Plugin Dependencies # Gradle # testImplementation(&quot;com.navercorp.fixturemonkey:fixture-monkey-jakarta-validation:1.1.10&quot;) Maven # &lt;dependency&gt; &lt;groupId&gt;com.navercorp.fixturemonkey&lt;/groupId&gt; &lt;artifactId&gt;fixture-monkey-jakarta-validation&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; The jakarta validation API and the Hibernate validator are already provided as part of the dependency.
Plugin # Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JakartaValidationPlugin()) .build(); val fixtureMonkey = FixtureMonkey.builder() .plugin(JakartaValidationPlugin()) .build() `}),e.add({id:40,href:"/v1-1-0/docs/plugins/jakarta-validation-plugin/bean-validation/",title:"Bean Validation",description:`Generating valid data # Using the Jakarta Validation plugin, we can generate valid data based on Jakarta Bean validation annotations on properties.
For example, there can be a Product class annotated as follows:
@Value public class Product { @Min(1) long id; @NotBlank String productName; @Max(100000) long price; @Size(min = 3) List&lt;@NotBlank String&gt; options; @Past Instant createdAt; } An instance of the Product class that is compliant with the annotations can be created in the following manner:
`,content:`Generating valid data # Using the Jakarta Validation plugin, we can generate valid data based on Jakarta Bean validation annotations on properties.
For example, there can be a Product class annotated as follows:
@Value public class Product { @Min(1) long id; @NotBlank String productName; @Max(100000) long price; @Size(min = 3) List&lt;@NotBlank String&gt; options; @Past Instant createdAt; } An instance of the Product class that is compliant with the annotations can be created in the following manner:
@Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .plugin(new JakartaValidationPlugin()) .build(); // when Product actual = fixtureMonkey.giveMeOne(Product.class); // then then(actual).isNotNull(); then(actual.getId()).isGreaterThan(0); then(actual.getProductName()).isNotBlank(); then(actual.getPrice()).isLessThanOrEqualTo(100000); then(actual.getOptions().size()).isGreaterThanOrEqualTo(3); then(actual.getOptions()).allSatisfy(it -&gt; then(it).isNotEmpty()); then(actual.getCreatedAt()).isNotNull().isLessThanOrEqualTo(Instant.now()); } Supported Annotations # Every annotation from the jakarta.validation.constraints package is supported. Different types support different annotation constraints.
Numeric Type # Supported Types: BigDecimal, BigInteger, byte, double, float, int, long, short
@Digits (fraction is currently not supported) @Max @Min @Negative @NegativeOrZero @DecimalMax @DecimalMin @Positive @PositiveOrZero Boolean Type # @AssertFalse @AssertTrue String Type # @Null @NotNull @NotBlank @NotEmpty @Size @Digits @Pattern @Email Time Type # Supported Types: Calendar, Date, Instant, LocalDate, LocalDateTime, LocalTime, ZonedDateTime, Year, YearMonth, MonthDay, OffsetDateTime, OffsetTime
@Past @PastOrPresent @Future @FutureOrPresent Container Type # @Size @NotEmpty `}),e.add({id:41,href:"/v1-1-0/docs/intellij-plugin/",title:"Intellij Plugin",description:"",content:""}),e.add({id:42,href:"/v1-1-0/docs/plugins/kotest-plugin/",title:"Kotest Plugin",description:"",content:""}),e.add({id:43,href:"/v1-1-0/docs/plugins/kotest-plugin/features/",title:"Features",description:`The Kotest plugin provided by Fixture Monkey allows you to enhance your testing experience within the Kotest framework.
Replaces the default generator for generating random values for primitive types from Jqwik to Kotest&rsquo;s property generator (Arb). Use of bean validation annotations also works. Support for Kotest&rsquo;s property-based testing functions, including forAll and checkAll. 💡 Adding the Kotest Plugin doesn't mean you have to use Kotest as your testing framework. You can still use Junit. Dependencies # fixture-monkey-kotlin # Gradle # testImplementation(&quot;com.navercorp.fixturemonkey:fixture-monkey-kotest:1.1.10&quot;) Maven # &lt;dependency&gt; &lt;groupId&gt;com.navercorp.fixturemonkey&lt;/groupId&gt; &lt;artifactId&gt;fixture-monkey-kotest&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; Plugin # val fixtureMonkey = FixtureMonkey.builder() .plugin(KotestPlugin()) .plugin(KotlinPlugin()) .build() `,content:`The Kotest plugin provided by Fixture Monkey allows you to enhance your testing experience within the Kotest framework.
Replaces the default generator for generating random values for primitive types from Jqwik to Kotest&rsquo;s property generator (Arb). Use of bean validation annotations also works. Support for Kotest&rsquo;s property-based testing functions, including forAll and checkAll. 💡 Adding the Kotest Plugin doesn't mean you have to use Kotest as your testing framework. You can still use Junit. Dependencies # fixture-monkey-kotlin # Gradle # testImplementation(&quot;com.navercorp.fixturemonkey:fixture-monkey-kotest:1.1.10&quot;) Maven # &lt;dependency&gt; &lt;groupId&gt;com.navercorp.fixturemonkey&lt;/groupId&gt; &lt;artifactId&gt;fixture-monkey-kotest&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; Plugin # val fixtureMonkey = FixtureMonkey.builder() .plugin(KotestPlugin()) .plugin(KotlinPlugin()) .build() `}),e.add({id:44,href:"/v1-1-0/docs/intellij-plugin/fixture-monkey-helper/",title:"Fixture Monkey Helper",description:`Fixture Monkey Helper is an IntelliJ plugin that helps to use Fixture Monkey on the IntelliJ IDE.
It provides some features that make using String Expressions and Kotlin DSL Expressions easier, and also add some IntelliJ inspections to detect and fix abnormal code.
🚨 This plugin currently operates only within Java source code and Kotlin test code. Plans for expansion are in progress. Features # Fixture Monkey Expression support
`,content:`Fixture Monkey Helper is an IntelliJ plugin that helps to use Fixture Monkey on the IntelliJ IDE.
It provides some features that make using String Expressions and Kotlin DSL Expressions easier, and also add some IntelliJ inspections to detect and fix abnormal code.
🚨 This plugin currently operates only within Java source code and Kotlin test code. Plans for expansion are in progress. Features # Fixture Monkey Expression support
Seamless Conversion: Transform string expressions into the Kotlin DSL provided by Fixture Monkey for ArbitraryBuilder. Expression Validation: Ensure the accuracy of your string expressions before execution. Intuitive Auto-Completion: Speed up your coding with smart suggestions as you type. Easy Navigation: Jump directly to field references within your codebase. FixtureMonkey Kotlin DSL Enhancements
Bidirectional Transformation: Switch between Kotlin DSL and Fixture Monkey string expressions effortlessly. Support for on-the-fly bidirectional Transformation (Beta) Code Folding: Simplify your view by collapsing DSL expressions into a single line. Lambda Expression Generator: Craft fixture specifications with ease using generated lambda expressions. Lambda to DSL Conversion: Convert complex lambda expressions into readable and maintainable Fixture Monkey Kotlin DSL. Inspection
Change type information passed as method arguments in Fixture Monkey factory methods to generic type arguments Change generic type arguments to variable types in Fixture Monkey factory methods when possible Fixture Monkey Property Overview Tool Window (Alpha)
This tool window allows you to view all properties registered with ArbitraryBuilder at a glance, presented in a tree format. `}),e.add({id:45,href:"/v1-1-0/docs/plugins/kotest-plugin/property-based-testing/",title:"Kotest Property Based Testing",description:`Fixture Monkey&rsquo;s Kotest plugin introduces two primary features that enhance property-based testing within the Kotest framework: forAll and checkAll.
The KotestPlugin and KotlinPlugin should be added to enable this feature.
val fixtureMonkey: FixtureMonkey = FixtureMonkey.builder() .plugin(KotestPlugin()) .plugin(KotlinPlugin()) .build() ForAll # Kotest provides a forAll function that accepts an n-arity function (a, ..., n) -&gt; Boolean to test a property. The test passes if, for all input values, the function returns true.
`,content:`Fixture Monkey&rsquo;s Kotest plugin introduces two primary features that enhance property-based testing within the Kotest framework: forAll and checkAll.
The KotestPlugin and KotlinPlugin should be added to enable this feature.
val fixtureMonkey: FixtureMonkey = FixtureMonkey.builder() .plugin(KotestPlugin()) .plugin(KotlinPlugin()) .build() ForAll # Kotest provides a forAll function that accepts an n-arity function (a, ..., n) -&gt; Boolean to test a property. The test passes if, for all input values, the function returns true.
This function accepts type parameters for the argument types, which Kotest uses to locate a generator that provides random values of a suitable type.
class PropertyExample: StringSpec({ &quot;String size&quot; { forAll&lt;String, String&gt; { a, b -&gt; (a + b).length == a.length + b.length } } }) For cases when a custom generator is needed, it&rsquo;s possible to specify generators (called Arb in Kotest). However, only generators of limited types are provided with kotest, and it is hard to customize.
Fixture Monkey offers a way to generate Arb for custom types using the giveMeArb() function. You can further customize the generator using Fixture Monkey&rsquo;s customization APIs.
Here&rsquo;s an example of performing property-based testing with forAll using Fixture Monkey:
class KotestInKotestTest : StringSpec({ &quot;forAll&quot; { forAll(fixtureMonkey.giveMeArb&lt;StringObject&gt; { it.set(&quot;value&quot;, &quot;test&quot;) }) { a -&gt; a.value == &quot;test&quot; } } }) { data class StringObject(val value: String) } CheckAll # Fixture Monkey also provides the extension function checkAll similar to Kotest&rsquo;s checkAll.
Primitive Type Input # With checkAll, you can test assertions against primitive data types, as shown in the example below:
class Test : StringSpec({ &quot;checkAll&quot; { SUT.checkAll { string: String, int: Int -&gt; string shouldNotBeSameInstanceAs int string shouldBe string } } }) Custom Type Input # Fixture Monkey&rsquo;s checkAll extension function goes beyond primitive types. You can also use custom types as input data, generated with Fixture Monkey.
class Test : StringSpec({ &quot;checkAllObject&quot; { SUT.checkAll { stringObject: StringObject -&gt; stringObject.value shouldNotBe null } } }) { data class StringObject(val value: String) } ArbitraryBuilder Input # Additionally, you can work with ArbitraryBuilder instances and further customize them to execute assertions.
class Test : StringSpec({ &quot;checkAllArbitraryBuilder&quot; { SUT.checkAll { string: ArbitraryBuilder&lt;List&lt;String&gt;&gt; -&gt; string .size(&quot;$&quot;, 3) .sample() shouldHaveSize 3 } } }) { data class StringObject(val value: String) } `}),e.add({id:46,href:"/v1-1-0/docs/cheat-sheet/",title:"Cheat sheet",description:"",content:""}),e.add({id:47,href:"/v1-1-0/docs/cheat-sheet/faq/",title:"FAQ",description:`How can I limit the range of characters for my generated Strings? # Related - How can I constrain the range of my generated Instant values?
Normally, if you want to add constraints to your fixture, you can do so using the Fixture Customization APIs provided with the ArbitraryBuilder. However, in cases where you want each generated primitive type to adhere to specific constraints, you can use the javaTypeArbitaryGenerator and javaTimeTypeArbitraryGenerator options.
`,content:`How can I limit the range of characters for my generated Strings? # Related - How can I constrain the range of my generated Instant values?
Normally, if you want to add constraints to your fixture, you can do so using the Fixture Customization APIs provided with the ArbitraryBuilder. However, in cases where you want each generated primitive type to adhere to specific constraints, you can use the javaTypeArbitaryGenerator and javaTimeTypeArbitraryGenerator options.
The javaTypeArbitaryGenerator option allows you to customize the default values for primitive types such as Strings or Integers. For time types, such as Instant, you can use the javaTimeTypeArbitraryGenerator option.
This option is particularly useful if you want the generated strings to fall within a certain range of characters, or if you want your time types to be generated at predefined intervals.
How can I exclude certain values from being generated? # You can easily specify a value using set(), but there may be cases where you want to EXCLUDE certain values.
For instance, you might have an Enum-typed field in your class, and you don&rsquo;t want it to have certain values. In these situations, you can use set() as shown below.
Java Kotlin Product product = sut.giveMeBuilder(Product.class) .set(&#34;productType&#34;, ArbitraryUtils.toCombinableArbitrary(Arbitraries.of(ProductType)).filter(it -&gt; it != CLOTHING &amp;&amp; it != ELECTRONICS))) .sample(); val product = sut.giveMeBuilder&lt;Product&gt;() .setExpGetter(Product::getProductType, ArbitraryUtils.toCombinableArbitrary(Arbitraries.of(ProductType::class.java)).filter { it != ProductType.CLOTHING &amp;&amp; it != ProductType.ELECTRONICS }) .sample() Or you can use setPostCondition() which works like a filter.
Java Kotlin Product product = sut.giveMeBuilder(Product.class) .setPostCondition(&#34;productType&#34;, ProductType.class, it -&gt; it != CLOTHING || it != ELECTRONICS) .sample(); val product = sut.giveMeBuilder&lt;Product&gt;() .setPostConditionExpGetter(Product::getProductType, ProductType::class.java) { it != ProductType.CLOTHING || it != ProductType.ELECTRONICS } .sample() Please note that using setPostCondition() can incur higher costs for narrow conditions because it filters after the Product instance has been created. In such cases, it&rsquo;s recommended to use set() instead.
One of my fields depends on the value of another field. How can I customize my fixture? # The thenApply() method comes in handy when you need to customize a field that relies on another field. For more information, check the thenApply() section
Throws an exception when generating a certain type # Use PriorityConstructorArbitraryIntrospector first. Apply as shown below.
FixtureMonkey.builder() .pushExactTypeArbitraryIntrospector(ProblematicType.class, PriorityConstructorArbitraryIntrospector.INSTANCE) .build(); If it does not work, please try to make your own ArbitraryIntrospector or create an issue on github and ask for help.
`}),e.add({id:48,href:"/v1-1-0/docs/migration-guide/",title:"Migration guide",description:"",content:""}),e.add({id:49,href:"/v1-1-0/docs/",title:"Docs",description:"",content:""}),search.addEventListener("input",t,!0);function t(){const s=4,o=300;var n=this.value,i=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of i.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[c,r]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href="/fixture-monkey"+c,n.appendChild(e);const i=document.createElement("span");i.textContent=r.title,i.classList.add("suggestion__title"),e.appendChild(i);const a=document.createElement("span");if(a.textContent=r.description.substring(0,o),a.classList.add("suggestion__description"),e.appendChild(a),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Generating Objects on</title><link>https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/</link><description>Recent content in Generating Objects on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/index.xml" rel="self" type="application/rss+xml"/><item><title>FixtureMonkey</title><link>https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/fixture-monkey/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/fixture-monkey/</guid><description>To generate test fixtures, the first step is to create a FixtureMonkey instance, which facilitates the creation of test fixtures.
You can use the create() method to generate a FixtureMonkey instance with default options. For Kotlin environments, add the Kotlin plugin.
Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.create(); val fixtureMonkey = FixtureMonkey .plugin(KotlinPlugin()) .build() If you want to add some options for creating or customizing the test fixtures, you can add them using the FixtureMonkey builder.</description></item><item><title>Generating Complex Types</title><link>https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/generating-complex-types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/generating-complex-types/</guid><description>Fixture Monkey is capable of generating complex objects that are difficult to create as test fixtures.
This page contains examples of the various types of objects that can be generated.
Java # Generic Objects # @Value public static class GenericObject&amp;lt;T&amp;gt; { T foo; } @Value public static class GenericArrayObject&amp;lt;T&amp;gt; { GenericObject&amp;lt;T&amp;gt;[] foo; } @Value public static class TwoGenericObject&amp;lt;T, U&amp;gt; { T foo; U bar; } @Value public static class ThreeGenericObject&amp;lt;T, U, V&amp;gt; { T foo; U bar; V baz; } Generic Interfaces # public interface GenericInterface&amp;lt;T&amp;gt; { } @Value public static class GenericInterfaceImpl&amp;lt;T&amp;gt; implements GenericInterface&amp;lt;T&amp;gt; { T foo; } public interface TwoGenericInterface&amp;lt;T, U&amp;gt; { } @Value public static class TwoGenericImpl&amp;lt;T, U&amp;gt; implements TwoGenericInterface&amp;lt;T, U&amp;gt; { T foo; U bar; } SelfReference # @Value public class SelfReference { String foo; SelfReference bar; } @Value public class SelfReferenceList { String foo; List&amp;lt;SelfReferenceList&amp;gt; bar; } Interface # public interface Interface { String foo(); Integer bar(); } public interface InheritedInterface extends Interface { String foo(); } public interface InheritedInterfaceWithSameNameMethod extends Interface { String foo(); } public interface ContainerInterface { List&amp;lt;String&amp;gt; baz(); Map&amp;lt;String, Integer&amp;gt; qux(); } public interface InheritedTwoInterface extends Interface, ContainerInterface { } Kotlin # Generic Objects # class Generic&amp;lt;T&amp;gt;(val foo: T) class GenericImpl(val foo: Generic&amp;lt;String&amp;gt;) SelfReference # class SelfReference(val foo: String, val bar: SelfReference?</description></item><item><title>Instantiate Methods</title><link>https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/instantiate-methods/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/instantiate-methods/</guid><description>For each test, you may want to use a different way of creating objects. For example, even within the same class, one test may require initialization using the constructor, while another test may require initialization using its factory method.
Fixture Monkey allows you to choose the preferred method of creating your object through the instantiate() method. ðŸ’¡ If the Kotlin Plugin is added, you can use the instantiateBy() method with a custom DSL.</description></item><item><title>Introspector</title><link>https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/introspector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/introspector/</guid><description>While you can change the way an object is created in the ArbitraryBuilder with instantiate, there may be cases where you want to change the way objects are created globally. Fixture Monkey lets you choose the way you want to create your object by providing different Introspectors.
An Introspector defines the default way of how Fixture Monkey creates objects. Each introspector has some kind of restrictions that the class must have in order for the introspector to generate instances of that class.</description></item><item><title>Generating Interface Type</title><link>https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/generating-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/generating-interface/</guid><description>Fixture Monkey is able to generate complex interface objects consisting of interface, generic interface, sealed interface.
Fixture Monkey provides the default implementations of certain interfaces. For example, ArrayList is for the List interface, HashSet is for the Set interface.
Except in those cases, you should specify the implementations of the interface. If you do not, Fixture Monkey will generate an anonymous object for you. You do not need to specify the implementations in the case of sealed interface.</description></item></channel></rss>
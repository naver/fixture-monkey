<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Generating Objects on</title><link>https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/</link><description>Recent content in Generating Objects on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/index.xml" rel="self" type="application/rss+xml"/><item><title>FixtureMonkey</title><link>https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/fixture-monkey/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/fixture-monkey/</guid><description>What is FixtureMonkey? # FixtureMonkey is the main entry point for creating test fixtures in the Fixture Monkey library. Think of it as a factory that knows how to create instances of any class with random but valid values. This makes it perfect for generating test data without writing verbose setup code.
How it works - A quick overview # The typical workflow with Fixture Monkey looks like this:
Create a FixtureMonkey instance Use one of its generation methods to create test objects Optionally customize the objects to match specific test requirements For example, here&amp;rsquo;s a complete test using Fixture Monkey:</description></item><item><title>Generating Complex Types</title><link>https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/generating-complex-types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/generating-complex-types/</guid><description>Why Complex Types Matter in Testing # When writing real-world tests, you&amp;rsquo;ll often need to work with complex objects that include:
Generic types with multiple type parameters Self-referencing structures (like trees or graphs) Complex interface hierarchies Sealed or abstract classes Manually creating instances of these types for testing can be extremely tedious and error-prone. This is where Fixture Monkey shines - it can automatically generate valid instances of even the most complex types with minimal code.</description></item><item><title>Instantiate Methods</title><link>https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/instantiate-methods/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/instantiate-methods/</guid><description>Overview: Why Specify Object Creation Methods # By default, Fixture Monkey automatically determines how to create objects through Introspectors. However, sometimes you may need to specify a particular creation method for reasons such as:
Specific constructor usage: When a class has multiple constructors and you want to choose a specific one Factory method utilization: When you want to create objects using factory methods instead of constructors Different initialization per test: When you need different initialization methods for the same class in different tests Special initialization logic: When you need special initialization that can&amp;rsquo;t be handled automatically by introspectors In these situations, the instantiate() method allows you to precisely control how objects are created.</description></item><item><title>Generating Interface Types</title><link>https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/generating-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/generating-interface/</guid><description>Why Generate Interface Types? # When writing tests, you often need to work with interfaces rather than concrete implementations:
You may be testing code that accepts interfaces as parameters Your system under test may return interface types You want to test behavior without coupling to specific implementations Fixture Monkey makes it easy to generate test objects for interfaces - whether they&amp;rsquo;re simple interfaces, generic interfaces, or sealed interfaces.
Quick Start Example # Here&amp;rsquo;s a simple example to get started with interface generation:</description></item><item><title>Introspector</title><link>https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/introspector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/introspector/</guid><description>What is an Introspector? # An Introspector in Fixture Monkey is simply a tool that determines how test objects are created. Think of it as a &amp;ldquo;factory&amp;rdquo; that figures out the best way to create objects for your tests.
For example, it decides:
Whether to use a constructor or a builder to create objects How to set values for fields How to handle different types of classes in your codebase Quick Start: Recommended Setup for Most Projects # If you&amp;rsquo;re new to Fixture Monkey and want to get started quickly, here&amp;rsquo;s the setup that works for most projects:</description></item><item><title>Creating Custom Introspector</title><link>https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/custom-introspector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0/docs/generating-objects/custom-introspector/</guid><description>Note: This guide is for advanced users who already understand Fixture Monkey basics. Most users won&amp;rsquo;t need to create custom introspectors as the built-in ones handle common scenarios. If you&amp;rsquo;re just getting started, check the Introspector guide first.
When Would You Need a Custom Introspector? # You might need to create a custom introspector in these specific situations:
Your classes have unique creation requirements that built-in introspectors can&amp;rsquo;t handle You&amp;rsquo;re working with third-party libraries that follow unconventional patterns Your objects need special initialization logic that can&amp;rsquo;t be addressed with the instantiate method If none of these apply to you, the built-in introspectors will likely be sufficient.</description></item></channel></rss>
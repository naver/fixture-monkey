var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",resolution:9,minlength:3,optimize:!0,fastupdate:!0,cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/v1-1-0/docs/introduction/",title:"Introduction",description:"",content:""}),e.add({id:1,href:"/v1-1-0/docs/migration-guide/migration-guide/",title:"From 1.0.x",description:`Migrating from 1.0.x to 1.1.x # This guide helps you update your code from Fixture Monkey 1.0.x to 1.1.x. We\u0026rsquo;ve made several improvements to make the library easier to use while maintaining backward compatibility where possible.
Major Changes at a Glance # Better handling of Kotlin types Separate APIs for Java and Kotlin Simpler way to handle abstract types and interfaces Kotlin Type Handling Improvements # What Changed # Before (1.`,content:`Migrating from 1.0.x to 1.1.x # This guide helps you update your code from Fixture Monkey 1.0.x to 1.1.x. We\u0026rsquo;ve made several improvements to make the library easier to use while maintaining backward compatibility where possible.
Major Changes at a Glance # Better handling of Kotlin types Separate APIs for Java and Kotlin Simpler way to handle abstract types and interfaces Kotlin Type Handling Improvements # What Changed # Before (1.0.x): When using KotlinPlugin, both Java and Kotlin types were created using Kotlin\u0026rsquo;s primary constructor approach. This caused errors when creating Java types. Now (1.1.x): Each language uses its appropriate object creation strategy: Java types â†’ Created using bean properties (getters/setters) Kotlin types â†’ Created using Kotlin primary constructors What You Need to Do # No changes needed. Your Java types will now work correctly with the KotlinPlugin.
Java and Kotlin Now Have Separate APIs # What Changed # Before (1.0.x): Same ArbitraryBuilder API for both Java and Kotlin Now (1.1.x): Specialized APIs for each language to provide a more natural experience Java API # Use one of these methods to get a Java-optimized builder:
// Java style API ArbitraryBuilder\u0026lt;User\u0026gt; userBuilder = fixtureMonkey.giveMeBuilder(User.class); // or explicitly request Java builder ArbitraryBuilder\u0026lt;User\u0026gt; userBuilder = fixtureMonkey.giveMeJavaBuilder(User.class); Kotlin API # Use Kotlin extension functions for a more idiomatic Kotlin experience:
// Kotlin style API with extension function val userBuilder = fixtureMonkey.giveMeKotlinBuilder\u0026lt;User\u0026gt;() Note: You can still use Java APIs with Kotlin types and vice versa if needed.
Simpler Way to Handle Abstract Types # What Changed # Before (1.0.x): Required complex ObjectPropertyGenerator configuration to implement abstract types or interfaces Now (1.1.x): Simpler CandidateConcretePropertyResolver lets you focus only on which implementations to use Example: Handling Sealed Classes # Before (1.0.x) - Complex Configuration # You needed to understand many details about ObjectProperty:
public final class SealedTypeObjectPropertyGenerator implements ObjectPropertyGenerator { @Override public ObjectProperty generate(ObjectPropertyGeneratorContext context) { Property sealedTypeProperty = context.getProperty(); double nullInject = context.getNullInjectGenerator().generate(context); Class\u0026lt;?\u0026gt; actualType = Types.getActualType(sealedTypeProperty.getType()); Set\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; permittedSubclasses = collectPermittedSubclasses(actualType); Map\u0026lt;Property, List\u0026lt;Property\u0026gt;\u0026gt; childPropertiesByProperty = permittedSubclasses.stream() .collect( toUnmodifiableMap( Function.identity(), it -\u0026gt; context.getPropertyGenerator().generateChildProperties(it) ) ); return new ObjectProperty( sealedTypeProperty, context.getPropertyNameResolver(), nullInject, context.getElementIndex(), childPropertiesByProperty ); } private static Set\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; collectPermittedSubclasses(Class\u0026lt;?\u0026gt; type) { Set\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; subclasses = new HashSet\u0026lt;\u0026gt;(); doCollectPermittedSubclasses(type, subclasses); return subclasses; } private static void doCollectPermittedSubclasses(Class\u0026lt;?\u0026gt; type, Set\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; subclasses) { if (type.isSealed()) { for (Class\u0026lt;?\u0026gt; subclass : type.getPermittedSubclasses()) { doCollectPermittedSubclasses(subclass, subclasses); } } else { subclasses.add(type); } } } Now (1.1.x) - Simpler Approach # Just focus on which implementation classes to use:
public final class SealedTypeCandidateConcretePropertyResolver implements CandidateConcretePropertyResolver { @Override public List\u0026lt;Property\u0026gt; resolve(Property property) { Class\u0026lt;?\u0026gt; actualType = Types.getActualType(property.getType()); Set\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; permittedSubclasses = collectPermittedSubclasses(actualType); return permittedSubclasses.stream() .map(PropertyUtils::toProperty) .toList(); } private static Set\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; collectPermittedSubclasses(Class\u0026lt;?\u0026gt; type) { Set\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; subclasses = new HashSet\u0026lt;\u0026gt;(); doCollectPermittedSubclasses(type, subclasses); return subclasses; } private static void doCollectPermittedSubclasses(Class\u0026lt;?\u0026gt; type, Set\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; subclasses) { if (type.isSealed()) { for (Class\u0026lt;?\u0026gt; subclass : type.getPermittedSubclasses()) { doCollectPermittedSubclasses(subclass, subclasses); } } else { subclasses.add(type); } } } Summary of Benefits # Better Language Support: Each language (Java/Kotlin) now uses its natural creation approach More Intuitive APIs: Language-specific APIs that feel more natural to use Simpler Complex Type Handling: Less boilerplate code when working with interfaces, abstract classes, and sealed types These changes make Fixture Monkey 1.1.x easier to use while maintaining compatibility with most of your existing code.
`}),e.add({id:2,href:"/v1-1-0/docs/introduction/overview/",title:"Overview",description:`Fixture Monkey # Fixture Monkey is a Java \u0026amp; Kotlin library designed to generate controllable arbitrary test objects. Its most distinctive feature is the ability to freely access and configure any nested fields through path-based expressions.
It focuses on simplifying test writing, by facilitating the generation of necessary test fixtures. Whether you\u0026rsquo;re dealing with basic or complex test fixtures, Fixture Monkey helps you to effortlessly create the test objects you need and easily customize them to match your desired configurations.`,content:`Fixture Monkey # Fixture Monkey is a Java \u0026amp; Kotlin library designed to generate controllable arbitrary test objects. Its most distinctive feature is the ability to freely access and configure any nested fields through path-based expressions.
It focuses on simplifying test writing, by facilitating the generation of necessary test fixtures. Whether you\u0026rsquo;re dealing with basic or complex test fixtures, Fixture Monkey helps you to effortlessly create the test objects you need and easily customize them to match your desired configurations.
Make your JVM tests more concise and safe with Fixture Monkey.
Quick Start # Add Fixture Monkey to your project:
Java Kotlin dependencies { testImplementation \u0026#39;com.navercorp.fixturemonkey:fixture-monkey-starter:1.1.15\u0026#39; } dependencies { testImplementation(\u0026#34;com.navercorp.fixturemonkey:fixture-monkey-starter-kotlin:1.1.15\u0026#34;) } Create your first test object:
FixtureMonkey fixtureMonkey = FixtureMonkey.create(); // Basic type generation String randomString = fixtureMonkey.giveMeOne(String.class); Integer randomNumber = fixtureMonkey.giveMeOne(Integer.class); // Collection generation List\u0026lt;String\u0026gt; randomStrings = fixtureMonkey.giveMe(String.class, 3); Set\u0026lt;Integer\u0026gt; randomNumbers = fixtureMonkey.giveMe(Set.class, Integer.class, 5); // Complex object generation class User { String name; int age; List\u0026lt;Address\u0026gt; addresses; } class Address { String city; String street; } // Single object generation User user = fixtureMonkey.giveMeOne(User.class); // Multiple objects generation List\u0026lt;User\u0026gt; users = fixtureMonkey.giveMe(User.class, 3); // Nested object generation User userWithAddresses = fixtureMonkey.giveMeBuilder(User.class) .size(\u0026quot;addresses\u0026quot;, 2) .sample(); Why use Fixture Monkey? # 1. One-Line Test Object Generation # // Before: Manual object creation Product product = new Product(); product.setId(1L); product.setName(\u0026quot;Test Product\u0026quot;); product.setPrice(1000); product.setCreatedAt(LocalDateTime.now()); // After: With Fixture Monkey Product product = fixtureMonkey.giveMeOne(Product.class); Stop writing boilerplate code for test object creation. Fixture Monkey generates any test object with a single line of code. Transform your test preparation from a tedious chore into a simple, elegant solution. No changes to production code or test environment required.
2. Intuitive Path-Based Configuration # class Order { List\u0026lt;OrderItem\u0026gt; items; Customer customer; Address shippingAddress; } class OrderItem { Product product; int quantity; } class Product { String name; List\u0026lt;Review\u0026gt; reviews; } // Set all product names to \u0026quot;Special Product\u0026quot; ArbitraryBuilder\u0026lt;Order\u0026gt; orderBuilder = fixtureMonkey.giveMeBuilder(Order.class) .set(\u0026quot;items[*].product.name\u0026quot;, \u0026quot;Special Product\u0026quot;); // Set all review ratings to 5 stars ArbitraryBuilder\u0026lt;Order\u0026gt; orderWithGoodReviews = fixtureMonkey.giveMeBuilder(Order.class) .set(\u0026quot;items[*].product.reviews[*].rating\u0026quot;, 5); // Set all quantities to 2 ArbitraryBuilder\u0026lt;Order\u0026gt; orderWithFixedQuantity = fixtureMonkey.giveMeBuilder(Order.class) .set(\u0026quot;items[*].quantity\u0026quot;, 2); Bid farewell to endless getter/setter chains. Fixture Monkey\u0026rsquo;s path expressions let you configure any nested field with a single line. The [*] wildcard operator empowers you to manipulate entire collections effortlessly, dramatically reducing boilerplate code and enhancing test maintainability.
3. Reusable Test Specifications # // Define a reusable builder ArbitraryBuilder\u0026lt;Product\u0026gt; productBuilder = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026quot;category\u0026quot;, \u0026quot;Book\u0026quot;) .set(\u0026quot;price\u0026quot;, 1000); // Reuse in different tests @Test void testProductCreation() { Product product = productBuilder.sample(); assertThat(product.getCategory()).isEqualTo(\u0026quot;Book\u0026quot;); assertThat(product.getPrice()).isEqualTo(1000); } @Test void testProductWithReviews() { Product product = productBuilder .size(\u0026quot;reviews\u0026quot;, 3) .sample(); assertThat(product.getReviews()).hasSize(3); } @Test void testProductWithSpecificReview() { Product product = productBuilder .set(\u0026quot;reviews[0].rating\u0026quot;, 5) .set(\u0026quot;reviews[0].comment\u0026quot;, \u0026quot;Excellent!\u0026quot;) .sample(); assertThat(product.getReviews().get(0).getRating()).isEqualTo(5); assertThat(product.getReviews().get(0).getComment()).isEqualTo(\u0026quot;Excellent!\u0026quot;); } Eliminate test code duplication. Define complex object specifications once and reuse them across your test suite. ArbitraryBuilder\u0026rsquo;s lazy evaluation ensures objects are only created when needed, optimizing your test performance.
4. Universal Object Generation # // inheritance class Foo { String foo; } class Bar extends Foo { String bar; } Foo foo = FixtureMonkey.create().giveMeOne(Foo.class); Bar bar = FixtureMonkey.create().giveMeOne(Bar.class); // circular-reference class Foo { String value; Foo foo; } Foo foo = FixtureMonkey.create().giveMeOne(Foo.class); // anonymous objects interface Foo { Bar getBar(); } class Bar { String value; } Foo foo = FixtureMonkey.create().giveMeOne(Foo.class); From simple POJOs to complex object graphs, Fixture Monkey handles it all. Generate lists, nested collections, enums, generic types, and even objects with inheritance relationships or circular references. No object structure is too complex for Fixture Monkey.
5. Dynamic Test Data # ArbitraryBuilder\u0026lt;Product\u0026gt; actual = fixtureMonkey.giveMeBuilder(Product.class); then(actual.sample()).isNotEqualTo(actual.sample()); Move beyond static test data. Fixture Monkey\u0026rsquo;s random value generation helps you discover edge cases that static data might miss. Make your tests more robust by testing with varied data in every run.
Real Test Example # @Test void testOrderProcessing() { // Given Order order = fixtureMonkey.giveMeBuilder(Order.class) .set(\u0026quot;items[*].quantity\u0026quot;, 2) .set(\u0026quot;items[*].product.price\u0026quot;, 1000) .sample(); OrderProcessor processor = new OrderProcessor(); // When OrderResult result = processor.process(order); // Then assertThat(result.getTotalAmount()).isEqualTo(4000); // 2 items * 2 quantity * 1000 price assertThat(result.getStatus()).isEqualTo(OrderStatus.COMPLETED); } Battle-Tested in Production # Originally developed at Naver, Fixture Monkey played a pivotal role in the Plasma project, revolutionizing Naver Pay\u0026rsquo;s architecture. Supporting over 10,000 tests for South Korea\u0026rsquo;s leading mobile payment service, Fixture Monkey has proven its reliability in handling complex business requirements at scale. Now available as open-source, bring this battle-tested solution to your projects and write more reliable tests with confidence.
`}),e.add({id:3,href:"/v1-1-0/docs/get-started/",title:"Getting Started",description:"",content:""}),e.add({id:4,href:"/v1-1-0/docs/get-started/requirements/",title:"Requirements",description:"ðŸ’¡ Fixture Monkey is designed for test environments. It is not recommended for production use. Prerequisites # JDK 1.8 or higher (Or Kotlin 1.8 or higher) JUnit 5 platform jqwik 1.7.3 Dependencies # Dependency Description fixture-monkey Core library fixture-monkey-starter Starter dependency for fixture monkey fixture-monkey-kotlin Kotlin support fixture-monkey-starter-kotlin Starter dependency for fixture monkey kotlin fixture-monkey-starter is a starter dependency that comes with pre-configured dependencies such as fixture-monkey-jakarta-validation to help you get started using Fixture Monkey.",content:` ðŸ’¡ Fixture Monkey is designed for test environments. It is not recommended for production use. Prerequisites # JDK 1.8 or higher (Or Kotlin 1.8 or higher) JUnit 5 platform jqwik 1.7.3 Dependencies # Dependency Description fixture-monkey Core library fixture-monkey-starter Starter dependency for fixture monkey fixture-monkey-kotlin Kotlin support fixture-monkey-starter-kotlin Starter dependency for fixture monkey kotlin fixture-monkey-starter is a starter dependency that comes with pre-configured dependencies such as fixture-monkey-jakarta-validation to help you get started using Fixture Monkey.
For Kotlin environments, you can use fixture-monkey-starter-kotlin
Gradle # Add junit-platform-launcher as a runtime dependency. The dependency is optional below Gradle 9, but it will be mandatory from Gradle 9 onwards.
ðŸ“” Gradle Offical Documentation âš ï¸ Issue
testRuntimeOnly(\u0026quot;org.junit.platform:junit-platform-launcher:{version}\u0026quot;) testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-starter:1.1.15\u0026quot;) Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.15\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; Third party library support # Dependency Description fixture-monkey-jackson Jackson support for serialization and deserialization of objects fixture-monkey-jakarta-validation Support for Jakarta Bean Validation (JSR 380) annotations fixture-monkey-javax-validation Support for Javax Bean Validation (JSR 303/349) annotations fixture-monkey-mockito Support for Mockito mocking framework fixture-monkey-autoparams Support for AutoParams test data generation fixture-monkey-junit-jupiter Support for JUnit Jupiter test framework fixture-monkey-kotest Support for Kotest test framework `}),e.add({id:5,href:"/v1-1-0/docs/get-started/creating-objects/",title:"Creating objects",description:`Fixture Monkey works in both Java and Kotlin. We have a separate \u0026lsquo;Getting Started\u0026rsquo; page for each environment you can use: Java, Java without Lombok, and Kotlin.
This page explains the Java environment. Please refer to the appropriate page for your environment.
Creating test objects with Fixture Monkey is remarkably simple. Here\u0026rsquo;s how you can use it:
@Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build(); // when Product actual = fixtureMonkey.`,content:` Fixture Monkey works in both Java and Kotlin. We have a separate \u0026lsquo;Getting Started\u0026rsquo; page for each environment you can use: Java, Java without Lombok, and Kotlin.
This page explains the Java environment. Please refer to the appropriate page for your environment.
Creating test objects with Fixture Monkey is remarkably simple. Here\u0026rsquo;s how you can use it:
@Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build(); // when Product actual = fixtureMonkey.giveMeOne(Product.class); // then then(actual).isNotNull(); } When you run this code, Fixture Monkey will generate a Product instance with random values. Below is just an example, and the actual values will be different each time:
Product( id=42, productName=\u0026quot;product-value-1\u0026quot;, price=1000, options=[\u0026quot;option1\u0026quot;, \u0026quot;option2\u0026quot;], createdAt=2024-03-21T10:15:30Z, productType=ELECTRONICS, merchantInfo={1=\u0026quot;merchant1\u0026quot;, 2=\u0026quot;merchant2\u0026quot;} ) First, create a FixtureMonkey instance that facilitates the creation of test fixtures. There are several custom options available in Fixture Monkey that allow you to generate instances according to your specific requirements.
Here we are configuring the objectIntrospector to use ConstructorPropertiesArbitraryIntrospector, which means that the object will be constructed using the constructor annotated with @ConstructorProperties. An Introspector defines how Fixture Monkey generates objects.
For example, consider a Product class like this:
ðŸ’¡ lombok.anyConstructor.addConstructorProperties=true should be added in lombok.config @Value public class Product { long id; String productName; long price; List\u0026lt;String\u0026gt; options; Instant createdAt; ProductType productType; Map\u0026lt;Integer, String\u0026gt; merchantInfo; } (Note that the Lombok annotation @Value is used to make Immutable classes. If you\u0026rsquo;re working in an environment without Lombok, go to creating test objects without lombok)
For ConstructorPropertiesArbitraryIntrospector, the generated class should have a constructor with @ConstructorProperties or you can add lombok.anyConstructor.addConstructorProperties=true in the lombok.config file. (There are alternative Introspectors available, each with their own requirements. Check out the Introspectors section for more details.)
As shown in the then section above, an instance of the Product class is created.
`}),e.add({id:6,href:"/v1-1-0/docs/get-started/creating-objects-without-lombok/",title:"Creating objects without Lombok",description:`ðŸ’¡ If you're using Lombok in your project, feel free to move on to the next page. Creating test objects with Fixture Monkey is remarkably simple, even without Lombok. Here\u0026rsquo;s how you can use it:
@Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.create(); // when Product actual = fixtureMonkey.giveMeOne(Product.class); // then then(actual).isNotNull(); } When you run this code, Fixture Monkey will generate a Product instance with random values.`,content:` ðŸ’¡ If you're using Lombok in your project, feel free to move on to the next page. Creating test objects with Fixture Monkey is remarkably simple, even without Lombok. Here\u0026rsquo;s how you can use it:
@Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.create(); // when Product actual = fixtureMonkey.giveMeOne(Product.class); // then then(actual).isNotNull(); } When you run this code, Fixture Monkey will generate a Product instance with random values. Below is just an example, and the actual values will be different each time:
Product( id=42, productName=\u0026quot;product-value-1\u0026quot;, price=1000, options=[\u0026quot;option1\u0026quot;, \u0026quot;option2\u0026quot;], createdAt=2024-03-21T10:15:30Z, productType=ELECTRONICS, merchantInfo={1=\u0026quot;merchant1\u0026quot;, 2=\u0026quot;merchant2\u0026quot;} ) First, create a FixtureMonkey instance that facilitates the creation of test fixtures. You can use create() to generate a Fixture Monkey instance with default options. There are also several custom options available in Fixture Monkey that allow you to generate instances according to your specific requirements.
Fixture Monkey uses BeanArbitraryIntrospector as its default method for generating objects. An Introspector defines how Fixture Monkey generates objects.
For example, consider a Product class like this:
public class Product { private long id; private String productName; private long price; private List\u0026lt;String\u0026gt; options; private Instant createdAt; private ProductType productType; private Map\u0026lt;Integer, String\u0026gt; merchantInfo; public Product() { } public void setId(long id) { this.id = id; } public void setProductName(String productName) { this.productName = productName; } public void setPrice(long price) { this.price = price; } public void setOptions(List\u0026lt;String\u0026gt; options) { this.options = options; } public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; } public void setProductType(ProductType productType) { this.productType = productType; } public void setMerchantInfo(Map\u0026lt;Integer, String\u0026gt; merchantInfo) { this.merchantInfo = merchantInfo; } } For BeanArbitraryIntrospector, the class being generated needs to have a no-args constructor and setters, as shown in the Product class above. The introspector will create an instance using the no-args constructor and then set random values using the setter methods. (There are alternative Introspectors available, each with their own requirements. Check out the Introspectors section for more details.)
`}),e.add({id:7,href:"/v1-1-0/docs/get-started/creating-objects-in-kotlin/",title:"Creating objects in Kotlin",description:`Fixture Monkey helps you create test objects for your Kotlin classes easily. For example, suppose you have a Kotlin data class:
data class Product ( val id: Long, val productName: String, val price: Long, val options: List\u0026lt;String\u0026gt;, val createdAt: Instant, val productType: ProductType, val merchantInfo: Map\u0026lt;Int, String\u0026gt; ) With Fixture Monkey, you can create test instances of this class with just one line of code:
val product: Product = fixtureMonkey.giveMeOne() The generated object will contain random values that make sense for each field type.`,content:`Fixture Monkey helps you create test objects for your Kotlin classes easily. For example, suppose you have a Kotlin data class:
data class Product ( val id: Long, val productName: String, val price: Long, val options: List\u0026lt;String\u0026gt;, val createdAt: Instant, val productType: ProductType, val merchantInfo: Map\u0026lt;Int, String\u0026gt; ) With Fixture Monkey, you can create test instances of this class with just one line of code:
val product: Product = fixtureMonkey.giveMeOne() The generated object will contain random values that make sense for each field type. Here\u0026rsquo;s an example of what you might get:
Product( id=42, productName=\u0026quot;product-value-1\u0026quot;, price=1000, options=[\u0026quot;option1\u0026quot;, \u0026quot;option2\u0026quot;], createdAt=2024-03-21T10:15:30Z, productType=ELECTRONICS, merchantInfo={1=\u0026quot;merchant1\u0026quot;, 2=\u0026quot;merchant2\u0026quot;} ) To start using Fixture Monkey with Kotlin, follow these steps:
Add the fixture-monkey-starter-kotlin dependency to your project.
Create a FixtureMonkey instance with the Kotlin plugin:
@Test fun test() { val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .build() } The Kotlin plugin enables Fixture Monkey to work with Kotlin\u0026rsquo;s features, using the primary constructor to create objects.
Here\u0026rsquo;s a complete test example:
@Test fun test() { // given val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .build() // when val actual: Product = fixtureMonkey.giveMeOne() // then then(actual).isNotNull } You can also customize the generated objects using Kotlin\u0026rsquo;s property references:
@Test fun test() { // given val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .build(); // when val actual = fixtureMonkey.giveMeKotlinBuilder\u0026lt;Product\u0026gt;() .set(Product::id, 1000L) // Set specific id .size(Product::options, 3) // Set options list size .set(Product::options[1], \u0026quot;red\u0026quot;) // Set specific option .sample() // then then(actual.id).isEqualTo(1000L) then(actual.options).hasSize(3) then(actual.options[1]).isEqualTo(\u0026quot;red\u0026quot;) } For more Kotlin-specific features, check out the Kotlin Plugin documentation.
`}),e.add({id:8,href:"/v1-1-0/docs/get-started/adding-bean-validation/",title:"Adding Bean Validation",description:`Sometimes, you might want to create a valid test object that adheres to the constraints specified by the Bean Validation annotations on your class. Fixture Monkey makes this easy with support for jakarta.validation.constraints and javax.validation.constraints packages.
For example, consider a Product class with validation constraints:
@Value public class Product { @Min(1) long id; @NotBlank String productName; @Max(100000) long price; @Size(min = 3) List\u0026lt;@NotBlank String\u0026gt; options; @Past Instant createdAt; } To generate objects that satisfy these constraints, first add the appropriate dependency:`,content:`Sometimes, you might want to create a valid test object that adheres to the constraints specified by the Bean Validation annotations on your class. Fixture Monkey makes this easy with support for jakarta.validation.constraints and javax.validation.constraints packages.
For example, consider a Product class with validation constraints:
@Value public class Product { @Min(1) long id; @NotBlank String productName; @Max(100000) long price; @Size(min = 3) List\u0026lt;@NotBlank String\u0026gt; options; @Past Instant createdAt; } To generate objects that satisfy these constraints, first add the appropriate dependency:
Gradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-jakarta-validation:1.1.15\u0026quot;) Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-jakarta-validation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.15\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; Then, add the validation plugin to your FixtureMonkey configuration:
FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JakartaValidationPlugin()) // or new JavaxValidationPlugin() .build(); Note: If you\u0026rsquo;re using fixture-monkey-starter, the validation plugin is already included.
Now you can generate valid objects that satisfy all constraints:
@Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .plugin(new JakartaValidationPlugin()) .build(); // when Product actual = fixtureMonkey.giveMeOne(Product.class); // then then(actual).isNotNull(); then(actual.getId()).isGreaterThan(0); then(actual.getProductName()).isNotBlank(); then(actual.getPrice()).isLessThanOrEqualTo(100000); then(actual.getOptions().size()).isGreaterThanOrEqualTo(3); then(actual.getOptions()).allSatisfy(it -\u0026gt; then(it).isNotEmpty()); then(actual.getCreatedAt()).isNotNull().isLessThanOrEqualTo(Instant.now()); } When you run this code, Fixture Monkey will generate a Product instance that satisfies all validation constraints. Below is just an example, and the actual values will be different each time:
Product( id=42, // Satisfies @Min(1) productName=\u0026quot;product-1\u0026quot;, // Satisfies @NotBlank price=75000, // Satisfies @Max(100000) options=[ // Satisfies @Size(min = 3) \u0026quot;option1\u0026quot;, // Each string satisfies @NotBlank \u0026quot;option2\u0026quot;, \u0026quot;option3\u0026quot; ], createdAt=2024-03-20T10:15:30Z // Satisfies @Past ) `}),e.add({id:9,href:"/v1-1-0/docs/get-started/customizing-objects/",title:"Customizing objects",description:`Fixture Monkey allows you to customize test objects to match your specific test requirements. Let\u0026rsquo;s see how it works with a real-world example.
Why Customize Test Objects? # Suppose you\u0026rsquo;re testing a discount service that applies a 10% discount only to products priced over 1000. You need to test both scenarios:
Products that should get a discount (price \u0026gt; 1000) Products that shouldn\u0026rsquo;t get a discount (price â‰¤ 1000) Without Fixture Monkey, you might write code like this:`,content:`Fixture Monkey allows you to customize test objects to match your specific test requirements. Let\u0026rsquo;s see how it works with a real-world example.
Why Customize Test Objects? # Suppose you\u0026rsquo;re testing a discount service that applies a 10% discount only to products priced over 1000. You need to test both scenarios:
Products that should get a discount (price \u0026gt; 1000) Products that shouldn\u0026rsquo;t get a discount (price â‰¤ 1000) Without Fixture Monkey, you might write code like this:
// Without Fixture Monkey Product expensiveProduct = new Product(1, \u0026quot;Expensive Product\u0026quot;, 2000, ...); Product cheapProduct = new Product(2, \u0026quot;Cheap Product\u0026quot;, 500, ...); With Fixture Monkey, you can create these test objects more easily and flexibly.
Step-by-Step Guide # Let\u0026rsquo;s start with a simple Product class:
@Value public class Product { long id; String productName; long price; List\u0026lt;String\u0026gt; options; Instant createdAt; } Step 1: Create a FixtureMonkey Instance # First, create a FixtureMonkey instance with the appropriate introspector:
Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build(); val fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build() Step 2: Create a Product with Specific Price # Now, let\u0026rsquo;s create a product with a price of 2000 to test the discount scenario:
Java Kotlin @Test void testDiscountApplied() { // given Product expensiveProduct = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026#34;price\u0026#34;, 2000L) // Set price to 2000 .sample(); // when double discount = discountService.calculateDiscount(expensiveProduct); // then then(discount).isEqualTo(200.0); // 10% of 2000 } @Test fun testDiscountApplied() { // given val expensiveProduct = fixtureMonkey.giveMeBuilder(Product::class.java) .set(\u0026#34;price\u0026#34;, 2000L) // Set price to 2000 .sample() // when val discount = discountService.calculateDiscount(expensiveProduct) // then then(discount).isEqualTo(200.0) // 10% of 2000 } Step 3: Create a Product with Customized List # You can also customize collections. For example, to test a product with specific options:
Java Kotlin @Test void testProductWithOptions() { // given Product actual = fixtureMonkey.giveMeBuilder(Product.class) .size(\u0026#34;options\u0026#34;, 3) // Set list size to 3 .set(\u0026#34;options[1]\u0026#34;, \u0026#34;red\u0026#34;) // Set second element to \u0026#34;red\u0026#34; .sample(); // then then(actual.getOptions()).hasSize(3); then(actual.getOptions().get(1)).isEqualTo(\u0026#34;red\u0026#34;); } @Test fun testProductWithOptions() { // given val actual = fixtureMonkey.giveMeBuilder(Product::class.java) .size(\u0026#34;options\u0026#34;, 3) // Set list size to 3 .set(\u0026#34;options[1]\u0026#34;, \u0026#34;red\u0026#34;) // Set second element to \u0026#34;red\u0026#34; .sample() // then then(actual.options).hasSize(3) then(actual.options[1]).isEqualTo(\u0026#34;red\u0026#34;) } The generated Product will look like this:
Product( id=42, // Random value productName=\u0026quot;product-value-1\u0026quot;, // Random value price=2000, // Customized value options=[\u0026quot;option1\u0026quot;, \u0026quot;option2\u0026quot;], // Random values createdAt=2024-03-21T10:15:30Z // Random value ) Common Pitfalls and Tips # Field Names Use exact field names as they appear in your class Wrong: set(\u0026quot;product_name\u0026quot;, \u0026quot;test\u0026quot;) (field name mismatch) Right: set(\u0026quot;productName\u0026quot;, \u0026quot;test\u0026quot;) Tip: Use IDE\u0026rsquo;s code completion to avoid typos in field names Tip: Use setExp or setExpGetter for type-safe field access Tip: Install the Fixture Monkey Helper for enhanced code completion and type safety Java Kotlin // Type-safe field access .set(javaGetter(Product::getProductName), \u0026#34;test\u0026#34;) // Type-safe field access .setExp(Product::productName, \u0026#34;test\u0026#34;) // or .setExpGetter(Product::productName, { \u0026#34;test\u0026#34; }) Advanced Type-Safe Property Selection # Fixture Monkey provides several type-safe ways to select and customize object properties, eliminating the need for string-based property paths and reducing runtime errors.
Java: Typed Getter Methods # For Java classes, you can use typed getter methods with javaGetter() and customizeProperty():
Java @Test void typedJavaGetter() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .customizeProperty(javaGetter(Product::getProductName), arb -\u0026gt; arb.map(name -\u0026gt; \u0026#34;Custom-\u0026#34; + name)) .sample(); // productName will always start with \u0026#34;Custom-\u0026#34; then(product.getProductName()).startsWith(\u0026#34;Custom-\u0026#34;); } Java: Nested Property Selection # For nested objects, chain property selectors with .into():
Java @Test void nestedTypedJavaGetter() { OrderInfo orderInfo = fixtureMonkey.giveMeBuilder(OrderInfo.class) .customizeProperty( javaGetter(OrderInfo::getProduct).into(Product::getProductName), arb -\u0026gt; arb.map(name -\u0026gt; \u0026#34;Premium-\u0026#34; + name) ) .sample(); // Nested product name will start with \u0026#34;Premium-\u0026#34; then(orderInfo.getProduct().getProductName()).startsWith(\u0026#34;Premium-\u0026#34;); } Java: Collection Element Selection # For collections and arrays, use .index() to select specific elements:
Java @Test void indexTypedJavaGetter() { ProductCatalog catalog = fixtureMonkey.giveMeBuilder(ProductCatalog.class) .size(\u0026#34;products\u0026#34;, 3) .customizeProperty( javaGetter(ProductCatalog::getProducts).index(Product.class, 0), arb -\u0026gt; arb.map(product -\u0026gt; product.withPrice(9999L)) ) .sample(); // First product will have price 9999 then(catalog.getProducts().get(0).getPrice()).isEqualTo(9999L); } Kotlin: Property Reference Selection # Kotlin provides even more concise syntax with property references:
Kotlin @Test fun typedKotlinPropertySelector() { data class StringObject(val string: String) val result = fixtureMonkey.giveMeKotlinBuilder\u0026lt;StringObject\u0026gt;() .customizeProperty(StringObject::string) { it.map { _ -\u0026gt; \u0026#34;customized\u0026#34; } } .sample() then(result.string).isEqualTo(\u0026#34;customized\u0026#34;) } Kotlin: Nested Property Selection # Use into for nested properties in Kotlin:
Kotlin @Test fun typedNestedKotlinPropertySelector() { data class StringObject(val string: String) data class NestedStringObject(val obj: StringObject) val result = fixtureMonkey.giveMeKotlinBuilder\u0026lt;NestedStringObject\u0026gt;() .customizeProperty(NestedStringObject::obj into StringObject::string) { it.map { _ -\u0026gt; \u0026#34;nested-custom\u0026#34; } } .sample() then(result.obj.string).isEqualTo(\u0026#34;nested-custom\u0026#34;) } Mixed Java-Kotlin Property Selection # When working with mixed Java-Kotlin projects, you can combine different selector types:
Kotlin @Test fun typedRootIsKotlinNestedJavaPropertySelector() { data class RootJavaStringObject(val obj: JavaStringObject) val result = fixtureMonkey.giveMeKotlinBuilder\u0026lt;RootJavaStringObject\u0026gt;() .customizeProperty(RootJavaStringObject::obj intoGetter JavaStringObject::getString) { it.map { _ -\u0026gt; \u0026#34;mixed-custom\u0026#34; } } .sample() then(result.obj.string).isEqualTo(\u0026#34;mixed-custom\u0026#34;) } Benefits of Typed Property Selection # Compile-time Safety: Catch property name errors at compile time rather than runtime
IDE Support: Get auto-completion and refactoring support from your IDE
Type Safety: Ensure the correct types are used for property values
Maintainability: Changes to class structure are automatically reflected in tests
Collection Indexing
Remember that list indices start at 0 Wrong: set(\u0026quot;options[3]\u0026quot;, \u0026quot;red\u0026quot;) (for a list of size 3) Right: set(\u0026quot;options[2]\u0026quot;, \u0026quot;red\u0026quot;) Tip: Use size() before setting specific indices to ensure the list is large enough Type Safety
Make sure to use the correct type for values Wrong: set(\u0026quot;price\u0026quot;, \u0026quot;1000\u0026quot;) (String instead of Long) Right: set(\u0026quot;price\u0026quot;, 1000L) Tip: Use IDE\u0026rsquo;s type hints to ensure correct value types Comparison: Before and After # Before Fixture Monkey:
// Creating a product with specific options List\u0026lt;String\u0026gt; options = new ArrayList\u0026lt;\u0026gt;(); options.add(\u0026quot;option1\u0026quot;); options.add(\u0026quot;red\u0026quot;); options.add(\u0026quot;option3\u0026quot;); Product product = new Product(1, \u0026quot;Test Product\u0026quot;, 1000, options, Instant.now()); After Fixture Monkey:
// Same result with much less code Product product = fixtureMonkey.giveMeBuilder(Product.class) .size(\u0026quot;options\u0026quot;, 3) .set(\u0026quot;options[1]\u0026quot;, \u0026quot;red\u0026quot;) .sample(); For more examples of how to select properties with expressions and set property values, check out the customizing section.
`}),e.add({id:10,href:"/v1-1-0/docs/get-started/tips/",title:"Tips for Beginners",description:"Essential Tips for Using Fixture Monkey # 1. Use Type-Safe Methods # Prefer type-safe methods over string-based ones Example: // Instead of .set(\u0026quot;price\u0026quot;, 1000L) // Use .set(javaGetter(Product::getPrice), 1000L) 2. Use Meaningful Test Data # Use values that make sense in your test context Avoid using arbitrary values like \u0026ldquo;test\u0026rdquo; or \u0026ldquo;123\u0026rdquo; Consider business rules and constraints when setting values Benefits: Makes tests more readable and self-documenting Helps identify test failures more quickly Makes it easier to understand test scenarios Reduces the need for additional comments Example: // Use meaningful values Product product = fixtureMonkey.",content:`Essential Tips for Using Fixture Monkey # 1. Use Type-Safe Methods # Prefer type-safe methods over string-based ones Example: // Instead of .set(\u0026quot;price\u0026quot;, 1000L) // Use .set(javaGetter(Product::getPrice), 1000L) 2. Use Meaningful Test Data # Use values that make sense in your test context Avoid using arbitrary values like \u0026ldquo;test\u0026rdquo; or \u0026ldquo;123\u0026rdquo; Consider business rules and constraints when setting values Benefits: Makes tests more readable and self-documenting Helps identify test failures more quickly Makes it easier to understand test scenarios Reduces the need for additional comments Example: // Use meaningful values Product product = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026quot;price\u0026quot;, 1000L) // Use realistic price that matches business rules .set(\u0026quot;name\u0026quot;, \u0026quot;Premium Product\u0026quot;) // Use descriptive name that indicates product type .set(\u0026quot;category\u0026quot;, \u0026quot;ELECTRONICS\u0026quot;) // Use valid category from your domain .set(\u0026quot;stock\u0026quot;, 50) // Use reasonable stock quantity .sample(); 3. Keep Tests Readable # Add comments to explain why specific values are set Example: Product product = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026quot;price\u0026quot;, 2000L) // Price above discount threshold .set(\u0026quot;category\u0026quot;, \u0026quot;PREMIUM\u0026quot;) // Category that gets special treatment .sample(); 4. Handle Collections Properly # Set collection size before accessing specific indices Example: Product product = fixtureMonkey.giveMeBuilder(Product.class) .size(\u0026quot;options\u0026quot;, 3) // Set size first .set(\u0026quot;options[1]\u0026quot;, \u0026quot;red\u0026quot;) // Then access specific index .sample(); 5. Reuse FixtureMonkey Instance # Create one instance and reuse it across tests Example: public class ProductTest { private static final FixtureMonkey FIXTURE_MONKEY = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build(); @Test void test1() { Product product = FIXTURE_MONKEY.giveMeBuilder(Product.class).sample(); // ... } @Test void test2() { Product product = FIXTURE_MONKEY.giveMeBuilder(Product.class).sample(); // ... } } 6. Reuse ArbitraryBuilder # Reuse ArbitraryBuilder instances to maintain consistent test data structure Share common configurations across multiple tests Improve code readability by centralizing test data setup Example: public class ProductTest { private static final FixtureMonkey FIXTURE_MONKEY = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build(); // Base configuration for premium products private static final ArbitraryBuilder\u0026lt;Product\u0026gt; PREMIUM_PRODUCT_BUILDER = FIXTURE_MONKEY.giveMeBuilder(Product.class) .set(\u0026quot;category\u0026quot;, \u0026quot;PREMIUM\u0026quot;) .set(\u0026quot;price\u0026quot;, 1000L); @Test void testDiscountForPremiumProduct() { // Test discount for premium product with price above threshold Product product = PREMIUM_PRODUCT_BUILDER .set(\u0026quot;price\u0026quot;, 2000L) // Price above discount threshold .sample(); // Test discount logic } @Test void testShippingForPremiumProduct() { // Test shipping for premium product with minimum order amount Product product = PREMIUM_PRODUCT_BUILDER .set(\u0026quot;price\u0026quot;, 5000L) // Price above free shipping threshold .sample(); // Test shipping logic } } 7. Start with Simple Objects # Begin with basic objects before moving to complex ones Example: public class ProductTest { private static final FixtureMonkey FIXTURE_MONKEY = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build(); @Test void testBasicProduct() { // Start with a simple object Product product = FIXTURE_MONKEY.giveMeBuilder(Product.class) .set(\u0026quot;name\u0026quot;, \u0026quot;Test Product\u0026quot;) .sample(); // ... } } 8. Use the IntelliJ Plugin # Install the Fixture Monkey Helper plugin to enhance your development experience:
Smart code completion for Fixture Monkey methods Type-safe field access suggestions using method references Quick navigation to field definitions Automatic import suggestions for Fixture Monkey classes Real-time validation of field names and types 9. Common Use Cases # Testing validation rules Testing business logic with specific conditions Creating test data for integration tests Generating random but valid test data 10. Best Practices # Keep test data generation close to where it\u0026rsquo;s used Use meaningful variable names Document complex test scenarios Use constants for frequently used values `}),e.add({id:11,href:"/v1-1-0/docs/generating-objects/",title:"Generating Objects",description:`Creating test data is one of the most important and time-consuming parts of writing tests. Fixture Monkey simplifies this task by providing an easy and flexible way to generate test objects of any complexity.
This section covers:
Creating a FixtureMonkey instance - the main entry point for generating test objects Basic object generation methods for simple and common use cases Handling complex types like interfaces and generic types Customizing how objects are created and initialized Whether you need a simple POJO or a complex object graph with specific constraints, Fixture Monkey\u0026rsquo;s intuitive API makes test data generation straightforward and maintainable.`,content:`Creating test data is one of the most important and time-consuming parts of writing tests. Fixture Monkey simplifies this task by providing an easy and flexible way to generate test objects of any complexity.
This section covers:
Creating a FixtureMonkey instance - the main entry point for generating test objects Basic object generation methods for simple and common use cases Handling complex types like interfaces and generic types Customizing how objects are created and initialized Whether you need a simple POJO or a complex object graph with specific constraints, Fixture Monkey\u0026rsquo;s intuitive API makes test data generation straightforward and maintainable.
`}),e.add({id:12,href:"/v1-1-0/docs/generating-objects/fixture-monkey/",title:"FixtureMonkey",description:`What is FixtureMonkey? # FixtureMonkey is the main entry point for creating test fixtures in the Fixture Monkey library. Think of it as a factory that knows how to create instances of any class with random but valid values. This makes it perfect for generating test data without writing verbose setup code.
How it works - A quick overview # The typical workflow with Fixture Monkey looks like this:
Create a FixtureMonkey instance Use one of its generation methods to create test objects Optionally customize the objects to match specific test requirements For example, here\u0026rsquo;s a complete test using Fixture Monkey:`,content:`What is FixtureMonkey? # FixtureMonkey is the main entry point for creating test fixtures in the Fixture Monkey library. Think of it as a factory that knows how to create instances of any class with random but valid values. This makes it perfect for generating test data without writing verbose setup code.
How it works - A quick overview # The typical workflow with Fixture Monkey looks like this:
Create a FixtureMonkey instance Use one of its generation methods to create test objects Optionally customize the objects to match specific test requirements For example, here\u0026rsquo;s a complete test using Fixture Monkey:
Java Kotlin @Test void testProductDiscount() { // 1. Create a FixtureMonkey instance FixtureMonkey fixtureMonkey = FixtureMonkey.create(); // 2. Generate a test object with specific properties Product product = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026#34;price\u0026#34;, 100.0) .sample(); // 3. Use the object in your test double discountedPrice = productService.applyDiscount(product, 10); // 4. Assert the expected outcome assertEquals(90.0, discountedPrice); } @Test fun testProductDiscount() { // 1. Create a FixtureMonkey instance val fixtureMonkey = FixtureMonkey.plugin(KotlinPlugin()).build() // 2. Generate a test object with specific properties val product: Product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .set(\u0026#34;price\u0026#34;, 100.0) .sample() // 3. Use the object in your test val discountedPrice = productService.applyDiscount(product, 10) // 4. Assert the expected outcome assertEquals(90.0, discountedPrice) } Now let\u0026rsquo;s learn the specific steps to use FixtureMonkey in your tests.
Creating a FixtureMonkey Instance # To generate test fixtures, the first step is to create a FixtureMonkey instance, which facilitates the creation of test fixtures.
You can use the create() method to generate a FixtureMonkey instance with default options. For Kotlin environments, add the Kotlin plugin.
Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.create(); val fixtureMonkey = FixtureMonkey .plugin(KotlinPlugin()) .build() If you want to add some options for creating or customizing the test fixtures, you can add them using the FixtureMonkey builder.
Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() + options... .build(); val fixtureMonkey = FixtureMonkey.builder() + options... .build() For information on what options are available, see the Fixture Monkey Options section.
Generating instances # The FixtureMonkey class provides several methods to help create test objects of the required type.
When to use which method? # Here\u0026rsquo;s a quick guide to help you choose the right method:
giveMeOne() - When you need a single instance with default random values giveMe() - When you need multiple instances with default random values giveMeBuilder() - When you need to customize properties before creating instances giveMeArbitrary() - Advanced usage when working with jqwik\u0026rsquo;s Arbitrary API giveMeOne() # If you need an instance of a certain type, you can use giveMeOne(). Pass either a class or a type reference.
Java Kotlin Product product = fixtureMonkey.giveMeOne(Product.class); List\u0026lt;String\u0026gt; strList = fixtureMonkey.giveMeOne(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {}); val product: Product = fixtureMonkey.giveMeOne() val strList: List\u0026lt;String\u0026gt; = fixtureMonkey.giveMeOne() giveMe() # If you need multiple instances of a certain type, you can use the giveMe() method. You can choose to generate either a stream of instances or a list by specifying the desired size.
Java Kotlin Stream\u0026lt;Product\u0026gt; productStream = fixtureMonkey.giveMe(Product.class); Stream\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; strListStream = fixtureMonkey.giveMe(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {}); List\u0026lt;Product\u0026gt; productList = fixtureMonkey.giveMe(Product.class, 3); List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; strListList = fixtureMonkey.giveMe(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {}, 3); val productSequence: Sequence\u0026lt;Product\u0026gt; = fixtureMonkey.giveMe() val strListSequence: Sequence\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; = fixtureMonkey.giveMe() val productList: List\u0026lt;Product\u0026gt; = fixtureMonkey.giveMe(3) val strListList: List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; = fixtureMonkey.giveMe(3) giveMeBuilder() # If you need to further customize the instance to be created, you can use giveMeBuilder(). This will return an ArbitraryBuilder of the given type. An ArbitraryBuilder is a class in Fixture Monkey that acts as a builder for an Arbitrary object of the given class.
Java Kotlin ArbitraryBuilder\u0026lt;Product\u0026gt; productBuilder = fixtureMonkey.giveMeBuilder(Product.class); ArbitraryBuilder\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; strListBuilder = fixtureMonkey.giveMeBuilder(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {}); val productBuilder: ArbitraryBuilder\u0026lt;Product\u0026gt; = fixtureMonkey.giveMeBuilder() val strListBuilder: ArbitraryBuilder\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; = fixtureMonkey.giveMeBuilder() For cases where you already have a generated instance and want to customize it further, you can also use giveMeBuilder().
Java Kotlin Product product = new Product(1L, \u0026#34;Book\u0026#34;, ...); ArbitraryBuilder\u0026lt;Product\u0026gt; productBuilder = fixtureMonkey.giveMeBuilder(product); val product = Product(1L, \u0026#34;Book\u0026#34;, ...) val productBuilder = fixtureMonkey.giveMeBuilder(product) The generated ArbitraryBuilder can be used for further customization of your fixture. For more information on customization options, see the section on customization objects.
To obtain an instance from the ArbitraryBuilder, you can use the sample(), sampleList(), sampleStream() methods of the ArbitraryBuilder.
Java Kotlin ArbitraryBuilder\u0026lt;Product\u0026gt; productBuilder = fixtureMonkey.giveMeBuilder(Product.class); Product product = productBuilder.sample(); List\u0026lt;Product\u0026gt; productList = productBuilder.sampleList(3); Stream\u0026lt;Product\u0026gt; productStream = productBuilder.sampleStream(); val productBuilder: ArbitraryBuilder\u0026lt;Product\u0026gt; = fixtureMonkey.giveMeBuilder() val product = productBuilder.sample() val productList = productBuilder.sampleList(3) val productStream = productBuilder.sampleStream() In cases where you need an Arbitrary itself rather than an instance, you can simply call the build() method.
Java Kotlin ArbitraryBuilder\u0026lt;Product\u0026gt; productBuilder = fixtureMonkey.giveMeBuilder(Product.class); Arbitrary\u0026lt;Product\u0026gt; productArbitrary = productBuilder.build(); val productBuilder: ArbitraryBuilder\u0026lt;Product\u0026gt; = fixtureMonkey.giveMeBuilder() val productArbitrary = productBuilder.build() giveMeArbitrary() # To get an Arbitrary of the specified type, you can use the giveMeArbitrary() method.
Java Kotlin Arbitrary\u0026lt;Product\u0026gt; productArbitrary = fixtureMonkey.giveMeArbitrary(Product.class); Arbitrary\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; strListArbitrary = fixtureMonkey.giveMeArbitrary(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {}); val productArbitrary: Arbitrary\u0026lt;Product\u0026gt; = fixtureMonkey.giveMeArbitrary() val strListArbitrary: Arbitrary\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; = fixtureMonkey.giveMeArbitrary() `}),e.add({id:13,href:"/v1-1-0/docs/generating-objects/generating-complex-types/",title:"Generating Complex Types",description:`Why Complex Types Matter in Testing # When writing real-world tests, you\u0026rsquo;ll often need to work with complex objects that include:
Generic types with multiple type parameters Self-referencing structures (like trees or graphs) Complex interface hierarchies Sealed or abstract classes Manually creating instances of these types for testing can be extremely tedious and error-prone. This is where Fixture Monkey shines - it can automatically generate valid instances of even the most complex types with minimal code.`,content:`Why Complex Types Matter in Testing # When writing real-world tests, you\u0026rsquo;ll often need to work with complex objects that include:
Generic types with multiple type parameters Self-referencing structures (like trees or graphs) Complex interface hierarchies Sealed or abstract classes Manually creating instances of these types for testing can be extremely tedious and error-prone. This is where Fixture Monkey shines - it can automatically generate valid instances of even the most complex types with minimal code.
How Fixture Monkey Handles Complex Types # Fixture Monkey analyzes the structure of your classes and interfaces at runtime, understanding their relationships and constraints. It then generates valid instances with all the necessary fields populated, even for nested and recursive structures.
For interfaces, Fixture Monkey applies special handling. When an interface has multiple implementations, Fixture Monkey randomly selects one of the available implementations to generate. This is especially useful when testing interfaces with various implementations. Of course, you can also explicitly specify which implementations to use. This behavior can be controlled in detail through the InterfacePlugin.
// Example of specifying multiple implementations for a UserService interface FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin( new InterfacePlugin() .interfaceImplements(UserService.class, List.of(BasicUserService.class, PremiumUserService.class)) ) .build(); // One of the specified implementations will be randomly selected UserService userService = fixtureMonkey.giveMeOne(UserService.class); Let\u0026rsquo;s look at examples of complex types and how to generate them with Fixture Monkey.
Java # Generic Objects # Generic types with type parameters can be challenging to instantiate correctly in tests:
@Value public static class GenericObject\u0026lt;T\u0026gt; { T foo; } @Value public static class GenericArrayObject\u0026lt;T\u0026gt; { GenericObject\u0026lt;T\u0026gt;[] foo; } @Value public static class TwoGenericObject\u0026lt;T, U\u0026gt; { T foo; U bar; } @Value public static class ThreeGenericObject\u0026lt;T, U, V\u0026gt; { T foo; U bar; V baz; } To generate instances of these generic types with Fixture Monkey:
// Simple generic with String GenericObject\u0026lt;String\u0026gt; stringGeneric = fixtureMonkey.giveMeOne( new TypeReference\u0026lt;GenericObject\u0026lt;String\u0026gt;\u0026gt;() {} ); // Generic with array GenericArrayObject\u0026lt;Integer\u0026gt; arrayGeneric = fixtureMonkey.giveMeOne( new TypeReference\u0026lt;GenericArrayObject\u0026lt;Integer\u0026gt;\u0026gt;() {} ); // Multiple type parameters TwoGenericObject\u0026lt;String, Integer\u0026gt; twoParamGeneric = fixtureMonkey.giveMeOne( new TypeReference\u0026lt;TwoGenericObject\u0026lt;String, Integer\u0026gt;\u0026gt;() {} ); Generic Interfaces # public interface GenericInterface\u0026lt;T\u0026gt; { } @Value public static class GenericInterfaceImpl\u0026lt;T\u0026gt; implements GenericInterface\u0026lt;T\u0026gt; { T foo; } public interface TwoGenericInterface\u0026lt;T, U\u0026gt; { } @Value public static class TwoGenericImpl\u0026lt;T, U\u0026gt; implements TwoGenericInterface\u0026lt;T, U\u0026gt; { T foo; U bar; } To generate interface implementations:
// Generate an implementation of GenericInterface\u0026lt;String\u0026gt; GenericInterface\u0026lt;String\u0026gt; genericInterface = fixtureMonkey.giveMeOne( new TypeReference\u0026lt;GenericInterface\u0026lt;String\u0026gt;\u0026gt;() {} ); For example, when you have multiple classes implementing the same interface:
public interface PaymentProcessor { void processPayment(double amount); } public class CreditCardProcessor implements PaymentProcessor { @Override public void processPayment(double amount) { // Credit card payment processing logic } } public class BankTransferProcessor implements PaymentProcessor { @Override public void processPayment(double amount) { // Bank transfer payment processing logic } } // One of the implementations will be randomly selected PaymentProcessor processor = fixtureMonkey.giveMeOne(PaymentProcessor.class); SelfReference # Self-referencing types are particularly challenging to create manually but easy with Fixture Monkey:
@Value public class SelfReference { String foo; SelfReference bar; } @Value public class SelfReferenceList { String foo; List\u0026lt;SelfReferenceList\u0026gt; bar; } Generate self-referencing objects with depth control:
// Default generation (limited nesting depth to avoid infinite recursion) SelfReference selfRef = fixtureMonkey.giveMeOne(SelfReference.class); // With custom configuration to control container size FixtureMonkey customFixture = FixtureMonkey.builder() .defaultArbitraryContainerInfo(new ContainerInfo(2, 2)) // Controls lists size .build(); SelfReferenceList refList = customFixture.giveMeOne(SelfReferenceList.class); Interface # public interface Interface { String foo(); Integer bar(); } public interface InheritedInterface extends Interface { String foo(); } public interface InheritedInterfaceWithSameNameMethod extends Interface { String foo(); } public interface ContainerInterface { List\u0026lt;String\u0026gt; baz(); Map\u0026lt;String, Integer\u0026gt; qux(); } public interface InheritedTwoInterface extends Interface, ContainerInterface { } Kotlin # Generic Objects # class Generic\u0026lt;T\u0026gt;(val foo: T) class GenericImpl(val foo: Generic\u0026lt;String\u0026gt;) Generating Kotlin generic objects:
// Generate a Generic\u0026lt;Int\u0026gt; val genericInt: Generic\u0026lt;Int\u0026gt; = fixtureMonkey.giveMeOne() // Generate a GenericImpl with nested Generic\u0026lt;String\u0026gt; val genericImpl: GenericImpl = fixtureMonkey.giveMeOne() SelfReference # class SelfReference(val foo: String, val bar: SelfReference?) Sealed class, Value class # sealed class SealedClass object ObjectSealedClass : SealedClass() class SealedClassImpl(val foo: String) : SealedClass() @JvmInline value class ValueClass(val foo: String) Generating sealed classes and value classes in Kotlin:
// Fixture Monkey will choose a concrete implementation of the sealed class val sealedClass: SealedClass = fixtureMonkey.giveMeOne() // Generate a value class val valueClass: ValueClass = fixtureMonkey.giveMeOne() Kotlin sealed classes are handled similarly to interfaces. Fixture Monkey randomly selects one of the subclasses of the sealed class to generate.
Tips for Working with Complex Types # Use TypeReference for generic types to preserve type information For complex interfaces, you may need to configure implementation classes using InterfacePlugin If you want to use only specific implementations for interfaces or abstract classes, use InterfacePlugin.interfaceImplements() For very complex structures, consider breaking them down and building them step by step `}),e.add({id:14,href:"/v1-1-0/docs/generating-objects/instantiate-methods/",title:"Instantiate Methods",description:`Overview: Why Specify Object Creation Methods # By default, Fixture Monkey automatically determines how to create objects through Introspectors. However, sometimes you may need to specify a particular creation method for reasons such as:
Specific constructor usage: When a class has multiple constructors and you want to choose a specific one Factory method utilization: When you want to create objects using factory methods instead of constructors Different initialization per test: When you need different initialization methods for the same class in different tests Special initialization logic: When you need special initialization that can\u0026rsquo;t be handled automatically by introspectors In these situations, the instantiate() method allows you to precisely control how objects are created.`,content:`Overview: Why Specify Object Creation Methods # By default, Fixture Monkey automatically determines how to create objects through Introspectors. However, sometimes you may need to specify a particular creation method for reasons such as:
Specific constructor usage: When a class has multiple constructors and you want to choose a specific one Factory method utilization: When you want to create objects using factory methods instead of constructors Different initialization per test: When you need different initialization methods for the same class in different tests Special initialization logic: When you need special initialization that can\u0026rsquo;t be handled automatically by introspectors In these situations, the instantiate() method allows you to precisely control how objects are created.
ðŸ’¡ This document explains how to specify object creation methods on a per-test basis. If you want to apply the same method for all tests, refer to the Introspector page. Getting Started: Basic Usage # The most basic way to create objects with Fixture Monkey is:
// Basic approach - let the introspector automatically determine how to create objects Product product = fixtureMonkey.giveMeOne(Product.class); However, if you want to use a specific constructor or factory method, you can use the instantiate() method:
// Specify a constructor Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate(constructor()) .sample(); // Specify a factory method Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate(factoryMethod(\u0026quot;create\u0026quot;)) .sample(); â­ Beginner tip: In most cases, the basic approach (giveMeOne) is sufficient. Only use the instantiate() method when you have special initialization requirements. Basic Concepts # What is ArbitraryBuilder? # ArbitraryBuilder is a builder class for configuring object creation settings. It\u0026rsquo;s returned when you call the giveMeBuilder() method in Fixture Monkey.
// Get an ArbitraryBuilder ArbitraryBuilder\u0026lt;Product\u0026gt; builder = fixtureMonkey.giveMeBuilder(Product.class); What is the instantiate() method? # The instantiate() method allows you to specify how the ArbitraryBuilder should create objects. You can choose between constructors and factory methods:
ðŸ“Œ Method format:
Java Kotlin // Specifying a constructor in Java .instantiate(constructor()) // Specifying a factory method in Java .instantiate(factoryMethod(\u0026#34;methodName\u0026#34;)) // Specifying a constructor in Kotlin (Kotlin Plugin required) .instantiateBy { constructor() } // Specifying a factory method in Kotlin .instantiateBy { factory(\u0026#34;methodName\u0026#34;) } 1. Using Simple Constructors # Let\u0026rsquo;s start with the most basic usage. Here\u0026rsquo;s a simple class example:
Java Kotlin public class SimpleProduct { private final String name; private final int price; // Constructor public SimpleProduct(String name, int price) { this.name = name; this.price = price; } // Getter methods public String getName() { return name; } public int getPrice() { return price; } } class SimpleProduct( val name: String, val price: Int ) Using the constructor to create an object:
Java Kotlin @Test void usingSimpleConstructor() { SimpleProduct product = fixtureMonkey.giveMeBuilder(SimpleProduct.class) .instantiate(constructor()) .sample(); // Verify the created object assertThat(product).isNotNull(); assertThat(product.getName()).isNotNull(); assertThat(product.getPrice()).isNotNegative(); } @Test fun usingSimpleConstructor() { val product = fixtureMonkey.giveMeBuilder\u0026lt;SimpleProduct\u0026gt;() .instantiateBy { constructor() } .sample() // Verify the created object assertThat(product).isNotNull() assertThat(product.name).isNotNull() assertThat(product.price).isNotNegative() } In this example, constructor() specifies that the constructor of SimpleProduct should be used. Fixture Monkey automatically generates appropriate values and passes them to the constructor.
2. Choosing Between Multiple Constructors # Now let\u0026rsquo;s look at a class with multiple constructors:
Java Kotlin public class Product { private final long id; private final String name; private final long price; private final List\u0026lt;String\u0026gt; options; // Default constructor (all fields with default values) public Product() { this.id = 0; this.name = \u0026#34;defaultProduct\u0026#34;; this.price = 0; this.options = null; } // Simple product constructor without options public Product(String name, long price) { this.id = new Random().nextLong(); this.name = name; this.price = price; this.options = Collections.emptyList(); } // Product constructor with options public Product(String name, long price, List\u0026lt;String\u0026gt; options) { this.id = new Random().nextLong(); this.name = name; this.price = price; this.options = options; } // Getter methods public long getId() { return id; } public String getName() { return name; } public long getPrice() { return price; } public List\u0026lt;String\u0026gt; getOptions() { return options; } } class Product { val id: Long val name: String val price: Long val options: List\u0026lt;String\u0026gt; // Default constructor (all fields with default values) constructor() { this.id = 0 this.name = \u0026#34;defaultProduct\u0026#34; this.price = 0 this.options = emptyList() } // Simple product constructor without options constructor(name: String, price: Long) { this.id = Random().nextLong() this.name = name this.price = price this.options = emptyList() } // Product constructor with options constructor(name: String, price: Long, options: List\u0026lt;String\u0026gt;) { this.id = Random().nextLong() this.name = name this.price = price this.options = options } } 2.1 Using the Default Constructor # To use the default constructor:
Java Kotlin @Test void usingDefaultConstructor() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate(constructor()) // No parameters means default constructor .sample(); assertThat(product.getId()).isEqualTo(0); assertThat(product.getName()).isEqualTo(\u0026#34;defaultProduct\u0026#34;); } @Test fun usingDefaultConstructor() { val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .instantiateBy { constructor() // No parameters means default constructor } .sample() assertThat(product.id).isEqualTo(0) assertThat(product.name).isEqualTo(\u0026#34;defaultProduct\u0026#34;) } When you specify constructor() without parameters, Fixture Monkey uses the no-args constructor (default constructor).
2.2 Selecting a Specific Constructor # When a class has multiple constructors, you can specify parameter types to select the desired constructor:
Java Kotlin @Test void selectingConstructorWithoutOptions() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate( constructor() .parameter(String.class) // First parameter type .parameter(long.class) // Second parameter type ) .sample(); assertThat(product.getOptions()).isEmpty(); } @Test void selectingConstructorWithOptions() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate( constructor() .parameter(String.class) .parameter(long.class) .parameter(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;(){}) // Generic type ) .sample(); assertThat(product.getOptions()).isNotNull(); } @Test fun selectingConstructorWithoutOptions() { val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .instantiateBy { constructor\u0026lt;Product\u0026gt; { parameter\u0026lt;String\u0026gt;() // First parameter type parameter\u0026lt;Long\u0026gt;() // Second parameter type } } .sample() assertThat(product.options).isEmpty() } @Test fun selectingConstructorWithOptions() { val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .instantiateBy { constructor\u0026lt;Product\u0026gt; { parameter\u0026lt;String\u0026gt;() parameter\u0026lt;Long\u0026gt;() parameter\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() // Generic type } } .sample() assertThat(product.options).isNotNull() } Term Explanation: The parameter() method specifies the parameter types to select the desired constructor.
2.3 Specifying Constructor Parameter Values # To provide specific values for constructor parameters, you can use parameter name hints:
Java Kotlin @Test void specifyingParameterValues() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate( constructor() .parameter(String.class, \u0026#34;productName\u0026#34;) // Parameter name hint .parameter(long.class) ) .set(\u0026#34;productName\u0026#34;, \u0026#34;specialProduct\u0026#34;) // Set value using the hint name .sample(); assertThat(product.getName()).isEqualTo(\u0026#34;specialProduct\u0026#34;); } @Test fun specifyingParameterValues() { val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .instantiateBy { constructor\u0026lt;Product\u0026gt; { parameter\u0026lt;String\u0026gt;(\u0026#34;productName\u0026#34;) // Parameter name hint parameter\u0026lt;Long\u0026gt;() } } .set(\u0026#34;productName\u0026#34;, \u0026#34;specialProduct\u0026#34;) // Set value using the hint name .sample() assertThat(product.name).isEqualTo(\u0026#34;specialProduct\u0026#34;) } Term Explanation: A parameter name hint assigns an alias to a constructor parameter, allowing you to set values for it later using this name.
3. Using Factory Methods # Besides constructors, you can create objects using factory methods. Let\u0026rsquo;s look at a class with factory methods:
Java Kotlin public class Product { // Fields and constructors defined earlier... // Factory method public static Product create(String name, long price) { return new Product(name, price); } // Recommended product factory method public static Product createRecommended(long price) { return new Product(\u0026#34;recommendedProduct\u0026#34;, price); } } class Product { // Fields and constructors defined earlier... companion object { // Factory method fun create(name: String, price: Long): Product { return Product(name, price) } // Recommended product factory method fun createRecommended(price: Long): Product { return Product(\u0026#34;recommendedProduct\u0026#34;, price) } } } 3.1 Basic Factory Method Usage # To create an object using a factory method:
Java Kotlin @Test void usingFactoryMethod() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate( factoryMethod(\u0026#34;create\u0026#34;) // Specify factory method name ) .sample(); assertThat(product).isNotNull(); assertThat(product.getOptions()).isEmpty(); } @Test fun usingFactoryMethod() { val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .instantiateBy { factory\u0026lt;Product\u0026gt;(\u0026#34;create\u0026#34;) // Specify factory method name } .sample() assertThat(product).isNotNull() assertThat(product.options).isEmpty() } Term Explanation: A factory method is a static method responsible for object creation, used instead of directly calling constructors.
3.2 Selecting a Specific Factory Method # When there are multiple factory methods, you can specify parameter types to select the desired method:
Java Kotlin @Test void selectingSpecificFactoryMethod() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate( factoryMethod(\u0026#34;createRecommended\u0026#34;) .parameter(long.class) // Parameter type ) .sample(); assertThat(product.getName()).isEqualTo(\u0026#34;recommendedProduct\u0026#34;); } @Test fun selectingSpecificFactoryMethod() { val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .instantiateBy { factory\u0026lt;Product\u0026gt;(\u0026#34;createRecommended\u0026#34;) { parameter\u0026lt;Long\u0026gt;() // Parameter type } } .sample() assertThat(product.name).isEqualTo(\u0026#34;recommendedProduct\u0026#34;) } 3.3 Specifying Factory Method Parameter Values # To provide specific values for factory method parameters:
Java Kotlin @Test void specifyingFactoryMethodParameterValues() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate( factoryMethod(\u0026#34;create\u0026#34;) .parameter(String.class, \u0026#34;productName\u0026#34;) // Parameter name hint .parameter(long.class, \u0026#34;productPrice\u0026#34;) ) .set(\u0026#34;productName\u0026#34;, \u0026#34;customProduct\u0026#34;) .set(\u0026#34;productPrice\u0026#34;, 9900L) .sample(); assertThat(product.getName()).isEqualTo(\u0026#34;customProduct\u0026#34;); assertThat(product.getPrice()).isEqualTo(9900L); } @Test fun specifyingFactoryMethodParameterValues() { val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .instantiateBy { factory\u0026lt;Product\u0026gt;(\u0026#34;create\u0026#34;) { parameter\u0026lt;String\u0026gt;(\u0026#34;productName\u0026#34;) // Parameter name hint parameter\u0026lt;Long\u0026gt;(\u0026#34;productPrice\u0026#34;) } } .set(\u0026#34;productName\u0026#34;, \u0026#34;customProduct\u0026#34;) .set(\u0026#34;productPrice\u0026#34;, 9900L) .sample() assertThat(product.name).isEqualTo(\u0026#34;customProduct\u0026#34;) assertThat(product.price).isEqualTo(9900L) } 4. Advanced Features and Important Notes # Here are some advanced features and important notes to be aware of when creating objects.
4.1 Choosing Between Field and JavaBeansProperty # You can control how property values are set during object creation. There are two main approaches:
ðŸ“˜ These options determine how properties not initialized by the constructor or factory method will be set after the object is created. field(): Generate properties based on class fields
Pros: Direct field access, works without setters Cons: Bypasses encapsulation, ignores validation logic javaBeansProperty(): Generate properties based on getter/setter methods
Pros: Respects encapsulation, uses validation logic in setters Cons: Requires setter methods to set properties ðŸ“‹ Quick selection guide:
If setter methods have validation logic and you want to test it: javaBeansProperty() If there are no setter methods or you want to bypass validation: field() 4.1.1 Field-Based Property Generation # To generate properties based on fields:
Java Kotlin @Test void fieldBasedPropertyGeneration() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate( constructor().field() // Field-based property generation ) .sample(); assertThat(product).isNotNull(); } @Test fun fieldBasedPropertyGeneration() { val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .instantiateBy { constructor { javaField() // Field-based property generation } } .sample() assertThat(product).isNotNull() } Term Explanation: Fields are variables defined in a class that store the object\u0026rsquo;s state. Field-based property generation uses these fields directly to set values.
4.1.2 JavaBeansProperty-Based Property Generation # To generate properties based on JavaBeansProperty:
Java Kotlin @Test void javaBeanPropertyBasedGeneration() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate( constructor().javaBeansProperty() // JavaBeansProperty-based generation ) .sample(); assertThat(product).isNotNull(); } @Test fun javaBeanPropertyBasedGeneration() { val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .instantiateBy { constructor { javaBeansProperty() // JavaBeansProperty-based generation } } .sample() assertThat(product).isNotNull() } Term Explanation: JavaBeansProperty refers to properties represented by getter/setter method pairs. For example, the getName()/setName() method pair represents the \u0026rsquo;name\u0026rsquo; property.
4.2 Property Setting After Constructor Invocation # âš ï¸ This section explains important cautions when Fixture Monkey sets property values after object creation. When you specify a constructor using the instantiate() method, Fixture Monkey sets random values for properties not handled by the constructor after object creation. This feature is useful when you want to generate test data for fields that are not initialized in the constructor.
How it works at a glance: # Specify constructor: instantiate(constructor()...) Create object using constructor Set random values for properties not initialized by constructor Return complete object Let\u0026rsquo;s see an example:
Java Kotlin public class PartiallyInitializedObject { private final String name; // Initialized in constructor private int count; // Not initialized in constructor private List\u0026lt;String\u0026gt; items; // Not initialized in constructor public PartiallyInitializedObject(String name) { this.name = name; } // Getter/Setter public String getName() { return name; } public int getCount() { return count; } public void setCount(int count) { this.count = count; } public List\u0026lt;String\u0026gt; getItems() { return items; } public void setItems(List\u0026lt;String\u0026gt; items) { this.items = items; } } @Test void propertySettingAfterConstructor() { PartiallyInitializedObject obj = fixtureMonkey.giveMeBuilder(PartiallyInitializedObject.class) .instantiate(constructor().parameter(String.class)) .sample(); assertThat(obj.getName()).isNotNull(); // Initialized in constructor assertThat(obj.getCount()).isNotZero(); // Initialized after constructor assertThat(obj.getItems()).isNotNull(); // Initialized after constructor } class PartiallyInitializedObject( val name: String // Initialized in constructor ) { var count: Int = 0 // Not initialized in constructor var items: List\u0026lt;String\u0026gt;? = null // Not initialized in constructor } @Test fun propertySettingAfterConstructor() { val obj = fixtureMonkey.giveMeBuilder\u0026lt;PartiallyInitializedObject\u0026gt;() .instantiateBy { constructor\u0026lt;PartiallyInitializedObject\u0026gt; { parameter\u0026lt;String\u0026gt;() } } .sample() assertThat(obj.name).isNotNull() // Initialized in constructor assertThat(obj.count).isNotZero() // Initialized after constructor assertThat(obj.items).isNotNull() // Initialized after constructor } 4.2.1 Caution # There\u0026rsquo;s one important caution when using this feature:
âš ï¸ Fixture Monkey may also **modify property values that were already set in the constructor**. This could lead to unexpected test results. Problem scenario:
Set name = \u0026quot;specificName\u0026quot; in constructor Fixture Monkey automatically assigns random value to name after object creation name changes from \u0026ldquo;specificName\u0026rdquo; to some other value Solution: You can solve this problem by explicitly setting important values:
Java Kotlin @Test void preservingConstructorSetValues() { String specificName = \u0026#34;specificName\u0026#34;; PartiallyInitializedObject obj = fixtureMonkey.giveMeBuilder(PartiallyInitializedObject.class) .instantiate( constructor() .parameter(String.class, \u0026#34;name\u0026#34;) ) .set(\u0026#34;name\u0026#34;, specificName) // Explicitly set constructor parameter value .sample(); assertThat(obj.getName()).isEqualTo(specificName); // Explicitly set value is preserved } @Test fun preservingConstructorSetValues() { val specificName = \u0026#34;specificName\u0026#34; val obj = fixtureMonkey.giveMeBuilder\u0026lt;PartiallyInitializedObject\u0026gt;() .instantiateBy { constructor\u0026lt;PartiallyInitializedObject\u0026gt; { parameter\u0026lt;String\u0026gt;(\u0026#34;name\u0026#34;) } } .set(\u0026#34;name\u0026#34;, specificName) // Explicitly set constructor parameter value .sample() assertThat(obj.name).isEqualTo(specificName) // Explicitly set value is preserved } ðŸ’¡ Beginner tip: Always explicitly set important values using the \`.set()\` method to ensure predictable test results! Frequently Asked Questions (FAQ) # Q: What\u0026rsquo;s the difference between instantiate and introspectors? # A: Introspectors are global settings applied to all object creation, while instantiate is a local setting applied only to specific tests or objects.
Simply put:
Introspector: \u0026ldquo;Create all objects this way for all tests\u0026rdquo; instantiate: \u0026ldquo;Create objects this way only for this specific test\u0026rdquo; In most cases, introspectors are sufficient, but use instantiate when you need special creation logic.
Q: How do I decide which constructor to choose among multiple options? # A: Choose the constructor that best fits your test purpose. Generally:
Simple tests: Use constructors with fewer arguments Testing specific fields: Choose constructors that initialize the fields you\u0026rsquo;re focusing on Testing validation logic: Use constructors with validation or special initialization logic Q: What are the benefits of parameter name hints? # A: Parameter name hints allow you to:
Assign meaningful names to constructor or factory method parameters Easily set specific parameter values using the set() method Improve code readability // Without parameter name hints .instantiate(constructor().parameter(String.class)) .set(\u0026quot;__ANONYMOUS_0\u0026quot;, \u0026quot;value\u0026quot;) // Hard to understand which parameter this is // With parameter name hints .instantiate(constructor().parameter(String.class, \u0026quot;name\u0026quot;)) .set(\u0026quot;name\u0026quot;, \u0026quot;John\u0026quot;) // Clearly indicates which parameter Q: Which should I use: field() or javaBeansProperty()? # A:
field(): Suitable for classes where fields need to be accessed directly or setter methods aren\u0026rsquo;t available javaBeansProperty(): Suitable for classes where setter methods include validation or special processing If unsure, use the default (don\u0026rsquo;t specify). Fixture Monkey will choose an appropriate method. Q: How do I specify generic type parameters? # A: Generic types are specified using TypeReference:
// Java .parameter(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;(){}) // Kotlin parameter\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() Q: How do I prevent values set in the constructor from being changed? # A: Use the .set() method to explicitly set important values:
fixtureMonkey.giveMeBuilder(MyClass.class) .instantiate(constructor().parameter(String.class, \u0026quot;name\u0026quot;)) .set(\u0026quot;name\u0026quot;, \u0026quot;importantValue\u0026quot;) // This value won't be changed .sample(); Summary # ðŸ“Œ Key Points Summary The instantiate() method provides fine-grained control over object creation methods You can choose between constructors and factory methods as the two main object creation approaches Parameter name hints allow you to set specific values for constructor or factory method parameters field() and javaBeansProperty() control how property values are generated In most cases, introspector settings are sufficient, and instantiate is only needed for special cases By properly utilizing these features, you can create even complex objects accurately for your testing purposes.
Next Steps # To learn more about test data generation:
Introspector: How to set object creation methods globally Fixture Monkey: Basic usage of Fixture Monkey Generating Complex Types: How to generate complex object structures `}),e.add({id:15,href:"/v1-1-0/docs/generating-objects/generating-interface/",title:"Generating Interface Types",description:`Why Generate Interface Types? # When writing tests, you often need to work with interfaces rather than concrete implementations:
You may be testing code that accepts interfaces as parameters Your system under test may return interface types You want to test behavior without coupling to specific implementations Fixture Monkey makes it easy to generate test objects for interfaces - whether they\u0026rsquo;re simple interfaces, generic interfaces, or sealed interfaces.
Quick Start Example # Here\u0026rsquo;s a simple example to get started with interface generation:`,content:`Why Generate Interface Types? # When writing tests, you often need to work with interfaces rather than concrete implementations:
You may be testing code that accepts interfaces as parameters Your system under test may return interface types You want to test behavior without coupling to specific implementations Fixture Monkey makes it easy to generate test objects for interfaces - whether they\u0026rsquo;re simple interfaces, generic interfaces, or sealed interfaces.
Quick Start Example # Here\u0026rsquo;s a simple example to get started with interface generation:
// Define an interface you want to test with public interface StringSupplier { String getValue(); } // Create a Fixture Monkey instance FixtureMonkey fixture = FixtureMonkey.create(); // Generate an instance of the interface StringSupplier supplier = fixture.giveMeOne(StringSupplier.class); // Use it in your test String value = supplier.getValue(); assertThat(value).isNotNull(); // Will pass This example generates an anonymous implementation of the StringSupplier interface that you can use in your tests. Let\u0026rsquo;s explore more options for interface generation.
Interface Generation Approaches # Fixture Monkey provides three main approaches for generating interface instances:
Approach Description Best For Anonymous implementation Fixture Monkey creates an anonymous class Quick tests, simple interfaces Specific implementation You specify which class to use More control, realistic behavior Built-in implementations Fixture Monkey provides defaults for common interfaces Standard Java interfaces Examples for Each Approach # // Anonymous implementation StringSupplier supplier = fixture.giveMeOne(StringSupplier.class); // Specific implementation InterfacePlugin plugin = new InterfacePlugin() .interfaceImplements(StringSupplier.class, List.of(DefaultStringSupplier.class)); // Built-in implementation List\u0026lt;String\u0026gt; list = fixture.giveMeOne(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {}); Common Interface Types with Built-in Support # Fixture Monkey provides default implementations for common Java interfaces:
List â†’ ArrayList Set â†’ HashSet Map â†’ HashMap Queue â†’ LinkedList And more\u0026hellip; You don\u0026rsquo;t need to configure anything special to use these.
Detailed Examples # Simple Interface # Let\u0026rsquo;s start with a simple interface example:
// The interface we want to generate public interface StringSupplier { String getValue(); } // A concrete implementation we might want to use public class DefaultStringSupplier implements StringSupplier { private final String value; @ConstructorProperties(\u0026quot;value\u0026quot;) // It is not needed if you are using Lombok. public DefaultStringSupplier(String value) { this.value = value; } @Override public String getValue() { return \u0026quot;default\u0026quot; + value; } } Approach 1: Anonymous Implementation (No Options) # The simplest approach is to let Fixture Monkey generate an anonymous implementation:
@Test void testWithAnonymousImplementation() { // Setup FixtureMonkey fixture = FixtureMonkey.create(); // Generate an anonymous implementation StringSupplier result = fixture.giveMeOne(StringSupplier.class); // Test assertThat(result.getValue()).isNotNull(); assertThat(result).isNotInstanceOf(DefaultStringSupplier.class); } With this approach, Fixture Monkey creates an anonymous object that implements the StringSupplier interface. The getValue() method returns a randomly generated String.
ðŸ’¡ Fixture Monkey only generates property values for methods that:
Follow the naming convention of getters (like getValue(), getName(), etc.) Have no parameters Other methods will always return null or default primitive values.
You can customize the generated properties using the same API as for regular classes:
@Test void testWithCustomizedProperties() { // Setup FixtureMonkey fixture = FixtureMonkey.create(); // Generate with a specific property value StringSupplier result = fixture.giveMeBuilder(StringSupplier.class) .set(\u0026quot;value\u0026quot;, \u0026quot;customValue\u0026quot;) .sample(); // Test assertThat(result.getValue()).isEqualTo(\u0026quot;customValue\u0026quot;); } Approach 2: Using a Specific Implementation # When you need more realistic behavior, you can tell Fixture Monkey to use your concrete implementation:
@Test void testWithSpecificImplementation() { // Setup Fixture Monkey with a specific implementation FixtureMonkey fixture = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) // needed for DefaultStringSupplier's constructor .plugin( new InterfacePlugin() .interfaceImplements(StringSupplier.class, List.of(DefaultStringSupplier.class)) ) .build(); // Generate the interface StringSupplier result = fixture.giveMeOne(StringSupplier.class); // Test assertThat(result).isInstanceOf(DefaultStringSupplier.class); assertThat(result.getValue()).startsWith(\u0026quot;default\u0026quot;); } This approach generates a real DefaultStringSupplier instance with the behavior defined in your implementation.
Generic Interface # For generic interfaces, the approach varies depending on whether you specify type parameters:
1. Without Type Parameters # When you create a generic interface without specifying type parameters, Fixture Monkey defaults to using String type:
// Generic interface public interface ObjectValueSupplier\u0026lt;T\u0026gt; { T getValue(); } @Test void testGenericInterfaceWithoutTypeParameters() { FixtureMonkey fixture = FixtureMonkey.create(); // Create without specifying type parameter ObjectValueSupplier\u0026lt;?\u0026gt; result = fixture.giveMeOne(ObjectValueSupplier.class); // String type is used by default assertThat(result.getValue()).isInstanceOf(String.class); } 2. With Explicit Type Parameters # You can explicitly specify the type parameter using TypeReference:
@Test void testGenericInterfaceWithTypeParameters() { FixtureMonkey fixture = FixtureMonkey.create(); // Specify Integer as the type parameter ObjectValueSupplier\u0026lt;Integer\u0026gt; result = fixture.giveMeOne(new TypeReference\u0026lt;ObjectValueSupplier\u0026lt;Integer\u0026gt;\u0026gt;() {}); // Integer type is used assertThat(result.getValue()).isInstanceOf(Integer.class); } 3. Using a Specific Implementation # When using a specific implementation, it follows the type parameters of that implementation:
// Concrete implementation for String public class StringValueSupplier implements ObjectValueSupplier\u0026lt;String\u0026gt; { private final String value; @ConstructorProperties(\u0026quot;value\u0026quot;) public StringValueSupplier(String value) { this.value = value; } @Override public String getValue() { return value; } } @Test void testGenericInterfaceWithSpecificImplementation() { // Setup with specific implementation FixtureMonkey fixture = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .plugin( new InterfacePlugin() .interfaceImplements(ObjectValueSupplier.class, List.of(StringValueSupplier.class)) ) .build(); // Generate the interface ObjectValueSupplier\u0026lt;?\u0026gt; result = fixture.giveMeOne(ObjectValueSupplier.class); // Test assertThat(result).isInstanceOf(StringValueSupplier.class); assertThat(result.getValue()).isInstanceOf(String.class); } ðŸ’¡ When generating a generic interface without type parameters, Fixture Monkey uses String as the default type. If you need a different type, use TypeReference or specify a concrete implementation. Sealed Interface (Java 17+) # Java 17 introduced sealed interfaces, which explicitly define their permitted implementations. Fixture Monkey automatically handles these without additional configuration:
// Sealed interface with permitted implementations sealed interface SealedStringSupplier { String getValue(); } // Permitted implementation public static final class SealedDefaultStringSupplier implements SealedStringSupplier { private final String value; @ConstructorProperties(\u0026quot;value\u0026quot;) public SealedDefaultStringSupplier(String value) { this.value = value; } @Override public String getValue() { return \u0026quot;sealed\u0026quot; + value; } } @Test void testSealedInterface() { // Setup FixtureMonkey fixture = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build(); // Generate sealed interface SealedStringSupplier result = fixture.giveMeOne(SealedStringSupplier.class); // Test assertThat(result).isInstanceOf(SealedDefaultStringSupplier.class); assertThat(result.getValue()).startsWith(\u0026quot;sealed\u0026quot;); } Combining with Other Interfaces # You can also specify which implementation to use for certain interfaces. For example, using LinkedList instead of the default ArrayList for List:
@Test void testCustomListImplementation() { // Setup FixtureMonkey fixture = FixtureMonkey.builder() .plugin( new InterfacePlugin() .interfaceImplements(List.class, List.of(LinkedList.class)) ) .build(); // Generate List\u0026lt;String\u0026gt; list = fixture.giveMeOne(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {}); // Test assertThat(list).isInstanceOf(LinkedList.class); } Interface Inheritance # Fixture Monkey can also handle interface inheritance. You can specify implementations at any level of the hierarchy:
interface ObjectValueSupplier { Object getValue(); } interface StringValueSupplier extends ObjectValueSupplier { String getValue(); } @Test void testInterfaceHierarchy() { // Setup FixtureMonkey fixture = FixtureMonkey.builder() .plugin( new InterfacePlugin() .interfaceImplements(Collection.class, List.of(List.class)) ) .build(); // Generate a Collection, which will use a List implementation Collection\u0026lt;String\u0026gt; collection = fixture.giveMeOne(new TypeReference\u0026lt;Collection\u0026lt;String\u0026gt;\u0026gt;() {}); // Test assertThat(collection).isInstanceOf(List.class); } Advanced Features # For more complex scenarios, Fixture Monkey provides advanced options for interface implementation resolution.
Dynamic Implementation Resolution # If you have many implementations or need to select implementations based on type conditions:
FixtureMonkey fixture = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .plugin( new InterfacePlugin() .interfaceImplements( new AssignableTypeMatcher(ObjectValueSupplier.class), property -\u0026gt; { Class\u0026lt;?\u0026gt; actualType = Types.getActualType(property.getType()); if (StringValueSupplier.class.isAssignableFrom(actualType)) { return List.of(PropertyUtils.toProperty(DefaultStringValueSupplier.class)); } if (IntegerValueSupplier.class.isAssignableFrom(actualType)) { return List.of(PropertyUtils.toProperty(DefaultIntegerValueSupplier.class)); } return List.of(); } ) ) .build(); âš ï¸ This section describes advanced features that most beginners won\u0026rsquo;t need initially. Feel free to revisit this when you need more complex interface generation strategies. Custom Resolution Implementation # For the most advanced scenarios, you can implement the CandidateConcretePropertyResolver interface:
class YourCustomCandidateConcretePropertyResolver implements CandidateConcretePropertyResolver { @Override public List\u0026lt;Property\u0026gt; resolveCandidateConcreteProperties(Property property) { // Your custom logic to resolve implementations return List.of(...); } } You can use the built-in ConcreteTypeCandidateConcretePropertyResolver to help with type conversion:
FixtureMonkey fixture = FixtureMonkey.builder() .plugin(new InterfacePlugin() .interfaceImplements( new ExactTypeMatcher(Collection.class), new ConcreteTypeCandidateConcretePropertyResolver\u0026lt;\u0026gt;(List.of(List.class, Set.class)) ) ) .build(); ðŸ’¡ When setting type conditions for option application, be careful with matchers like AssignableTypeMatcher. Using it incorrectly can cause infinite recursion if implementations also match the condition. Summary # Here\u0026rsquo;s a quick summary of how to generate interface types with Fixture Monkey:
Simple cases: Just use fixture.giveMeOne(YourInterface.class) to get an anonymous implementation
Specific implementation: Use the InterfacePlugin with interfaceImplements:
new InterfacePlugin().interfaceImplements(YourInterface.class, List.of(YourImplementation.class)) Built-in implementations: Common interfaces like List, Set, etc. are handled automatically
Sealed interfaces: No special configuration needed - Fixture Monkey uses the permitted implementations
Complex cases: Use AssignableTypeMatcher or implement CandidateConcretePropertyResolver for advanced scenarios
Remember that for most testing scenarios, the simpler approaches will be sufficient. The advanced features are there when you need more control over the generated implementations.
`}),e.add({id:16,href:"/v1-1-0/docs/generating-objects/introspector/",title:"Introspector",description:`What is an Introspector? # An Introspector in Fixture Monkey is simply a tool that determines how test objects are created. Think of it as a \u0026ldquo;factory\u0026rdquo; that figures out the best way to create objects for your tests.
For example, it decides:
Whether to use a constructor or a builder to create objects How to set values for fields How to handle different types of classes in your codebase Quick Start: Recommended Setup for Most Projects # If you\u0026rsquo;re new to Fixture Monkey and want to get started quickly, here\u0026rsquo;s the setup that works for most projects:`,content:`What is an Introspector? # An Introspector in Fixture Monkey is simply a tool that determines how test objects are created. Think of it as a \u0026ldquo;factory\u0026rdquo; that figures out the best way to create objects for your tests.
For example, it decides:
Whether to use a constructor or a builder to create objects How to set values for fields How to handle different types of classes in your codebase Quick Start: Recommended Setup for Most Projects # If you\u0026rsquo;re new to Fixture Monkey and want to get started quickly, here\u0026rsquo;s the setup that works for most projects:
// Recommended setup that handles most class types FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(new FailoverIntrospector( Arrays.asList( ConstructorPropertiesArbitraryIntrospector.INSTANCE, BuilderArbitraryIntrospector.INSTANCE, FieldReflectionArbitraryIntrospector.INSTANCE, BeanArbitraryIntrospector.INSTANCE ), false // Disable logging for cleaner test output )) .build(); // Use it in your tests @Test void testExample() { // Generate a test object MyClass myObject = fixtureMonkey.giveMeOne(MyClass.class); // Use the generated object in your test assertThat(myObject).isNotNull(); // more assertions... } This setup combines multiple strategies to handle different class types, so it works well for most real-world projects without additional configuration.
Simplest Approach (If You Just Want Basic Setup) # If you prefer the simplest possible setup, you can use the default configuration:
// Simplest approach with default settings FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .build(); // Generate a test object MyClass myObject = fixtureMonkey.giveMeOne(MyClass.class); However, this basic approach only works well with simple JavaBean classes that have a no-arguments constructor and setter methods.
Choosing the Right Introspector for Your Classes # Different class types require different approaches to object creation. Here\u0026rsquo;s a simple guide to help you choose:
Class Type Recommended Introspector Example Classes with setters (JavaBeans) BeanArbitraryIntrospector Classes with getters/setters Immutable classes with constructors ConstructorPropertiesArbitraryIntrospector Records, classes with annotated constructors Classes with mixed field access FieldReflectionArbitraryIntrospector Classes with public fields, no-args constructor Classes using builder pattern BuilderArbitraryIntrospector Classes with .builder() method Mixed codebase with different patterns FailoverArbitraryIntrospector Projects with various class types Examples for Common Class Types # Example 1: Standard JavaBean Class (with getters/setters) # // Class definition public class Customer { private String name; private int age; // No-args constructor public Customer() {} // Setters public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } // Getters public String getName() { return name; } public int getAge() { return age; } } // Test code @Test void testCustomer() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(BeanArbitraryIntrospector.INSTANCE) // Default, so optional .build(); Customer customer = fixtureMonkey.giveMeOne(Customer.class); assertThat(customer.getName()).isNotNull(); assertThat(customer.getAge()).isGreaterThanOrEqualTo(0); } Example 2: Immutable Class with Constructor # // Class definition (with @ConstructorProperties) public class Product { private final String name; private final double price; @ConstructorProperties({\u0026quot;name\u0026quot;, \u0026quot;price\u0026quot;}) public Product(String name, double price) { this.name = name; this.price = price; } public String getName() { return name; } public double getPrice() { return price; } } // Test code @Test void testProduct() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build(); Product product = fixtureMonkey.giveMeOne(Product.class); assertThat(product.getName()).isNotNull(); assertThat(product.getPrice()).isGreaterThanOrEqualTo(0.0); } // Works with Java records too public record OrderItem(String productId, int quantity, double price) {} Example 3: Class with Builder Pattern # // Class definition with builder public class User { private final String username; private final String email; private User(Builder builder) { this.username = builder.username; this.email = builder.email; } public static Builder builder() { return new Builder(); } public static class Builder { private String username; private String email; public Builder username(String username) { this.username = username; return this; } public Builder email(String email) { this.email = email; return this; } public User build() { return new User(this); } } public String getUsername() { return username; } public String getEmail() { return email; } } // Test code @Test void testUser() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(BuilderArbitraryIntrospector.INSTANCE) .build(); User user = fixtureMonkey.giveMeOne(User.class); assertThat(user.getUsername()).isNotNull(); assertThat(user.getEmail()).isNotNull(); } Why Introspectors Matter # Different projects use different patterns for object creation:
Some use simple classes with getters/setters Others use immutable objects with constructors Some follow the builder pattern Frameworks like Lombok generate code in specific ways By choosing the right introspector, you can make Fixture Monkey work with your existing code without modifications, saving you time and effort.
Frequently Asked Questions (FAQ) # Q: I\u0026rsquo;m not sure which introspector to use. What should I do? # A: Start with the recommended setup (using FailoverIntrospector with multiple introspectors). It works for most projects and automatically tries different strategies.
FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(new FailoverIntrospector( Arrays.asList( ConstructorPropertiesArbitraryIntrospector.INSTANCE, BuilderArbitraryIntrospector.INSTANCE, FieldReflectionArbitraryIntrospector.INSTANCE, BeanArbitraryIntrospector.INSTANCE ), false // Disable logging for cleaner test output )) .build(); Q: My objects aren\u0026rsquo;t being generated. What should I check? # A: Ensure your class has one of the following:
A no-args constructor with setters (for BeanArbitraryIntrospector) A constructor with @ConstructorProperties (for ConstructorPropertiesArbitraryIntrospector) A builder method (for BuilderArbitraryIntrospector) Q: I\u0026rsquo;m using Lombok and my objects aren\u0026rsquo;t generating properly. What should I do? # A: Add lombok.anyConstructor.addConstructorProperties=true to your lombok.config file and use ConstructorPropertiesArbitraryIntrospector.
Q: What if I need custom creation logic for a specific class? # A: For specific cases, you can use the instantiate method to specify how an instance should be created:
MySpecialClass object = fixtureMonkey.giveMeBuilder(MySpecialClass.class) .instantiate(() -\u0026gt; new MySpecialClass(specialParam1, specialParam2)) .sample(); For more advanced custom logic, see the Custom Introspector guide, but most users won\u0026rsquo;t need this.
Available Introspectors (More Details) # BeanArbitraryIntrospector (Default) # Best for: Standard JavaBean classes with setters
Requirements:
Class must have a no-args constructor Class must have setter methods for properties FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(BeanArbitraryIntrospector.INSTANCE) // This is the default .build(); ConstructorPropertiesArbitraryIntrospector # Best for: Immutable objects with constructors
Requirements:
Class must have a constructor with @ConstructorProperties or be a record type For Lombok, add lombok.anyConstructor.addConstructorProperties=true to lombok.config FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build(); FieldReflectionArbitraryIntrospector # Best for: Classes with field access
Requirements:
Class must have a no-args constructor Fields can be accessed via reflection FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(FieldReflectionArbitraryIntrospector.INSTANCE) .build(); BuilderArbitraryIntrospector # Best for: Classes using the builder pattern
Requirements:
Class must have a builder with set methods and a build method FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(BuilderArbitraryIntrospector.INSTANCE) .build(); FailoverArbitraryIntrospector (Recommended for Mixed Codebases) # Best for: Projects with a mix of class types
Benefits:
Tries multiple introspectors in sequence Works with various class patterns Most versatile option FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(new FailoverIntrospector( Arrays.asList( ConstructorPropertiesArbitraryIntrospector.INSTANCE, BuilderArbitraryIntrospector.INSTANCE, FieldReflectionArbitraryIntrospector.INSTANCE, BeanArbitraryIntrospector.INSTANCE ), false // Disable logging for cleaner test output )) .build(); If you want to disable the fail log, set the constructor argument enableLoggingFail to false as shown above.
âš ï¸ Performance note: \`FailoverArbitraryIntrospector\` may increase generation costs as it attempts to create objects using each registered introspector in sequence. When performance is a concern, use a specific introspector if you know your class patterns. PriorityConstructorArbitraryIntrospector # Best for: Special cases where other introspectors don\u0026rsquo;t work
Benefits:
Uses available constructors even without @ConstructorProperties Helpful for library classes you can\u0026rsquo;t modify FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(PriorityConstructorArbitraryIntrospector.INSTANCE) .build(); Additional Introspectors from Plugins # Plugins provide additional introspectors for specific needs:
JacksonObjectArbitraryIntrospector for Jackson JSON objects PrimaryConstructorArbitraryIntrospector for Kotlin classes How Introspectors Work (Technical Details) # graph TD A[Object Creation Request] --\u0026gt; B{Introspector Selection} B -- BeanArbitraryIntrospector --\u0026gt; C[Use Default Constructor \u0026#43; Setters] B -- ConstructorProperties --\u0026gt; D[Use Annotated Constructor] B -- FieldReflection --\u0026gt; E[Set Fields with Reflection] B -- Builder --\u0026gt; F[Use Builder Pattern] B -- Failover --\u0026gt; G[Try Multiple Introspectors Sequentially] C --\u0026gt; H[Object Instance] D --\u0026gt; H E --\u0026gt; H F --\u0026gt; H G --\u0026gt; H Need More Advanced Customization? # If you have special requirements for object creation that aren\u0026rsquo;t covered by the built-in introspectors, you might need to create a custom introspector.
This is an advanced topic and most users won\u0026rsquo;t need it. If you\u0026rsquo;re interested, see the Custom Introspector guide.
`}),e.add({id:17,href:"/v1-1-0/docs/generating-objects/custom-introspector/",title:"Creating Custom Introspector",description:`Note: This guide is for advanced users who already understand Fixture Monkey basics. Most users won\u0026rsquo;t need to create custom introspectors as the built-in ones handle common scenarios. If you\u0026rsquo;re just getting started, check the Introspector guide first.
When Would You Need a Custom Introspector? # You might need to create a custom introspector in these specific situations:
Your classes have unique creation requirements that built-in introspectors can\u0026rsquo;t handle You\u0026rsquo;re working with third-party libraries that follow unconventional patterns Your objects need special initialization logic that can\u0026rsquo;t be addressed with the instantiate method If none of these apply to you, the built-in introspectors will likely be sufficient.`,content:` Note: This guide is for advanced users who already understand Fixture Monkey basics. Most users won\u0026rsquo;t need to create custom introspectors as the built-in ones handle common scenarios. If you\u0026rsquo;re just getting started, check the Introspector guide first.
When Would You Need a Custom Introspector? # You might need to create a custom introspector in these specific situations:
Your classes have unique creation requirements that built-in introspectors can\u0026rsquo;t handle You\u0026rsquo;re working with third-party libraries that follow unconventional patterns Your objects need special initialization logic that can\u0026rsquo;t be addressed with the instantiate method If none of these apply to you, the built-in introspectors will likely be sufficient.
Basic Approaches # There are two main ways to create custom introspectors:
1. Assembling Objects from Properties # This approach is useful when you need to manually construct objects using their properties:
// Example custom introspector that handles a specific class type public class CustomArbitraryIntrospector implements ArbitraryIntrospector { @Override public ArbitraryIntrospectorResult introspect(ArbitraryGeneratorContext context) { // Step 1: Check if this introspector should handle this type Property property = context.getResolvedProperty(); Class\u0026lt;?\u0026gt; type = Types.getActualType(property.getType()); if (!MyCustomClass.class.isAssignableFrom(type)) { // If not our target type, let other introspectors handle it return ArbitraryIntrospectorResult.NOT_INTROSPECTED; } // Step 2: Get the properties Fixture Monkey generated for this object Map\u0026lt;ArbitraryProperty, CombinableArbitrary\u0026lt;?\u0026gt;\u0026gt; arbitrariesByProperty = context.getCombinableArbitrariesByArbitraryProperty(); // Step 3: Build the object using these properties CombinableArbitrary\u0026lt;MyCustomClass\u0026gt; combinableArbitrary = CombinableArbitrary.objectBuilder() .properties(arbitrariesByProperty) .build(propertyValues -\u0026gt; { // Create a new instance of our class MyCustomClass obj = new MyCustomClass(); // Set each property value propertyValues.forEach((property, value) -\u0026gt; { String propertyName = property.getName(); if (\u0026quot;name\u0026quot;.equals(propertyName)) { obj.setName((String) value); } else if (\u0026quot;value\u0026quot;.equals(propertyName)) { obj.setValue((Integer) value); } }); return obj; }); // Step 4: Return the result return new ArbitraryIntrospectorResult(combinableArbitrary); } } 1.1 Defining Required Properties # Sometimes you need to customize how child properties are discovered and generated:
// Override this method to control property generation for specific properties @Override @Nullable public PropertyGenerator getRequiredPropertyGenerator(Property property) { // Check if this property needs special handling if (\u0026quot;nestedObject\u0026quot;.equals(property.getName())) { // Create a generator that only includes specific fields return new FieldPropertyGenerator( // Only include id and name fields field -\u0026gt; \u0026quot;id\u0026quot;.equals(field.getName()) || \u0026quot;name\u0026quot;.equals(field.getName()), // Match all fields that pass the filter field -\u0026gt; true ); } // For other properties, use the default generator return null; } 2. Returning Fixed Instances # Sometimes you just need to return a constant or specially calculated value:
// Example introspector that returns a fixed value for a specific type public class ConstantArbitraryIntrospector implements ArbitraryIntrospector { private final Object constantValue; public ConstantArbitraryIntrospector(Object constantValue) { this.constantValue = constantValue; } @Override public ArbitraryIntrospectorResult introspect(ArbitraryGeneratorContext context) { Property property = context.getResolvedProperty(); Class\u0026lt;?\u0026gt; type = Types.getActualType(property.getType()); // Make sure our constant is the right type if (!type.isInstance(constantValue)) { return ArbitraryIntrospectorResult.NOT_INTROSPECTED; } // Return our constant value return new ArbitraryIntrospectorResult( CombinableArbitrary.from(constantValue) ); } } Using Your Custom Introspector # After creating your introspector, you can use it in two ways:
As the Global Introspector # Standalone Usage # // Create your custom introspector ArbitraryIntrospector customIntrospector = new CustomArbitraryIntrospector(); // Use it as the global introspector FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(customIntrospector) .build(); // Generate objects MyCustomClass obj = fixtureMonkey.giveMeOne(MyCustomClass.class); Combined with Other Introspectors # Usually, you\u0026rsquo;ll want to combine your custom introspector with the built-in ones:
// Create a Fixture Monkey that tries your introspector first, // then falls back to the standard ones if yours doesn't apply FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(new FailoverIntrospector( Arrays.asList( customIntrospector, // Try your custom one first ConstructorPropertiesArbitraryIntrospector.INSTANCE, BuilderArbitraryIntrospector.INSTANCE, FieldReflectionArbitraryIntrospector.INSTANCE, BeanArbitraryIntrospector.INSTANCE ) )) .build(); As a Type-Specific Introspector # // Use customIntrospector only for MyCustomClass FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .pushArbitraryIntrospector( new MatcherOperator\u0026lt;\u0026gt;( new ExactTypeMatcher(MyCustomClass.class), customIntrospector ) ) .build(); For more information on various ArbitraryIntrospector configuration options, see Custom Introspection Settings.
Best Practices # When creating custom introspectors:
Always check the type before processing, returning NOT_INTROSPECTED for types your introspector doesn\u0026rsquo;t handle Handle exceptions gracefully to prevent test failures Keep it focused - each introspector should handle a specific pattern or class type Consider performance since introspectors run for every object creation Test thoroughly with various edge cases Real-world Example: Class Range # // External library - Class Range\u0026lt;C\u0026gt; using Instant as generic type public class RangeInstantArbitraryIntrospector implements ArbitraryIntrospector { @Override public ArbitraryIntrospectorResult introspect(ArbitraryGeneratorContext context) { Property property = context.getResolvedProperty(); Class\u0026lt;?\u0026gt; type = Types.getActualType(property.getType()); List\u0026lt;AnnotatedType\u0026gt; typeArguments = Types.getGenericsTypes(property.getAnnotatedType()); Class\u0026lt;?\u0026gt; genericType = typeArguments.isEmpty() ? null : Types.getActualType(typeArguments.getFirst()); if (!type.equals(Range.class) || typeArguments.size() != 1 || !genericType.equals(Instant.class)) { return ArbitraryIntrospectorResult.NOT_INTROSPECTED; } // ===== Random generation example ===== int randomInt = (int)(Math.random() * 365) + 1; Instant startTime = Instant.now().minus(randomInt, ChronoUnit.DAYS); Instant endTime = Instant.now().plus(randomInt, ChronoUnit.DAYS); Range\u0026lt;Instant\u0026gt; rangeValue = Range.closed(startTime, endTime); return new ArbitraryIntrospectorResult( CombinableArbitrary.from(rangeValue) ); } } Real-world Example: Class InetAddress # You can also handle class type matching in .pushArbitraryIntrospector() instead of inside the introspector.
// Class java.net.InetAddress public class InetAddressArbitraryIntrospector implements ArbitraryIntrospector { @Override public ArbitraryIntrospectorResult introspect(ArbitraryGeneratorContext context) { Property property = context.getResolvedProperty(); Class\u0026lt;?\u0026gt; type = Types.getActualType(property.getType()); InetAddress inetAddress; if (type.equals(Inet4Address.class)){ inetAddress = generateRandomInet4Address(); } else { inetAddress = generateRandomInet6Address(); } return new ArbitraryIntrospectorResult( CombinableArbitrary.from(inetAddress) ); } private Inet4Address generateRandomInet4Address() { // Implement random generation logic } private Inet6Address generateRandomInet6Address() { // Implement random generation logic } } ArbitraryIntrospector inetAddressArbitraryIntrospector = new InetAddressArbitraryIntrospector(); // Use InetAddressArbitraryIntrospector only for InetAddress and its subclasses FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .pushArbitraryIntrospector( new MatcherOperator\u0026lt;\u0026gt;( new AssignableTypeMatcher(InetAddress.class), inetAddressArbitraryIntrospector ) ) // ... .build(); Advanced: Property Generators # Fixture Monkey provides several built-in PropertyGenerator implementations that can help with custom property discovery:
FieldPropertyGenerator # Useful for creating properties based on class fields:
// Generate properties based on fields with specific conditions new FieldPropertyGenerator( // Only non-final fields with a specific annotation field -\u0026gt; !Modifier.isFinal(field.getModifiers()) \u0026amp;\u0026amp; field.isAnnotationPresent(MyRequired.class), // Include all fields that pass the filter field -\u0026gt; true ) CompositePropertyGenerator # Combines multiple property generators:
// Use both field and JavaBeans property generation together new CompositePropertyGenerator( Arrays.asList( new FieldPropertyGenerator(field -\u0026gt; true, matcher -\u0026gt; true), new JavaBeansPropertyGenerator( descriptor -\u0026gt; descriptor.getReadMethod() != null, matcher -\u0026gt; true ) ) ) DefaultPropertyGenerator # A pre-configured combination of common generators:
// Uses standard field and JavaBeans property generation new DefaultPropertyGenerator() Conclusion # Creating custom introspectors is an advanced topic, but it gives you complete control over object creation in Fixture Monkey. Most users won\u0026rsquo;t need this level of customization, but it\u0026rsquo;s available when you have special requirements that the built-in introspectors can\u0026rsquo;t handle.
If you have any questions about custom introspectors, refer to the source code of the built-in introspectors for examples of different implementation approaches.
`}),e.add({id:18,href:"/v1-1-0/docs/customizing-objects/",title:"Customizing Objects",description:"",content:""}),e.add({id:19,href:"/v1-1-0/docs/plugins/interface-plugin/",title:"Interface Plugin",description:"",content:""}),e.add({id:20,href:"/v1-1-0/docs/customizing-objects/quick-start-guide/",title:"Quick Start Guide",description:`What You\u0026rsquo;ll Learn # Core methods for customizing test objects with Fixture Monkey Basic approaches to customize simple and complex objects Solutions to the most common problems beginners face 5-Minute Quick Start # This section covers only the essential information needed to get started with Fixture Monkey.
4 Key Methods You Must Know # If you\u0026rsquo;re short on time, here\u0026rsquo;s what you need to know right now:
Java Kotlin // 1.`,content:`What You\u0026rsquo;ll Learn # Core methods for customizing test objects with Fixture Monkey Basic approaches to customize simple and complex objects Solutions to the most common problems beginners face 5-Minute Quick Start # This section covers only the essential information needed to get started with Fixture Monkey.
4 Key Methods You Must Know # If you\u0026rsquo;re short on time, here\u0026rsquo;s what you need to know right now:
Java Kotlin // 1. Create FixtureMonkey instance FixtureMonkey fixtureMonkey = FixtureMonkey.create(); // 2. Create a product with specific property values Product product = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026#34;name\u0026#34;, \u0026#34;Smartphone\u0026#34;) // Set property .set(\u0026#34;price\u0026#34;, new BigDecimal(499)) // Set another property .sample(); // Create the actual object // 3. Create an order with a list of products Order order = fixtureMonkey.giveMeBuilder(Order.class) .size(\u0026#34;products\u0026#34;, 2) // Set list size to 2 .set(\u0026#34;products[0].name\u0026#34;, \u0026#34;Laptop\u0026#34;) // Customize list element .sample(); // 1. Create FixtureMonkey instance val fixtureMonkey = FixtureMonkey.create() // 2. Create a product with specific property values val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setExp(Product::name, \u0026#34;Smartphone\u0026#34;) // Set property .setExp(Product::price, BigDecimal(499)) // Set another property .sample() // Create the actual object // 3. Create an order with a list of products val order = fixtureMonkey.giveMeBuilder\u0026lt;Order\u0026gt;() .sizeExp(Order::products, 2) // Set list size to 2 .set(\u0026#34;products[0].name\u0026#34;, \u0026#34;Laptop\u0026#34;) // Customize list element .sample() Visual Overview # Here\u0026rsquo;s a simple flowchart showing the process of customizing objects with Fixture Monkey:
flowchart LR A[Create FixtureMonkey] --\u0026gt; B[Get Builder] B --\u0026gt; C[Customize Properties] C --\u0026gt; D[Generate Object] style A fill:#f9d5e5,stroke:#333,stroke-width:2px style B fill:#eeeeee,stroke:#333,stroke-width:2px style C fill:#d5e8f9,stroke:#333,stroke-width:2px style D fill:#e8f9d5,stroke:#333,stroke-width:2px Prerequisites # This guide assumes:
You\u0026rsquo;ve already added Fixture Monkey to your project You know how to create a basic FixtureMonkey instance If you haven\u0026rsquo;t set up Fixture Monkey yet, refer to the Getting Started section first.
Basic Customization Methods # This section introduces the most fundamental customization methods you\u0026rsquo;ll use daily.
Setting Property Values # The most basic way to customize an object is to set specific property values:
Java Kotlin Product product = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026#34;name\u0026#34;, \u0026#34;Smartphone\u0026#34;) .set(\u0026#34;price\u0026#34;, new BigDecimal(\u0026#34;499.99\u0026#34;)) .set(\u0026#34;available\u0026#34;, true) .sample(); val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setExp(Product::name, \u0026#34;Smartphone\u0026#34;) .setExp(Product::price, BigDecimal(\u0026#34;499.99\u0026#34;)) .setExp(Product::available, true) .sample() Setting Null Values # When you need to test with null values:
Java Kotlin Product nullNameProduct = fixtureMonkey.giveMeBuilder(Product.class) .setNull(\u0026#34;name\u0026#34;) // Set name to null .sample(); val nullNameProduct = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setNullExp(Product::name) // Set name to null .sample() Working with Collections # The most important thing when working with collections is to set the size first:
Java Kotlin // Create an order with 2 products Order orderWith2Products = fixtureMonkey.giveMeBuilder(Order.class) .size(\u0026#34;products\u0026#34;, 2) // Set size first .set(\u0026#34;products[0].name\u0026#34;, \u0026#34;Laptop\u0026#34;) // Then customize elements .sample(); // Create an order with 2 products val orderWith2Products = fixtureMonkey.giveMeBuilder\u0026lt;Order\u0026gt;() .sizeExp(Order::products, 2) // Set size first .set(\u0026#34;products[0].name\u0026#34;, \u0026#34;Laptop\u0026#34;) // Then customize elements .sample() For more advanced collection customization, check the Path Expressions document.
Customizing Nested Objects # You can access nested properties using dot notation:
Java Kotlin // Create a customer with an address Customer customer = fixtureMonkey.giveMeBuilder(Customer.class) .set(\u0026#34;name\u0026#34;, \u0026#34;John Doe\u0026#34;) .set(\u0026#34;address.street\u0026#34;, \u0026#34;123 Main Street\u0026#34;) // Nested property .set(\u0026#34;address.city\u0026#34;, \u0026#34;New York\u0026#34;) // Nested property .sample(); // Create a customer with an address val customer = fixtureMonkey.giveMeBuilder\u0026lt;Customer\u0026gt;() .setExp(Customer::name, \u0026#34;John Doe\u0026#34;) .set(\u0026#34;address.street\u0026#34;, \u0026#34;123 Main Street\u0026#34;) // Nested property .set(\u0026#34;address.city\u0026#34;, \u0026#34;New York\u0026#34;) // Nested property .sample() For more complex nested object customization, check the InnerSpec guide.
Frequently Asked Questions # The most common issues beginners face.
Why is my collection empty when I tried to customize an element? # The most common mistake is not setting the collection size first:
Java Kotlin // Wrong way - collection might be empty Order orderWrong = fixtureMonkey.giveMeBuilder(Order.class) .set(\u0026#34;products[0].name\u0026#34;, \u0026#34;Laptop\u0026#34;) // This might not work! .sample(); // Correct way - set size first Order orderCorrect = fixtureMonkey.giveMeBuilder(Order.class) .size(\u0026#34;products\u0026#34;, 1) // Set size first! .set(\u0026#34;products[0].name\u0026#34;, \u0026#34;Laptop\u0026#34;) // Now this works .sample(); // Wrong way - collection might be empty val orderWrong = fixtureMonkey.giveMeBuilder\u0026lt;Order\u0026gt;() .set(\u0026#34;products[0].name\u0026#34;, \u0026#34;Laptop\u0026#34;) // This might not work! .sample() // Correct way - set size first val orderCorrect = fixtureMonkey.giveMeBuilder\u0026lt;Order\u0026gt;() .sizeExp(Order::products, 1) // Set size first! .set(\u0026#34;products[0].name\u0026#34;, \u0026#34;Laptop\u0026#34;) // Now this works .sample() Why do I get null values when I didn\u0026rsquo;t set them to null? # By default, Fixture Monkey may generate null values for some properties. To ensure values are not null:
Java Kotlin Product nonNullProduct = fixtureMonkey.giveMeBuilder(Product.class) .setNotNull(\u0026#34;name\u0026#34;) // Ensure name is not null .setNotNull(\u0026#34;price\u0026#34;) // Ensure price is not null .sample(); val nonNullProduct = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setNotNullExp(Product::name) // Ensure name is not null .setNotNullExp(Product::price) // Ensure price is not null .sample() Next Steps # Now that you\u0026rsquo;ve learned the basics, explore these topics for more advanced usage:
Path Expressions - Accessing and customizing nested properties Customization APIs - Complete list of customization methods Testing Interfaces - How to work with interfaces InnerSpec - Advanced customization for complex objects Arbitrary - Generating test data with specific constraints `}),e.add({id:21,href:"/v1-1-0/docs/plugins/interface-plugin/features/",title:"Features",description:`The Interface Plugin is a powerful tool that enables Fixture Monkey to dynamically handle implementations of interfaces and abstract classes during object generation. It is particularly useful when you need to specify concrete implementations for interfaces or abstract classes in your test fixtures.
Abstract # Register concrete implementations for interfaces Register concrete implementations for abstract classes Anonymous arbitrary introspector usage option (default: enabled) Support for dynamic implementation resolution based on property characteristics using CandidateConcretePropertyResolver Basic Usage # FixtureMonkey sut = FixtureMonkey.`,content:`The Interface Plugin is a powerful tool that enables Fixture Monkey to dynamically handle implementations of interfaces and abstract classes during object generation. It is particularly useful when you need to specify concrete implementations for interfaces or abstract classes in your test fixtures.
Abstract # Register concrete implementations for interfaces Register concrete implementations for abstract classes Anonymous arbitrary introspector usage option (default: enabled) Support for dynamic implementation resolution based on property characteristics using CandidateConcretePropertyResolver Basic Usage # FixtureMonkey sut = FixtureMonkey.builder() .plugin(new InterfacePlugin() .interfaceImplements(MyInterface.class, Arrays.asList(MyInterfaceImpl1.class, MyInterfaceImpl2.class)) .abstractClassExtends(MyAbstractClass.class, Arrays.asList(MyConcreteClass1.class, MyConcreteClass2.class)) ) .build(); Disabling Anonymous Arbitrary Introspector # FixtureMonkey sut = FixtureMonkey.builder() .plugin(new InterfacePlugin() .interfaceImplements(MyInterface.class, Arrays.asList(MyInterfaceImpl.class)) .useAnonymousArbitraryIntrospector(false) ) .build(); API Reference # interfaceImplements # Registers implementations for a given interface.
public \u0026lt;T\u0026gt; InterfacePlugin interfaceImplements( Class\u0026lt;T\u0026gt; interfaceType, List\u0026lt;Class\u0026lt;? extends T\u0026gt;\u0026gt; implementations ) Parameters:
interfaceType: The interface class to be implemented implementations: List of classes implementing the interface abstractClassExtends # Registers implementations for a given abstract class.
public \u0026lt;T\u0026gt; InterfacePlugin abstractClassExtends( Class\u0026lt;T\u0026gt; abstractClassType, List\u0026lt;Class\u0026lt;? extends T\u0026gt;\u0026gt; implementations ) Parameters:
abstractClassType: The abstract class type to be implemented implementations: List of classes implementing the abstract class useAnonymousArbitraryIntrospector # Configures the use of an anonymous arbitrary introspector. By default, this option is enabled (default value: true). When enabled, it uses an instance of AnonymousArbitraryIntrospector as the fallback introspector.
public InterfacePlugin useAnonymousArbitraryIntrospector(boolean useAnonymousArbitraryIntrospector) Parameters:
useAnonymousArbitraryIntrospector: Whether to use the anonymous arbitrary introspector (default: true) Example:
// Default behavior (anonymous introspector enabled) FixtureMonkey sut = FixtureMonkey.builder() .plugin(new InterfacePlugin() .interfaceImplements(MyInterface.class, Arrays.asList(MyInterfaceImpl.class)) .useAnonymousArbitraryIntrospector(true) ) .build(); // Anonymous introspector disabled FixtureMonkey sut2 = FixtureMonkey.builder() .plugin(new InterfacePlugin() .interfaceImplements(MyInterface.class, Arrays.asList(MyInterfaceImpl.class)) .useAnonymousArbitraryIntrospector(false) ) .build(); Examples # Basic Interface Implementation # interface Animal { String sound(); } class Dog implements Animal { @Override public String sound() { return \u0026quot;Woof\u0026quot;; } } class Cat implements Animal { @Override public String sound() { return \u0026quot;Meow\u0026quot;; } } FixtureMonkey sut = FixtureMonkey.builder() .plugin(new InterfacePlugin() .interfaceImplements(Animal.class, Arrays.asList(Dog.class, Cat.class)) ) .build(); // Returns either a Dog or Cat instance Animal animal = sut.giveMeOne(Animal.class); Abstract Class Implementation # abstract class Vehicle { abstract int getWheels(); } class Car extends Vehicle { @Override int getWheels() { return 4; } } class Bike extends Vehicle { @Override int getWheels() { return 2; } } FixtureMonkey sut = FixtureMonkey.builder() .plugin(new InterfacePlugin() .abstractClassExtends(Vehicle.class, Arrays.asList(Car.class, Bike.class)) ) .build(); // Returns either a Car or Bike instance Vehicle vehicle = sut.giveMeOne(Vehicle.class); Anonymous Object Generation # When useAnonymousArbitraryIntrospector is enabled, you can generate anonymous implementations for interfaces that don\u0026rsquo;t have registered implementations. The plugin uses JDK Dynamic Proxy to create these implementations, allowing you to customize the generated values. Here\u0026rsquo;s an example:
interface UserService { String getUserName(); int getUserAge(); List\u0026lt;String\u0026gt; getUserRoles(); // Default method - behavior varies by JDK version default String getFullInfo() { return getUserName() + \u0026quot; (\u0026quot; + getUserAge() + \u0026quot;)\u0026quot;; } } FixtureMonkey sut = FixtureMonkey.builder() .plugin(new InterfacePlugin() .useAnonymousArbitraryIntrospector(true) ) .build(); // Generates an anonymous implementation with random values using JDK Dynamic Proxy UserService anonymousUserService = sut.giveMeOne(UserService.class); // Customizes the generated values UserService customAnonymousUserService = sut.giveMeBuilder(UserService.class) .set(\u0026quot;userName\u0026quot;, \u0026quot;John Doe\u0026quot;) .set(\u0026quot;userAge\u0026quot;, 30) .set(\u0026quot;userRoles\u0026quot;, Arrays.asList(\u0026quot;ADMIN\u0026quot;, \u0026quot;USER\u0026quot;)) .sample(); The generated anonymous implementation:
Is created using JDK Dynamic Proxy Returns random values for all interface methods by default Can be customized using giveMeBuilder Maintains consistent values across multiple method calls Supports all primitive types, objects, and collections Note: Default method behavior varies by JDK version:
In JDK 17, default methods maintain their original implementation In JDK versions prior to 17, default methods are proxied and return random values This means the original implementation is ignored, and default methods return random values like other methods For example, the getFullInfo() method will return a random string instead of using its original implementation Advanced Usage # Using Custom Matchers # FixtureMonkey sut = FixtureMonkey.builder() .plugin(new InterfacePlugin() .interfaceImplements( new ExactTypeMatcher(MyInterface.class), Arrays.asList(MyInterfaceImpl1.class, MyInterfaceImpl2.class) ) ) .build(); Using CandidateConcretePropertyResolver # CandidateConcretePropertyResolver provides a flexible way to dynamically determine concrete implementations for interfaces or abstract classes. It can make decisions at runtime based on various factors:
Property name Property type Property annotations Property metadata Other property characteristics The resolver\u0026rsquo;s resolve method is called for each property that requires a concrete implementation, enabling you to:
Return a single implementation for specific cases Return multiple implementations for random selection Return different implementations based on property characteristics Apply complex business logic to determine the appropriate implementation Here\u0026rsquo;s an example:
interface Animal { String sound(); String getName(); } class Dog implements Animal { @Override public String sound() { return \u0026quot;Woof\u0026quot;; } @Override public String getName() { return \u0026quot;Dog\u0026quot;; } } class Cat implements Animal { @Override public String sound() { return \u0026quot;Meow\u0026quot;; } @Override public String getName() { return \u0026quot;Cat\u0026quot;; } } // Custom resolver that returns implementations only when the property name is \u0026quot;animal\u0026quot; class AnimalResolver implements CandidateConcretePropertyResolver { @Override public List\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; resolve(Property property) { if (\u0026quot;animal\u0026quot;.equals(property.getName())) { return Arrays.asList(Dog.class, Cat.class); } return Collections.emptyList(); } } FixtureMonkey sut = FixtureMonkey.builder() .plugin(new InterfacePlugin() .interfaceImplements( new ExactTypeMatcher(Animal.class), new AnimalResolver() ) ) .build(); // Randomly selects either Dog or Cat when the property name is \u0026quot;animal\u0026quot; Animal animal = sut.giveMeOne(Animal.class); `}),e.add({id:22,href:"/v1-1-0/docs/customizing-objects/path-expressions/",title:"Path expressions",description:"What you will learn in this document # How to select specific fields or properties of a test object How to reference specific parts of an object using string expressions How to access properties in various structures like nested objects, arrays, and lists Introduction to Path Expressions # When writing tests, you often need to modify specific fields of your test objects. Path expressions in Fixture Monkey are like GPS coordinates that help you precisely locate and modify any part of your test object.",content:`What you will learn in this document # How to select specific fields or properties of a test object How to reference specific parts of an object using string expressions How to access properties in various structures like nested objects, arrays, and lists Introduction to Path Expressions # When writing tests, you often need to modify specific fields of your test objects. Path expressions in Fixture Monkey are like GPS coordinates that help you precisely locate and modify any part of your test object.
As a beginner, think of path expressions as a way to \u0026ldquo;navigate\u0026rdquo; through your object structure to reach exactly the field you want to change.
Basic Object Structure Example # To understand path expressions, let\u0026rsquo;s use a simple example object:
@Value public class JavaClass { String field; // A simple string field String[] array; // An array of strings List\u0026lt;String\u0026gt; list; // A list of strings Nested object; // A nested object List\u0026lt;Nested\u0026gt; objectList; // A list of nested objects @Value public static class Nested { String nestedField; // A field inside the nested object } } Visual Map of Path Expressions # Think of your object as a tree structure. Each path expression is like directions to a specific location in that tree:
JavaClass â”‚ â”œâ”€â”€ field â†’ \u0026quot;field\u0026quot; // Direct field access â”‚ â”œâ”€â”€ array â†’ \u0026quot;array\u0026quot; // The entire array â”‚ â”œâ”€â”€ array[0] â†’ \u0026quot;array[0]\u0026quot; // First element in array â”‚ â”œâ”€â”€ array[1] â†’ \u0026quot;array[1]\u0026quot; // Second element in array â”‚ â””â”€â”€ all elements â†’ \u0026quot;array[*]\u0026quot; // ALL elements in array (wildcard) â”‚ â”œâ”€â”€ list â†’ \u0026quot;list\u0026quot; // The entire list â”‚ â”œâ”€â”€ list[0] â†’ \u0026quot;list[0]\u0026quot; // First element in list â”‚ â”œâ”€â”€ list[1] â†’ \u0026quot;list[1]\u0026quot; // Second element in list â”‚ â””â”€â”€ all elements â†’ \u0026quot;list[*]\u0026quot; // ALL elements in list (wildcard) â”‚ â”œâ”€â”€ object â†’ \u0026quot;object\u0026quot; // The nested object â”‚ â””â”€â”€ nestedField â†’ \u0026quot;object.nestedField\u0026quot; // Field inside nested object â”‚ â””â”€â”€ objectList â†’ \u0026quot;objectList\u0026quot; // List of nested objects â”œâ”€â”€ objectList[0] â†’ \u0026quot;objectList[0]\u0026quot; // First object in the list â”‚ â””â”€â”€ nestedField â†’ \u0026quot;objectList[0].nestedField\u0026quot; // Field in first object â”‚ â”œâ”€â”€ objectList[1] â†’ \u0026quot;objectList[1]\u0026quot; // Second object in the list â”‚ â””â”€â”€ nestedField â†’ \u0026quot;objectList[1].nestedField\u0026quot; // Field in second object â”‚ â””â”€â”€ all elements â†’ \u0026quot;objectList[*]\u0026quot; // ALL objects in the list â””â”€â”€ nestedField â†’ \u0026quot;objectList[*].nestedField\u0026quot; // Field in ALL objects Simple Path Expressions Guide # 1. Selecting the Root Object # To select the entire object itself, use:
\u0026quot;$\u0026quot; Example:
ArbitraryBuilder\u0026lt;JavaClass\u0026gt; builder = fixtureMonkey.giveMeBuilder(JavaClass.class); // Select and manipulate the entire object builder.set(\u0026quot;$\u0026quot;, new JavaClass(...)); 2. Selecting a Direct Field # To select a simple field at the top level:
\u0026quot;field\u0026quot; Example:
// Set the \u0026quot;field\u0026quot; property to \u0026quot;Hello World\u0026quot; builder.set(\u0026quot;field\u0026quot;, \u0026quot;Hello World\u0026quot;); 3. Selecting a Nested Field # To access a field inside a nested object:
\u0026quot;object.nestedField\u0026quot; Example:
// Set the nestedField inside the object to \u0026quot;Nested Value\u0026quot; builder.set(\u0026quot;object.nestedField\u0026quot;, \u0026quot;Nested Value\u0026quot;); 4. Working with Collections # Selecting a specific item in a list: # \u0026quot;list[0]\u0026quot; // First item \u0026quot;list[1]\u0026quot; // Second item Example:
// Set the first item in the list to \u0026quot;First Item\u0026quot; builder.set(\u0026quot;list[0]\u0026quot;, \u0026quot;First Item\u0026quot;); Selecting ALL items in a list (wildcard): # \u0026quot;list[*]\u0026quot; Example:
// Set ALL items in the list to \u0026quot;Same Value\u0026quot; builder.set(\u0026quot;list[*]\u0026quot;, \u0026quot;Same Value\u0026quot;); 5. Working with Arrays # Very similar to lists:
\u0026quot;array[0]\u0026quot; // First element \u0026quot;array[*]\u0026quot; // All elements Example:
// Set all array elements to \u0026quot;Array Item\u0026quot; builder.set(\u0026quot;array[*]\u0026quot;, \u0026quot;Array Item\u0026quot;); 6. Complex Nested Paths # You can combine these patterns to go as deep as you need:
\u0026quot;objectList[0].nestedField\u0026quot; // nestedField of first object in list \u0026quot;objectList[*].nestedField\u0026quot; // nestedField of ALL objects in list Example:
// Set the nestedField of all objects in objectList to \u0026quot;All Nested\u0026quot; builder.set(\u0026quot;objectList[*].nestedField\u0026quot;, \u0026quot;All Nested\u0026quot;); Type-Safe Selection with JavaGetter # If you prefer to avoid string-based expressions, you can use type-safe getters:
1. Selecting a Direct Field # javaGetter(JavaClass::getField) Example:
builder.set(javaGetter(JavaClass::getField), \u0026quot;Hello World\u0026quot;); 2. Selecting a Nested Field # javaGetter(JavaClass::getObject).into(Nested::getNestedField) Example:
builder.set( javaGetter(JavaClass::getObject).into(Nested::getNestedField), \u0026quot;Nested Value\u0026quot; ); 3. Working with Collections # // Select specific element javaGetter(JavaClass::getList).index(String.class, 0) // Select all elements javaGetter(JavaClass::getList).allIndex(String.class) Example:
// Set all list elements to \u0026quot;List Item\u0026quot; builder.set( javaGetter(JavaClass::getList).allIndex(String.class), \u0026quot;List Item\u0026quot; ); Common Beginner Questions # What happens if I try to access an out-of-bounds index? # If you try to access an element that doesn\u0026rsquo;t exist (e.g., \u0026quot;list[5]\u0026quot; when the list only has 3 items), Fixture Monkey will simply ignore that setting. To catch these issues, you can enable Expression Strict Mode.
How do I handle maps? # While you can\u0026rsquo;t directly access map elements with path expressions, you can use InnerSpec to customize maps.
Can I use multiple path expressions at once? # Yes! You can chain multiple .set() calls to configure different parts of your object:
ArbitraryBuilder\u0026lt;JavaClass\u0026gt; builder = fixtureMonkey.giveMeBuilder(JavaClass.class) .set(\u0026quot;field\u0026quot;, \u0026quot;Value 1\u0026quot;) .set(\u0026quot;object.nestedField\u0026quot;, \u0026quot;Value 2\u0026quot;) .set(\u0026quot;list[*]\u0026quot;, \u0026quot;Value 3\u0026quot;); Advanced Options # Expression Strict Mode # Enable this option to make Fixture Monkey validate all path expressions:
FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .setExpressionStrictMode(true) .build(); With strict mode enabled, invalid paths will throw exceptions, helping you catch mistakes early.
Kotlin Support # If you\u0026rsquo;re using Kotlin, you can use property references for even more elegant expressions:
// Instead of: \u0026quot;user.address.street\u0026quot; builder.set(User::address..Address::street, \u0026quot;Main Street\u0026quot;) For more details, see the Kotlin DSL Exp page.
Summary # Path expressions are a powerful feature of Fixture Monkey that let you:
Navigate to any part of your test object structure Set specific values for testing different scenarios Modify multiple related fields in one operation Keep your test code clean and readable Start with simple direct field access, then gradually explore collection access and nested properties as you grow comfortable with the syntax.
`}),e.add({id:23,href:"/v1-1-0/docs/customizing-objects/apis/",title:"Customization APIs",description:`What you will learn in this document # How to easily create test data How to generate objects with desired values How to apply these customizations in real testing scenarios Before you start # This document introduces various ways to create test data easily. Here are some common scenarios where you can use Fixture Monkey APIs:
When you need member data of a specific age range for registration tests When you need a shopping cart with multiple products for order tests When you need orders above a certain amount for payment tests Useful Terms to Know # Sampling: The process of actually creating test data.`,content:`What you will learn in this document # How to easily create test data How to generate objects with desired values How to apply these customizations in real testing scenarios Before you start # This document introduces various ways to create test data easily. Here are some common scenarios where you can use Fixture Monkey APIs:
When you need member data of a specific age range for registration tests When you need a shopping cart with multiple products for order tests When you need orders above a certain amount for payment tests Useful Terms to Know # Sampling: The process of actually creating test data. Each time you call the sample() method, new test data is generated. Builder: A tool that helps you create objects step by step. In Fixture Monkey, you create a builder using giveMeBuilder(). Path Expression: A way to specify which property of an object to modify. For example, \u0026ldquo;age\u0026rdquo; refers to the age property, \u0026ldquo;items[0]\u0026rdquo; refers to the first item in a list, and \u0026ldquo;address.city\u0026rdquo; refers to the city property within an address object. Table of Contents # API Summary Using Basic APIs set() - Setting Specific Values size() - Controlling List Sizes setNull() - Handling Null Values Learning Intermediate APIs setInner() - Creating Reusable Settings setLazy() - Generating Dynamic Values setPostCondition() - Creating Values with Conditions fixed() - Generating Same Values limit - Setting Values Partially Using Advanced APIs thenApply() - Setting Related Values customizeProperty() - Fine-tune property generation behavior Frequently Asked Questions (FAQ) API Summary # Basic APIs (Essential APIs for Beginners) # API Description Example Scenario set() Set specific values directly Set member\u0026rsquo;s age to 20 size() Set collection sizes Add 3 items to cart setNull() Set null values Set email to null for withdrawn members Intermediate APIs (Use after getting familiar with basics) # API Description Example Scenario setInner() Create reusable settings Use same member info across multiple tests setLazy() Generate dynamic values Create sequential order numbers setPostCondition() Create values meeting conditions Test adults-only service fixed() Generate same values consistently Use same test data across tests limit Set values for some elements only Apply discount to some cart items Advanced APIs (For complex test scenarios) # API Description Example Scenario thenApply() Set related values Set order total as sum of item prices customizeProperty() Fine-tune property generation behavior Filter values, transform data, generate unique values Using Basic APIs # set() # The set() method is used to set specific values for object properties. This is the most basic and commonly used API.
Basic Usage # Java Kotlin // Creating member data Member member = fixtureMonkey.giveMeBuilder(Member.class) .set(\u0026#34;name\u0026#34;, \u0026#34;John Doe\u0026#34;) // Set name .set(\u0026#34;age\u0026#34;, 25) // Set age .set(\u0026#34;email\u0026#34;, \u0026#34;john@test.com\u0026#34;) // Set email .sample(); // Creating order data Order order = fixtureMonkey.giveMeBuilder(Order.class) .set(\u0026#34;orderId\u0026#34;, \u0026#34;ORDER-001\u0026#34;) // Set order ID .set(\u0026#34;totalAmount\u0026#34;, BigDecimal.valueOf(15000)) // Set order amount .sample(); // Creating member data val member = fixtureMonkey.giveMeBuilder\u0026lt;Member\u0026gt;() .setExp(Member::name, \u0026#34;John Doe\u0026#34;) // Set name .setExp(Member::age, 25) // Set age .setExp(Member::email, \u0026#34;john@test.com\u0026#34;) // Set email .sample() // Creating order data val order = fixtureMonkey.giveMeBuilder\u0026lt;Order\u0026gt;() .setExp(Order::orderId, \u0026#34;ORDER-001\u0026#34;) // Set order ID .setExp(Order::totalAmount, BigDecimal.valueOf(15000)) // Set order amount .sample() Values.just() # Values.just() wraps an object to use it as-is without decomposing it into individual fields internally.
Caution: You cannot set a child property after setting with Just.
Product product = fixture.giveMeBuilder(MyClass.class) .set(\u0026quot;options\u0026quot;, Values.just(List.of(\u0026quot;red\u0026quot;, \u0026quot;medium\u0026quot;, \u0026quot;adult\u0026quot;)) .set(\u0026quot;options[0]\u0026quot;, \u0026quot;blue\u0026quot;) .sample(); For example, the value of options[0] in MyClass will not be \u0026ldquo;blue\u0026rdquo;, but will remain as the list set with Values.just().
size(), minSize(), maxSize() # The size() method is used to specify the size of collections like lists or arrays. You can set exact sizes or specify minimum/maximum sizes.
Basic Usage # Java Kotlin // Adding 3 items to cart Cart cart = fixtureMonkey.giveMeBuilder(Cart.class) .size(\u0026#34;items\u0026#34;, 3) // 3 items in cart .sample(); // Creating a product with 2-4 reviews Product product = fixtureMonkey.giveMeBuilder(Product.class) .size(\u0026#34;reviews\u0026#34;, 2, 4) // Min 2, max 4 reviews .sample(); // Adding 3 items to cart val cart = fixtureMonkey.giveMeBuilder\u0026lt;Cart\u0026gt;() .sizeExp(Cart::items, 3) // 3 items in cart .sample() // Creating a product with 2-4 reviews val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .sizeExp(Product::reviews, 2, 4) // Min 2, max 4 reviews .sample() setNull(), setNotNull() # setNull() and setNotNull() are used to make properties null or ensure they have values.
Basic Usage # Java Kotlin // Creating withdrawn member data (email is null) Member withdrawnMember = fixtureMonkey.giveMeBuilder(Member.class) .set(\u0026#34;name\u0026#34;, \u0026#34;John Doe\u0026#34;) .setNull(\u0026#34;email\u0026#34;) // Set email to null .sample(); // Creating order with required fields Order validOrder = fixtureMonkey.giveMeBuilder(Order.class) .setNotNull(\u0026#34;orderId\u0026#34;) // Order ID must exist .setNotNull(\u0026#34;orderDate\u0026#34;) // Order date must exist .sample(); // Creating withdrawn member data (email is null) val withdrawnMember = fixtureMonkey.giveMeBuilder\u0026lt;Member\u0026gt;() .setExp(Member::name, \u0026#34;John Doe\u0026#34;) .setNullExp(Member::email) // Set email to null .sample() // Creating order with required fields val validOrder = fixtureMonkey.giveMeBuilder\u0026lt;Order\u0026gt;() .setNotNullExp(Order::orderId) // Order ID must exist .setNotNullExp(Order::orderDate) // Order date must exist .sample() Learning Intermediate APIs # setInner() # setInner() is used to create reusable settings for multiple tests. It\u0026rsquo;s useful when you need the same member or order information across different tests.
Basic Usage # Java Kotlin // Setting up VIP member info InnerSpec vipMemberSpec = new InnerSpec() .property(\u0026#34;grade\u0026#34;, \u0026#34;VIP\u0026#34;) .property(\u0026#34;point\u0026#34;, 10000) .property(\u0026#34;joinDate\u0026#34;, LocalDate.now().minusYears(1)); // Reusing for VIP member creation Member vipMember = fixtureMonkey.giveMeBuilder(Member.class) .setInner(vipMemberSpec) .sample(); // Setting up VIP member info val vipMemberSpec = InnerSpec() .property(\u0026#34;grade\u0026#34;, \u0026#34;VIP\u0026#34;) .property(\u0026#34;point\u0026#34;, 10000) .property(\u0026#34;joinDate\u0026#34;, LocalDate.now().minusYears(1)) // Reusing for VIP member creation val vipMember = fixtureMonkey.giveMeBuilder\u0026lt;Member\u0026gt;() .setInner(vipMemberSpec) .sample() setLazy() # setLazy() is used to generate different or sequential values each time. It\u0026rsquo;s useful for creating sequential order numbers or using current timestamps.
Basic Usage # Java Kotlin // Generating sequential order numbers AtomicInteger orderCounter = new AtomicInteger(1); Order order = fixtureMonkey.giveMeBuilder(Order.class) .setLazy(\u0026#34;orderId\u0026#34;, () -\u0026gt; \u0026#34;ORDER-\u0026#34; + orderCounter.getAndIncrement()) .sample(); // ORDER-1 Order nextOrder = fixtureMonkey.giveMeBuilder(Order.class) .setLazy(\u0026#34;orderId\u0026#34;, () -\u0026gt; \u0026#34;ORDER-\u0026#34; + orderCounter.getAndIncrement()) .sample(); // ORDER-2 // Generating sequential order numbers var orderCounter = AtomicInteger(1) val order = fixtureMonkey.giveMeBuilder\u0026lt;Order\u0026gt;() .setLazy(\u0026#34;orderId\u0026#34;) { \u0026#34;ORDER-\${orderCounter.getAndIncrement()}\u0026#34; } .sample() // ORDER-1 val nextOrder = fixtureMonkey.giveMeBuilder\u0026lt;Order\u0026gt;() .setLazy(\u0026#34;orderId\u0026#34;) { \u0026#34;ORDER-\${orderCounter.getAndIncrement()}\u0026#34; } .sample() // ORDER-2 setPostCondition() # setPostCondition() is used to generate values that meet specific conditions. It\u0026rsquo;s useful when testing services with specific requirements, like adults-only services.
ðŸš¨ If conditions are too strict, finding values might take longer. Use set() when possible. Basic Usage # Java Kotlin // Creating adult members only Member adultMember = fixtureMonkey.giveMeBuilder(Member.class) .setPostCondition(\u0026#34;age\u0026#34;, Integer.class, age -\u0026gt; age \u0026gt;= 19) .sample(); // Creating large orders only Order largeOrder = fixtureMonkey.giveMeBuilder(Order.class) .setPostCondition(\u0026#34;totalAmount\u0026#34;, BigDecimal.class, amount -\u0026gt; amount.compareTo(BigDecimal.valueOf(100000)) \u0026gt;= 0) .sample(); // Creating adult members only val adultMember = fixtureMonkey.giveMeBuilder\u0026lt;Member\u0026gt;() .setPostConditionExp(Member::age, Int::class.java) { it \u0026gt;= 19 } .sample() // Creating large orders only val largeOrder = fixtureMonkey.giveMeBuilder\u0026lt;Order\u0026gt;() .setPostConditionExp(Order::totalAmount, BigDecimal::class.java) { it \u0026gt;= BigDecimal.valueOf(100000) } .sample() fixed() # fixed() is used when you need the same test data every time you run your tests.
Basic Usage # Java Kotlin // Testing with same member info Member member = fixtureMonkey.giveMeBuilder(Member.class) .set(\u0026#34;name\u0026#34;, \u0026#34;John Doe\u0026#34;) .set(\u0026#34;age\u0026#34;, 30) .fixed() // Generate same data every time .sample(); // Testing with same member info val member = fixtureMonkey.giveMeBuilder\u0026lt;Member\u0026gt;() .setExp(Member::name, \u0026#34;John Doe\u0026#34;) .setExp(Member::age, 30) .fixed() // Generate same data every time .sample() limit # limit is used when you want to set specific values for only some elements in a collection.
Basic Usage # Java Kotlin // Applying discount to some cart items only Cart cart = fixtureMonkey.giveMeBuilder(Cart.class) .size(\u0026#34;items\u0026#34;, 5) // 5 items .set(\u0026#34;items[*].onSale\u0026#34;, true, 2) // Only 2 items on sale .sample(); // Applying discount to some cart items only val cart = fixtureMonkey.giveMeBuilder\u0026lt;Cart\u0026gt;() .sizeExp(Cart::items, 5) // 5 items .set(\u0026#34;items[*].onSale\u0026#34;, true, 2) // Only 2 items on sale .sample() Using Advanced APIs # thenApply() # thenApply() is used when you need to set values based on other values in the object. For example, setting an order\u0026rsquo;s total amount based on its item prices.
Basic Usage # Java Kotlin // Setting order total as sum of item prices Order order = fixtureMonkey.giveMeBuilder(Order.class) .size(\u0026#34;items\u0026#34;, 3) // 3 items .thenApply((tempOrder, orderBuilder) -\u0026gt; { // Calculate total BigDecimal total = tempOrder.getItems().stream() .map(item -\u0026gt; item.getPrice()) .reduce(BigDecimal.ZERO, BigDecimal::add); // Set calculated total orderBuilder.set(\u0026#34;totalAmount\u0026#34;, total); }) .sample(); // Setting order total as sum of item prices val order = fixtureMonkey.giveMeBuilder\u0026lt;Order\u0026gt;() .sizeExp(Order::items, 3) // 3 items .thenApply { tempOrder, orderBuilder -\u0026gt; // Calculate total val total = tempOrder.items .map { it.price } .fold(BigDecimal.ZERO, BigDecimal::add) // Set calculated total orderBuilder.set(\u0026#34;totalAmount\u0026#34;, total) } .sample() customizeProperty() # customizeProperty() is used when you want to fine-tune how Fixture Monkey generates values for specific properties. This is an advanced feature that gives you more control than set() by allowing transformations and filtering.
When do you need customizeProperty()? # You\u0026rsquo;ll find customizeProperty() useful when:
You want to transform generated values: \u0026ldquo;Make all names start with \u0026lsquo;Mr.\u0026rsquo;\u0026rdquo; You need conditional filtering: \u0026ldquo;Only positive numbers\u0026rdquo; You want unique values in collections: \u0026ldquo;No duplicate items in a list\u0026rdquo; âš ï¸ customizeProperty requires TypedPropertySelector. This is more complex than basic APIs, so make sure you're comfortable with set(), size(), and other basic APIs first. Simple Property Customization # Java Kotlin // You need to import the property selector import static com.navercorp.fixturemonkey.api.experimental.JavaGetterMethodPropertySelector.javaGetter; // Transform a property value String expected = \u0026#34;transformed\u0026#34;; String actual = fixtureMonkey.giveMeBuilder(Member.class) .customizeProperty(javaGetter(Member::getName), arb -\u0026gt; arb.map(name -\u0026gt; expected)) .sample() .getName(); // Filter values to meet conditions Member adult = fixtureMonkey.giveMeBuilder(Member.class) .customizeProperty(javaGetter(Member::getAge), arb -\u0026gt; arb.filter(age -\u0026gt; age \u0026gt;= 18)) .sample(); // Combine filtering and transformation Member vipMember = fixtureMonkey.giveMeBuilder(Member.class) .customizeProperty(javaGetter(Member::getEmail), arb -\u0026gt; arb.filter(email -\u0026gt; email.contains(\u0026#34;@\u0026#34;)) .map(email -\u0026gt; \u0026#34;vip-\u0026#34; + email)) .sample(); // Kotlin can use property references directly class StringObject(val string: String) val expected = \u0026#34;test\u0026#34; val actual = fixtureMonkey.giveMeKotlinBuilder\u0026lt;StringObject\u0026gt;() .customizeProperty(StringObject::string) { it.map { _ -\u0026gt; expected } } .sample() .string // Filter values to meet conditions class Member(val name: String, val age: Int) val adult = fixtureMonkey.giveMeKotlinBuilder\u0026lt;Member\u0026gt;() .customizeProperty(Member::age) { arb -\u0026gt; arb.filter { age -\u0026gt; age \u0026gt;= 18 } } .sample() // Combine filtering and transformation val vipMember = fixtureMonkey.giveMeKotlinBuilder\u0026lt;Member\u0026gt;() .customizeProperty(Member::name) { arb -\u0026gt; arb.filter { name -\u0026gt; name.isNotBlank() } .map { name -\u0026gt; \u0026#34;VIP-$name\u0026#34; } } .sample() Working with Nested Properties # Java Kotlin // Customize nested object properties String nestedValue = fixtureMonkey.giveMeBuilder(Order.class) .customizeProperty( javaGetter(Order::getCustomer).into(Customer::getName), arb -\u0026gt; arb.map(name -\u0026gt; \u0026#34;Mr. \u0026#34; + name) ) .sample() .getCustomer() .getName(); // Customize nested object properties class Customer(val name: String) class Order(val customer: Customer) val nestedValue = fixtureMonkey.giveMeKotlinBuilder\u0026lt;Order\u0026gt;() .customizeProperty(Order::customer into Customer::name) { it.map { name -\u0026gt; \u0026#34;Mr. $name\u0026#34; } } .sample() .customer .name Working with Collections # Java Kotlin // Customize individual elements in a collection String firstItem = fixtureMonkey.giveMeBuilder(Cart.class) .size(\u0026#34;items\u0026#34;, 3) .customizeProperty( javaGetter(Cart::getItems).index(String.class, 0), arb -\u0026gt; arb.map(item -\u0026gt; \u0026#34;ITEM-\u0026#34; + item) ) .sample() .getItems() .get(0); // Make a list unique (requires experimental API) import static com.navercorp.fixturemonkey.api.experimental.TypedExpressionGenerator.typedRoot; List\u0026lt;Integer\u0026gt; uniqueList = fixtureMonkey.giveMeExperimentalBuilder(new TypeReference\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;() {}) .\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;customizeProperty(typedRoot(), CombinableArbitrary::unique) .size(\u0026#34;$\u0026#34;, 10) .sample(); // Customize individual elements in a collection class Cart(val items: List\u0026lt;String\u0026gt;) val firstItem = fixtureMonkey.giveMeKotlinBuilder\u0026lt;Cart\u0026gt;() .size(Cart::items, 3) .customizeProperty(Cart::items[0]) { it.map { item -\u0026gt; \u0026#34;ITEM-$item\u0026#34; } } .sample() .items[0] // Make a list unique (requires experimental API) import com.navercorp.fixturemonkey.api.experimental.TypedExpressionGenerator.typedRoot val uniqueList = fixtureMonkey.giveMeExperimentalBuilder\u0026lt;List\u0026lt;Int\u0026gt;\u0026gt;() .customizeProperty(typedRoot\u0026lt;List\u0026lt;Int\u0026gt;\u0026gt;()) { it.unique() } .size(List\u0026lt;Int\u0026gt;::root, 10) .sample() Real-World Testing Scenarios # Java Kotlin // Testing user registration with business rules Member validUser = fixtureMonkey.giveMeBuilder(Member.class) .customizeProperty(javaGetter(Member::getEmail), arb -\u0026gt; arb.filter(email -\u0026gt; email.contains(\u0026#34;@\u0026#34;) \u0026amp;\u0026amp; email.contains(\u0026#34;.\u0026#34;)) .map(email -\u0026gt; email.toLowerCase())) .customizeProperty(javaGetter(Member::getAge), arb -\u0026gt; arb.filter(age -\u0026gt; age \u0026gt;= 18 \u0026amp;\u0026amp; age \u0026lt;= 120)) .sample(); // Testing orders with minimum amounts Order validOrder = fixtureMonkey.giveMeBuilder(Order.class) .customizeProperty(javaGetter(Order::getTotalAmount), arb -\u0026gt; arb.filter(amount -\u0026gt; amount.compareTo(BigDecimal.valueOf(10)) \u0026gt;= 0)) .sample(); // Testing user registration with business rules class User(val email: String, val age: Int, val name: String) val validUser = fixtureMonkey.giveMeKotlinBuilder\u0026lt;User\u0026gt;() .customizeProperty(User::email) { arb -\u0026gt; arb.filter { email -\u0026gt; email.contains(\u0026#34;@\u0026#34;) \u0026amp;\u0026amp; email.contains(\u0026#34;.\u0026#34;) } .map { email -\u0026gt; email.lowercase() } } .customizeProperty(User::age) { arb -\u0026gt; arb.filter { age -\u0026gt; age in 18..120 } } .sample() // Testing orders with minimum amounts class Order(val totalAmount: BigDecimal) val validOrder = fixtureMonkey.giveMeKotlinBuilder\u0026lt;Order\u0026gt;() .customizeProperty(Order::totalAmount) { arb -\u0026gt; arb.filter { amount -\u0026gt; amount \u0026gt;= BigDecimal.valueOf(10) } } .sample() Important Things to Remember # Learn basic APIs first: Make sure you understand set(), size(), setNull() before using customizeProperty()
Import required classes:
// For Java import static com.navercorp.fixturemonkey.api.experimental.JavaGetterMethodPropertySelector.javaGetter; // For experimental features import static com.navercorp.fixturemonkey.api.experimental.TypedExpressionGenerator.typedRoot; Order matters: set() will override customizeProperty()
// This won't work as expected .customizeProperty(javaGetter(Member::getName), arb -\u0026gt; arb.map(name -\u0026gt; \u0026quot;Mr. \u0026quot; + name)) .set(\u0026quot;name\u0026quot;, \u0026quot;John\u0026quot;) // This overwrites the customization above Keep filters reasonable: Too strict filters can cause generation to fail
// Too strict - might fail .customizeProperty(javaGetter(Member::getAge), arb -\u0026gt; arb.filter(age -\u0026gt; age == 25)) // Better - more flexible range .customizeProperty(javaGetter(Member::getAge), arb -\u0026gt; arb.filter(age -\u0026gt; age \u0026gt;= 20 \u0026amp;\u0026amp; age \u0026lt;= 30)) Use for complex transformations: If you just need a specific value, use set() instead
Frequently Asked Questions (FAQ) # Q: Which APIs should I learn first? # We recommend learning in this order:
set() - This is the most basic and commonly used API. size() - You\u0026rsquo;ll need this when working with lists and arrays. setNull(), setNotNull() - Use these when handling null values. After you\u0026rsquo;re comfortable with these, you can gradually learn other APIs.
Q: How can I use the same test data across tests? # You can use fixed(). For example:
// Using same member info across tests ArbitraryBuilder\u0026lt;Member\u0026gt; memberBuilder = fixtureMonkey.giveMeBuilder(Member.class) .set(\u0026quot;name\u0026quot;, \u0026quot;John Doe\u0026quot;) .set(\u0026quot;age\u0026quot;, 30) .fixed(); // Generate same data every time Member member1 = memberBuilder.sample(); // Always same data Member member2 = memberBuilder.sample(); // Same as member1 Q: How can I prevent incorrect values from being generated? # You can use setPostCondition() to specify value ranges or conditions:
// Age must be between 1-100 Member member = fixtureMonkey.giveMeBuilder(Member.class) .setPostCondition(\u0026quot;age\u0026quot;, Integer.class, age -\u0026gt; age \u0026gt;= 1 \u0026amp;\u0026amp; age \u0026lt;= 100) .sample(); Q: What\u0026rsquo;s the difference between set() and customizeProperty()? # set() directly assigns a specific value to a property customizeProperty() modifies how the property value is generated, allowing for filtering, transformation, and conditional logic Use set() when you know exactly what value you want. Use customizeProperty() when you need to apply transformations or filters to generated values:
// Direct assignment with set() Member member = fixtureMonkey.giveMeBuilder(Member.class) .set(\u0026quot;email\u0026quot;, \u0026quot;john@test.com\u0026quot;) .sample(); // Transformation with customizeProperty() Member memberWithCustomEmail = fixtureMonkey.giveMeBuilder(Member.class) .customizeProperty(\u0026quot;email\u0026quot;, arb -\u0026gt; arb.map(email -\u0026gt; \u0026quot;vip-\u0026quot; + email)) .sample(); Q: Can I use customizeProperty() with collections? # Yes! You can customize individual elements or the entire collection:
// Customize all elements in a list List\u0026lt;String\u0026gt; customizedList = fixtureMonkey.giveMeBuilder(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {}) .customizeProperty(\u0026quot;$[*]\u0026quot;, arb -\u0026gt; arb.map(str -\u0026gt; \u0026quot;PREFIX-\u0026quot; + str)) .sample(); // Make the list unique List\u0026lt;Integer\u0026gt; uniqueList = fixtureMonkey.giveMeBuilder(new TypeReference\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;() {}) .\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;customizeProperty(typedRoot(), CombinableArbitrary::unique) .size(\u0026quot;$\u0026quot;, 10) .sample(); `}),e.add({id:24,href:"/v1-1-0/docs/customizing-objects/arbitrary/",title:"Creating Random Test Data with Conditions",description:`What you will learn in this document # How to create test data with random but controlled values How to set ranges, patterns, and limits for your test data When and why to use random values instead of fixed values Introduction to Random Test Data # Sometimes in testing, using fixed values isn\u0026rsquo;t enough. You might want:
A range of valid inputs rather than a single value Different test data each time the test runs Random but realistic data that follows business rules For example, when testing:`,content:`What you will learn in this document # How to create test data with random but controlled values How to set ranges, patterns, and limits for your test data When and why to use random values instead of fixed values Introduction to Random Test Data # Sometimes in testing, using fixed values isn\u0026rsquo;t enough. You might want:
A range of valid inputs rather than a single value Different test data each time the test runs Random but realistic data that follows business rules For example, when testing:
Age validation: you might want random ages between 18-65 Username validation: you need random strings following specific patterns Payment processing: you need various amounts within certain ranges Understanding Arbitrary # In Fixture Monkey, we use Arbitrary to create random values that follow rules. Think of an Arbitrary as a value generator with rules.
In simple terms: An Arbitrary is like a machine that produces random values, but only values that follow your rules.
Step-by-Step Guide to Random Values # 1. Basic Usage: Setting a Simple Range # Java Kotlin // Create a member with age between 20 and 30 Member member = fixtureMonkey.giveMeBuilder(Member.class) .set(\u0026#34;age\u0026#34;, Arbitraries.integers().between(20, 30)) // Random age between 20-30 .sample(); // Create a member with age between 20 and 30 val member = fixtureMonkey.giveMeBuilder\u0026lt;Member\u0026gt;() .setExp(Member::age, Arbitraries.integers().between(20, 30)) // Random age between 20-30 .sample() 2. Working with Text: String Patterns # Java Kotlin // Create a user with valid username (lowercase letters, 5-10 characters) User user = fixtureMonkey.giveMeBuilder(User.class) .set(\u0026#34;username\u0026#34;, Arbitraries.strings() .withCharRange(\u0026#39;a\u0026#39;, \u0026#39;z\u0026#39;) // Only lowercase letters .ofMinLength(5) // At least 5 characters .ofMaxLength(10)) // At most 10 characters .sample(); // Create a user with valid username (lowercase letters, 5-10 characters) val user = fixtureMonkey.giveMeBuilder\u0026lt;User\u0026gt;() .setExp(User::username, Arbitraries.strings() .withCharRange(\u0026#39;a\u0026#39;, \u0026#39;z\u0026#39;) // Only lowercase letters .ofMinLength(5) // At least 5 characters .ofMaxLength(10)) // At most 10 characters .sample() 3. Selecting from Valid Options # Java Kotlin // Create an order with a valid status Order order = fixtureMonkey.giveMeBuilder(Order.class) .set(\u0026#34;status\u0026#34;, Arbitraries.of( // Randomly pick one of these values OrderStatus.PENDING, OrderStatus.PROCESSING, OrderStatus.SHIPPED)) .sample(); // Create an order with a valid status val order = fixtureMonkey.giveMeBuilder\u0026lt;Order\u0026gt;() .setExp(Order::status, Arbitraries.of( // Randomly pick one of these values OrderStatus.PENDING, OrderStatus.PROCESSING, OrderStatus.SHIPPED)) .sample() 4. Combining Multiple Constraints # Java Kotlin // Create a product with various constraints Product product = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026#34;id\u0026#34;, Arbitraries.longs().greaterOrEqual(1000)) // ID at least 1000 .set(\u0026#34;name\u0026#34;, Arbitraries.strings().withCharRange(\u0026#39;a\u0026#39;, \u0026#39;z\u0026#39;).ofMaxLength(10)) // Name max 10 chars .set(\u0026#34;price\u0026#34;, Arbitraries.bigDecimals() .between(BigDecimal.valueOf(10.0), BigDecimal.valueOf(1000.0))) // Price between 10-1000 .set(\u0026#34;category\u0026#34;, Arbitraries.of(\u0026#34;Electronics\u0026#34;, \u0026#34;Clothing\u0026#34;, \u0026#34;Books\u0026#34;)) // One of these categories .sample(); // Create a product with various constraints val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setExp(Product::id, Arbitraries.longs().greaterOrEqual(1000)) // ID at least 1000 .setExp(Product::name, Arbitraries.strings().withCharRange(\u0026#39;a\u0026#39;, \u0026#39;z\u0026#39;).ofMaxLength(10)) // Name max 10 chars .setExp(Product::price, Arbitraries.bigDecimals() .between(BigDecimal.valueOf(10.0), BigDecimal.valueOf(1000.0))) // Price between 10-1000 .setExp(Product::category, Arbitraries.of(\u0026#34;Electronics\u0026#34;, \u0026#34;Clothing\u0026#34;, \u0026#34;Books\u0026#34;)) // One of these categories .sample() Real-world Example: Testing Age Verification # Let\u0026rsquo;s say you\u0026rsquo;re testing a service that only allows adult members (18+) but has senior discounts (65+):
Java Kotlin @Test void adultMembersCanRegister() { // Create 50 random adult members for testing for (int i = 0; i \u0026lt; 50; i++) { Member member = fixtureMonkey.giveMeBuilder(Member.class) .set(\u0026#34;age\u0026#34;, Arbitraries.integers().between(18, 100)) // Adults only .sample(); boolean isSenior = member.getAge() \u0026gt;= 65; // Test registration logic with various ages MembershipResponse response = membershipService.register(member); assertThat(response.isSuccess()).isTrue(); assertThat(response.hasDiscount()).isEqualTo(isSenior); // Seniors get discounts } } @Test fun adultMembersCanRegister() { // Create 50 random adult members for testing repeat(50) { val member = fixtureMonkey.giveMeBuilder\u0026lt;Member\u0026gt;() .setExp(Member::age, Arbitraries.integers().between(18, 100)) // Adults only .sample() val isSenior = member.age \u0026gt;= 65 // Test registration logic with various ages val response = membershipService.register(member) assertThat(response.isSuccess).isTrue() assertThat(response.hasDiscount).isEqualTo(isSenior) // Seniors get discounts } } Common Arbitrary Methods # Method Purpose Example between(min, max) Values in range Arbitraries.integers().between(1, 100) greaterOrEqual(min) Values â‰¥ min Arbitraries.longs().greaterOrEqual(1000) lessOrEqual(max) Values â‰¤ max Arbitraries.doubles().lessOrEqual(99.9) ofMaxLength(max) Strings with max length Arbitraries.strings().ofMaxLength(10) withCharRange(from, to) Strings with character range Arbitraries.strings().withCharRange('a', 'z') of(values...) Choose from options Arbitraries.of(\u0026quot;Red\u0026quot;, \u0026quot;Green\u0026quot;, \u0026quot;Blue\u0026quot;) Frequently Asked Questions # When should I use Arbitrary instead of fixed values? # Use Arbitrary when:
You want to test with a variety of inputs rather than a single value The exact value doesn\u0026rsquo;t matter, but it needs to follow rules You want to discover edge cases automatically You need to test many different valid inputs Won\u0026rsquo;t random values make my tests inconsistent? # While values are random, they still follow your defined rules. This helps you:
Find bugs that only appear with certain values Ensure your code works with the full range of valid inputs Discover unexpected edge cases If a test fails, you can use Fixture Monkey\u0026rsquo;s @Seed annotation to make it reproducible:
import com.navercorp.fixturemonkey.junit.jupiter.annotation.Seed; import com.navercorp.fixturemonkey.junit.jupiter.extension.FixtureMonkeySeedExtension; import org.junit.jupiter.api.extension.ExtendWith; @ExtendWith(FixtureMonkeySeedExtension.class) class MembershipTest { @Test @Seed(123L) // Use a specific seed for predictable random values void testAdultMembersOnly() { Member member = fixtureMonkey.giveMeBuilder(Member.class) .set(\u0026quot;age\u0026quot;, Arbitraries.integers().between(18, 100)) .sample(); // Your test logic assertThat(membershipService.isEligible(member)).isTrue(); } } With the @Seed annotation, Fixture Monkey will use the specified seed value to generate the same \u0026ldquo;random\u0026rdquo; values every time the test runs. This makes tests with random data completely reproducible.
One of the most useful features of FixtureMonkeySeedExtension is that it automatically logs the seed value when a test fails:
Test Method [MembershipTest#testAdultMembersOnly] failed with seed: 42 You can then add this seed value to your @Seed annotation to consistently reproduce the exact test scenario that failed.
How is this different from setPostCondition()? # setPostCondition() generates any value and then checks if it matches a condition Arbitrary directly generates values that meet the constraints Use Arbitrary when you need more control over the generated values or when setPostCondition() is too slow because it has to discard many invalid values.
Advanced Arbitrary Types (Experimental) # Since version 1.1.12, Fixture Monkey provides specialized arbitrary types for more control over value generation.
CombinableArbitrary.integers() # The CombinableArbitrary.integers() method returns an IntegerCombinableArbitrary that provides specialized methods for integer generation:
Java Kotlin // Generate integers with various constraints Member member = fixtureMonkey.giveMeBuilder(Member.class) .set(\u0026#34;age\u0026#34;, CombinableArbitrary.integers() .withRange(18, 65) // Age between 18-65 .positive()) // Only positive numbers .set(\u0026#34;score\u0026#34;, CombinableArbitrary.integers() .even() // Only even numbers .withRange(0, 100)) // Between 0-100 .sample(); // Generate integers with various constraints val member = fixtureMonkey.giveMeBuilder\u0026lt;Member\u0026gt;() .setExp(Member::age, CombinableArbitrary.integers() .withRange(18, 65) // Age between 18-65 .positive()) // Only positive numbers .setExp(Member::score, CombinableArbitrary.integers() .even() // Only even numbers .withRange(0, 100)) // Between 0-100 .sample() IntegerCombinableArbitrary Methods # Method Description Example withRange(min, max) Generate integers between min and max (inclusive) integers().withRange(1, 100) positive() Generate only positive integers (â‰¥ 1) integers().positive() negative() Generate only negative integers (â‰¤ -1) integers().negative() even() Generate only even integers integers().even() odd() Generate only odd integers integers().odd() Important Note: When multiple constraint methods are chained, the last method wins. For example:
// This will generate negative integers, ignoring the positive() call CombinableArbitrary.integers().positive().negative() // This will generate integers in range 10-50, ignoring the positive() call CombinableArbitrary.integers().positive().withRange(10, 50) CombinableArbitrary.strings() # The CombinableArbitrary.strings() method returns a StringCombinableArbitrary that provides specialized methods for string generation:
Java Kotlin // Generate strings with various character sets and constraints User user = fixtureMonkey.giveMeBuilder(User.class) .set(\u0026#34;username\u0026#34;, CombinableArbitrary.strings() .alphabetic() // Only alphabetic characters .withLength(5, 15)) // Length between 5-15 .set(\u0026#34;password\u0026#34;, CombinableArbitrary.strings() .ascii() // ASCII characters .withMinLength(8)) // At least 8 characters .set(\u0026#34;phoneNumber\u0026#34;, CombinableArbitrary.strings() .numeric() // Only numeric characters .withLength(10, 11)) // 10 or 11 digits .sample(); // Generate strings with various character sets and constraints val user = fixtureMonkey.giveMeBuilder\u0026lt;User\u0026gt;() .setExp(User::username, CombinableArbitrary.strings() .alphabetic() // Only alphabetic characters .withLength(5, 15)) // Length between 5-15 .setExp(User::password, CombinableArbitrary.strings() .ascii() // ASCII characters .withMinLength(8)) // At least 8 characters .setExp(User::phoneNumber, CombinableArbitrary.strings() .numeric() // Only numeric characters .withLength(10, 11)) // 10 or 11 digits .sample() StringCombinableArbitrary Methods # Method Description Example withLength(min, max) Generate strings with length between min and max strings().withLength(5, 10) withMinLength(min) Generate strings with minimum length strings().withMinLength(3) withMaxLength(max) Generate strings with maximum length strings().withMaxLength(20) alphabetic() Generate strings with only alphabetic characters (a-z, A-Z) strings().alphabetic() ascii() Generate strings with only ASCII characters strings().ascii() numeric() Generate strings with only numeric characters (0-9) strings().numeric() korean() Generate strings with only Korean characters (ê°€-íž£) strings().korean() filterCharacter(predicate) Filter individual characters in the string strings().filterCharacter(c -\u0026gt; c != 'x') Important Notes:
Character set methods conflict with each other. When multiple character set methods are chained, the last method wins:
// This will generate Korean characters only, ignoring alphabetic() CombinableArbitrary.strings().alphabetic().korean() Character set methods ignore other configuration methods. When a character set method is called, it creates a new instance that ignores previous configurations:
// The withLength(5, 10) is ignored when alphabetic() is called CombinableArbitrary.strings().withLength(5, 10).alphabetic() Advanced Filtering # Both IntegerCombinableArbitrary and StringCombinableArbitrary support advanced filtering:
Java Kotlin // Filter integers with custom conditions Integer score = CombinableArbitrary.integers() .withRange(0, 100) .filter(n -\u0026gt; n % 5 == 0) // Only multiples of 5 .combined(); // Filter strings with custom character conditions String code = CombinableArbitrary.strings() .withLength(6, 8) .filterCharacter(c -\u0026gt; Character.isUpperCase(c) || Character.isDigit(c)) // Only uppercase letters and digits .combined(); // Filter integers with custom conditions val score = CombinableArbitrary.integers() .withRange(0, 100) .filter { it % 5 == 0 } // Only multiples of 5 .combined() // Filter strings with custom character conditions val code = CombinableArbitrary.strings() .withLength(6, 8) .filterCharacter { it.isUpperCase() || it.isDigit() } // Only uppercase letters and digits .combined() Real-world Example: User Registration Validation # Java Kotlin @Test void validateUserRegistrationWithVariousInputs() { for (int i = 0; i \u0026lt; 100; i++) { User user = fixtureMonkey.giveMeBuilder(User.class) .set(\u0026#34;username\u0026#34;, CombinableArbitrary.strings() .alphabetic() .withLength(3, 20)) // Valid username: 3-20 alphabetic chars .set(\u0026#34;email\u0026#34;, CombinableArbitrary.strings() .ascii() .withLength(5, 50) .filter(s -\u0026gt; s.contains(\u0026#34;@\u0026#34;))) // Simple email validation .set(\u0026#34;age\u0026#34;, CombinableArbitrary.integers() .withRange(13, 120)) // Valid age range .set(\u0026#34;score\u0026#34;, CombinableArbitrary.integers() .withRange(0, 100) .filter(n -\u0026gt; n % 10 == 0)) // Score in multiples of 10 .sample(); // Test with various valid inputs ValidationResult result = userService.validateRegistration(user); assertThat(result.isValid()).isTrue(); } } @Test fun validateUserRegistrationWithVariousInputs() { repeat(100) { val user = fixtureMonkey.giveMeBuilder\u0026lt;User\u0026gt;() .setExp(User::username, CombinableArbitrary.strings() .alphabetic() .withLength(3, 20)) // Valid username: 3-20 alphabetic chars .setExp(User::email, CombinableArbitrary.strings() .ascii() .withLength(5, 50) .filter { it.contains(\u0026#34;@\u0026#34;) }) // Simple email validation .setExp(User::age, CombinableArbitrary.integers() .withRange(13, 120)) // Valid age range .setExp(User::score, CombinableArbitrary.integers() .withRange(0, 100) .filter { it % 10 == 0 }) // Score in multiples of 10 .sample() // Test with various valid inputs val result = userService.validateRegistration(user) assertThat(result.isValid).isTrue() } } Additional Resources # For more details about all available Arbitrary types and methods, see the Jqwik User Guide
`}),e.add({id:25,href:"/v1-1-0/docs/customizing-objects/interface/",title:"Testing with Interfaces",description:`What You\u0026rsquo;ll Learn in This Document # How to generate test data for interfaces How to specify which implementation to use How to customize attributes of interface implementations How to choose between different interface testing approaches The Importance of Interface Testing # In this section, you\u0026rsquo;ll learn why interfaces are crucial in software development and why testing them is valuable.
Interfaces play a vital role in modern software development for several important reasons:`,content:`What You\u0026rsquo;ll Learn in This Document # How to generate test data for interfaces How to specify which implementation to use How to customize attributes of interface implementations How to choose between different interface testing approaches The Importance of Interface Testing # In this section, you\u0026rsquo;ll learn why interfaces are crucial in software development and why testing them is valuable.
Interfaces play a vital role in modern software development for several important reasons:
Why Interfaces Matter in Real Applications # Loose Coupling: Interfaces allow components to establish contracts without needing to know each other\u0026rsquo;s internal details. This reduces dependencies between parts of your application.
Dependency Injection: Interfaces make dependency injection easier, allowing implementations to be substituted with alternatives or mocks during testing.
Flexibility and Extensibility: New implementations can be added without changing the code that uses the interface. This follows the Open/Closed Principle (open for extension, closed for modification).
Better Testability: Interfaces make it possible to replace actual implementations with test doubles, making unit tests much more manageable.
Real-World Example: ProductInfo Interface # Let\u0026rsquo;s look at how interfaces are used in real applications through an example:
// A product info interface with getters public interface ProductInfo { String getName(); // Get the product name BigDecimal getPrice(); // Get the product price String getCategory(); // Get the product category boolean isAvailable(); // Check if product is in stock int getStockQuantity(); // Get the quantity in stock } // A service that uses the interface as method parameters public class ProductService { // Check if a specific quantity can be purchased public boolean canPurchase(ProductInfo productInfo, int quantity) { return productInfo.isAvailable() \u0026amp;\u0026amp; productInfo.getStockQuantity() \u0026gt;= quantity; } // Calculate total price for a quantity public BigDecimal calculateTotal(ProductInfo productInfo, int quantity) { return productInfo.getPrice().multiply(new BigDecimal(quantity)); } // Generate a product summary public String getProductSummary(ProductInfo productInfo) { return String.format(\u0026quot;%s (%s) - $%s, Stock: %d\u0026quot;, productInfo.getName(), productInfo.getCategory(), productInfo.getPrice(), productInfo.getStockQuantity()); } } In this example, ProductService works with any implementation of ProductInfo - it doesn\u0026rsquo;t need to know where the product data comes from.
Why ProductInfo Should Be an Interface # In real applications, product information could come from multiple sources:
Online store products (OnlineProductInfo) Physical store products (StoreProductInfo) Inventory management system products (InventoryProductInfo) Promotional products (PromotionProductInfo) Each source provides the same basic information (name, price, category) but might have additional information or behave differently. For example:
Online products need shipping date information Store products need store location information Inventory products need warehouse location information The ProductService needs to work with the basic product information regardless of where it comes from. Using an interface allows:
The service to be more flexible by not depending on specific implementations New types of product information (e.g., international products) to be added without changing the service code Easier testing since we can test without actual product databases Challenges When Testing Interfaces # Despite the benefits, interfaces present unique testing challenges:
Testing requires concrete implementations, but creating these can be time-consuming Each implementation may need different setups and configurations Test data must match the expected behavior of the interface contract Implementation-specific properties may need customization How Fixture Monkey Helps # Fixture Monkey addresses these challenges by:
Automatically generating implementations for testing Providing flexible ways to customize interface behavior Supporting multiple approaches for different testing scenarios Reducing boilerplate code needed for test implementations Basic Interface Testing Concepts # This section introduces the basic concepts of interface testing with Fixture Monkey, starting with simple examples.
Customizing Interface Properties # Let\u0026rsquo;s start with a simple example. When using Fixture Monkey, you can customize interface properties just like regular classes:
// A simple interface with one method public interface StringSupplier { String getValue(); // This method returns a string } // Create a Fixture Monkey instance with InterfacePlugin // NOTE: InterfacePlugin is required for all interface operations FixtureMonkey fixture = FixtureMonkey.builder() .plugin(new InterfacePlugin()) .build(); // Create and customize a StringSupplier String result = fixture.giveMeBuilder(StringSupplier.class) .set(\u0026quot;value\u0026quot;, \u0026quot;Hello World\u0026quot;) // Set the value property .sample() // Generate an instance .getValue(); // Call the method // result will be \u0026quot;Hello World\u0026quot; In this example, Fixture Monkey automatically creates an implementation of the StringSupplier interface and sets the value property.
Setting Properties on Interface Implementations # When working with interfaces in Fixture Monkey, you can set properties that will be returned by the implemented methods:
// An example interface with multiple methods public interface StringProvider { String getValue(); // Method to get a string value int getNumber(); // Method to get an integer value } // Create a Fixture Monkey instance with InterfacePlugin FixtureMonkey fixture = FixtureMonkey.builder() .plugin(new InterfacePlugin()) .build(); // Create an interface implementation with specified property values StringProvider provider = fixture.giveMeBuilder(StringProvider.class) .set(\u0026quot;value\u0026quot;, \u0026quot;Hello World\u0026quot;) // Set what getValue() will return .set(\u0026quot;number\u0026quot;, 42) // Set what getNumber() will return .sample(); // Use the implementation String value = provider.getValue(); // Returns \u0026quot;Hello World\u0026quot; int number = provider.getNumber(); // Returns 42 Interface Implementation Approaches # This section will teach you three different approaches to creating and working with interface implementations, from simplest to most advanced.
When working with interfaces that have multiple implementations, there are three main approaches, starting with the simplest:
Approach 1: Using Anonymous Implementations (Simplest) # For simple testing scenarios, Fixture Monkey can automatically create anonymous implementations of your interfaces. This approach is useful when:
You need quick implementations for testing without creating actual classes You want to focus on test values rather than implementation details You need different values for each test Here\u0026rsquo;s how to use automatic anonymous implementations with Fixture Monkey:
// A product info interface public interface ProductInfo { String getName(); // Method to get the product name BigDecimal getPrice(); // Method to get the product price String getCategory(); // Method to get the product category boolean isAvailable(); // Method to check if product is in stock int getStockQuantity(); // Method to get the quantity in stock } // Create a Fixture Monkey instance with InterfacePlugin // NOTE: InterfacePlugin is always required when working with interfaces FixtureMonkey fixture = FixtureMonkey.builder() .plugin(new InterfacePlugin()) .build(); // Let Fixture Monkey create an anonymous implementation ProductInfo productInfo = fixture.giveMeBuilder(ProductInfo.class) .set(\u0026quot;name\u0026quot;, \u0026quot;Smartphone\u0026quot;) // Set product name .set(\u0026quot;price\u0026quot;, new BigDecimal(\u0026quot;999.99\u0026quot;)) // Set product price .set(\u0026quot;category\u0026quot;, \u0026quot;Electronics\u0026quot;) // Set product category .set(\u0026quot;available\u0026quot;, true) // Set as available in stock .set(\u0026quot;stockQuantity\u0026quot;, 10) // Set stock quantity to 10 .sample(); // Use in tests ProductService service = new ProductService(); boolean canPurchase = service.canPurchase(productInfo, 5); // Returns true String summary = service.getProductSummary(productInfo); // Returns \u0026quot;Smartphone (Electronics) - $999.99, Stock: 10\u0026quot; The main advantage of this approach is that Fixture Monkey handles all the implementation details. You just define what values the interface methods should return, and Fixture Monkey internally creates an appropriate anonymous implementation.
Approach 2: Using Values.just # If you already have an implementation instance you want to use, you can simply use Values.just. This is useful when you have a specific implementation ready to use.
// An online store implementation public class OnlineProductInfo implements ProductInfo { private String name; // Product name private BigDecimal price; // Product price private String category; // Product category private boolean available; // Product availability private int stockQuantity; // Stock quantity // Constructor public OnlineProductInfo(String name, BigDecimal price, String category, boolean available, int stockQuantity) { this.name = name; this.price = price; this.category = category; this.available = available; this.stockQuantity = stockQuantity; } // Getters @Override public String getName() { return name; } @Override public BigDecimal getPrice() { return price; } @Override public String getCategory() { return category; } @Override public boolean isAvailable() { return available; } @Override public int getStockQuantity() { return stockQuantity; } } // Create a Fixture Monkey instance with InterfacePlugin FixtureMonkey fixture = FixtureMonkey.builder() .plugin(new InterfacePlugin()) .build(); // Create a product instance OnlineProductInfo originalProduct = new OnlineProductInfo( \u0026quot;Laptop\u0026quot;, new BigDecimal(\u0026quot;1999.99\u0026quot;), \u0026quot;Electronics\u0026quot;, true, 5 ); // Use Values.just to use this instance in tests ProductInfo productInfo = fixture.giveMeBuilder(ProductInfo.class) .set(\u0026quot;$\u0026quot;, Values.just(originalProduct)) // Use existing instance .sample(); // Use in tests ProductService service = new ProductService(); BigDecimal total = service.calculateTotal(productInfo, 2); // Returns 3999.98 The main benefit of this approach is simplicity - no additional configuration is needed. However, there\u0026rsquo;s also a limitation - you cannot further customize the implementation properties:
// This won't work - you can't modify properties in the Values.just approach OnlineProductInfo product = (OnlineProductInfo)fixture.giveMeBuilder(ProductInfo.class) .set(\u0026quot;$\u0026quot;, Values.just(originalProduct)) .set(\u0026quot;price\u0026quot;, new BigDecimal(\u0026quot;1499.99\u0026quot;)) // This will have no effect .sample(); Approach 3: Using the interfaceImplements Option (Most Flexible) # For more complex scenarios where you need property customization, you can use the interfaceImplements option. This approach tells Fixture Monkey about all possible implementations of your interface so it can select and customize the right one.
Step 1: Configure Fixture Monkey with Implementations # // A product info interface public interface ProductInfo { String getName(); BigDecimal getPrice(); String getCategory(); boolean isAvailable(); int getStockQuantity(); } // An online store implementation public class OnlineProductInfo implements ProductInfo { private String name; private BigDecimal price; private String category; private boolean available; private int stockQuantity; // Constructor, getters, setters } // A physical store implementation with additional properties public class StoreProductInfo implements ProductInfo { private String name; private BigDecimal price; private String category; private boolean available; private int stockQuantity; private String storeLocation; // Additional property // Constructor, getters, setters public String getStoreLocation() { return storeLocation; } public void setStoreLocation(String storeLocation) { this.storeLocation = storeLocation; } } // Configure Fixture Monkey with implementations FixtureMonkey fixture = FixtureMonkey.builder() .plugin( new InterfacePlugin() .interfaceImplements( ProductInfo.class, // The interface List.of(OnlineProductInfo.class, StoreProductInfo.class) // The implementations ) ) .build(); Step 2: Create Specific Implementations # // Create a StoreProductInfo instance StoreProductInfo storeProduct = (StoreProductInfo)fixture.giveMeBuilder(ProductInfo.class) .set(\u0026quot;$\u0026quot;, new StoreProductInfo()) // Specify which implementation to use .sample(); // Now you can access implementation-specific properties storeProduct.setStoreLocation(\u0026quot;Downtown\u0026quot;); // Set implementation-specific property String location = storeProduct.getStoreLocation(); // \u0026quot;Downtown\u0026quot; Step 3: Customize Implementation Properties # With the interfaceImplements option, you can also modify the properties of the implementation:
// Create and customize a StoreProductInfo StoreProductInfo product = (StoreProductInfo)fixture.giveMeBuilder(ProductInfo.class) .set(\u0026quot;$\u0026quot;, new StoreProductInfo()) // Use StoreProductInfo implementation .set(\u0026quot;name\u0026quot;, \u0026quot;Coffee Maker\u0026quot;) // Set product name .set(\u0026quot;price\u0026quot;, new BigDecimal(\u0026quot;89.99\u0026quot;)) // Set product price .set(\u0026quot;category\u0026quot;, \u0026quot;Kitchen Appliances\u0026quot;) // Set product category .set(\u0026quot;available\u0026quot;, true) // Set as available .set(\u0026quot;stockQuantity\u0026quot;, 15) // Set stock quantity .set(\u0026quot;storeLocation\u0026quot;, \u0026quot;America Mall\u0026quot;) // Set implementation-specific property .sample(); // Use in tests ProductService service = new ProductService(); String summary = service.getProductSummary(product); // Returns \u0026quot;Coffee Maker (Kitchen Appliances) - $89.99, Stock: 15\u0026quot; // Implementation-specific property is set assertEquals(\u0026quot;America Mall\u0026quot;, product.getStoreLocation()); Choosing the Right Approach # This guide will help you decide which approach to use based on your testing requirements.
Here\u0026rsquo;s a simple guide to help you choose the right approach:
When to Use Anonymous Implementations: # When you need quick, one-off implementations for testing When you don\u0026rsquo;t want to create whole classes just for testing When you need custom behavior specific to a single test When you\u0026rsquo;re just getting started with interface testing When to Use Values.just: # When you need a quick solution without additional configuration When you\u0026rsquo;ll only use the implementation once or twice When you already have an instance of the implementation When you don\u0026rsquo;t need to modify properties after creation When to Use interfaceImplements: # When you need to customize implementation properties When you\u0026rsquo;ll use the same set of implementations across multiple tests When you want Fixture Monkey to randomly select among implementations When building more complex testing scenarios Real-World Example: Testing Product Service # This section provides a complete example of testing a service that uses interfaces.
Here\u0026rsquo;s how to use interfaces in a real testing scenario:
@Test void testProductService() { // Configure Fixture Monkey FixtureMonkey fixture = FixtureMonkey.builder() .plugin( new InterfacePlugin() .interfaceImplements( ProductInfo.class, List.of(OnlineProductInfo.class, StoreProductInfo.class) ) ) .build(); // Create a product with specific properties ProductInfo product = fixture.giveMeBuilder(ProductInfo.class) .set(\u0026quot;name\u0026quot;, \u0026quot;Bluetooth Speaker\u0026quot;) // Set product name .set(\u0026quot;price\u0026quot;, new BigDecimal(\u0026quot;79.99\u0026quot;)) // Set product price .set(\u0026quot;category\u0026quot;, \u0026quot;Audio\u0026quot;) // Set product category .set(\u0026quot;available\u0026quot;, true) // Set as available .set(\u0026quot;stockQuantity\u0026quot;, 8) // Set stock quantity .sample(); // Test the product service ProductService service = new ProductService(); // Test various methods boolean canPurchase = service.canPurchase(product, 3); BigDecimal total = service.calculateTotal(product, 3); String summary = service.getProductSummary(product); // Verify results assertTrue(canPurchase); assertEquals(new BigDecimal(\u0026quot;239.97\u0026quot;), total); assertEquals(\u0026quot;Bluetooth Speaker (Audio) - $79.99, Stock: 8\u0026quot;, summary); } Common Issues and Solutions # This section addresses frequently encountered problems when testing interfaces.
Problem: ClassCastException When Accessing Implementation Properties # // ClassCastException will occur if the wrong type is used StoreProductInfo product = (StoreProductInfo)fixture.giveMeBuilder(ProductInfo.class) .sample(); // Default implementation might not be StoreProductInfo Solution: Always specify the implementation when casting is needed:
// Safe approach - explicitly specify implementation type StoreProductInfo product = (StoreProductInfo)fixture.giveMeBuilder(ProductInfo.class) .set(\u0026quot;$\u0026quot;, new StoreProductInfo()) // Explicitly set implementation type .sample(); Problem: Properties Not Being Set # Solution: Make sure you\u0026rsquo;re using the interfaceImplements option if you need to customize properties:
// First configure with interfaceImplements FixtureMonkey fixture = FixtureMonkey.builder() .plugin( new InterfacePlugin() .interfaceImplements( ProductInfo.class, List.of(OnlineProductInfo.class, StoreProductInfo.class) ) ) .build(); // Then you can customize properties StoreProductInfo product = (StoreProductInfo)fixture.giveMeBuilder(ProductInfo.class) .set(\u0026quot;$\u0026quot;, new StoreProductInfo()) .set(\u0026quot;name\u0026quot;, \u0026quot;Wireless Earbuds\u0026quot;) // This will work .set(\u0026quot;storeLocation\u0026quot;, \u0026quot;City Center\u0026quot;) // This will work .sample(); Summary # Interface testing is common in real applications that use dependency injection and interfaces Start with simple anonymous implementations for quick tests Use Values.just when you have a specific implementation ready to use Use interfaceImplements when you need to customize implementation properties Always specify the implementation when you need to access implementation-specific properties `}),e.add({id:26,href:"/v1-1-0/docs/customizing-objects/innerspec/",title:"InnerSpec",description:`What you will learn in this document # How to customize complex object structures more granularly How to effectively handle Map type properties How to create reusable customization specifications Introduction to InnerSpec # In this section, you\u0026rsquo;ll learn the basics of InnerSpec and why it\u0026rsquo;s useful for customizing complex objects.
If you\u0026rsquo;ve learned the basic property modification methods in previous documents, now it\u0026rsquo;s time to learn how to handle more complex object structures.`,content:`What you will learn in this document # How to customize complex object structures more granularly How to effectively handle Map type properties How to create reusable customization specifications Introduction to InnerSpec # In this section, you\u0026rsquo;ll learn the basics of InnerSpec and why it\u0026rsquo;s useful for customizing complex objects.
If you\u0026rsquo;ve learned the basic property modification methods in previous documents, now it\u0026rsquo;s time to learn how to handle more complex object structures.
What is InnerSpec and why use it? # InnerSpec is a powerful tool in Fixture Monkey that helps you customize complex nested objects in a structured way. Think of it as a \u0026ldquo;specification\u0026rdquo; of how you want your objects to be customized.
You might want to use InnerSpec when:
You need to customize deeply nested objects You\u0026rsquo;re working with Map type properties (which can\u0026rsquo;t be easily customized with regular expressions) You want to create reusable customization patterns across multiple tests You need more control over complex object structures An InnerSpec is a type-independent specification for the customizations you wish to apply. Using the setInner() method within ArbitraryBuilder, you can apply customizations defined within an InnerSpec instance into your builder.
A Simple Example # Let\u0026rsquo;s start with a very simple example to understand how InnerSpec works. Imagine you have a Product class:
public class Product { private Long id; private String name; private BigDecimal price; // getters and setters } Here\u0026rsquo;s how you might customize it using InnerSpec:
// Create a Fixture Monkey instance FixtureMonkey fixtureMonkey = FixtureMonkey.create(); // Create an InnerSpec to customize product properties InnerSpec productSpec = new InnerSpec() .property(\u0026quot;id\u0026quot;, 1000L) .property(\u0026quot;name\u0026quot;, \u0026quot;Smartphone\u0026quot;) .property(\u0026quot;price\u0026quot;, new BigDecimal(\u0026quot;499.99\u0026quot;)); // Apply the InnerSpec to a Product builder Product product = fixtureMonkey.giveMeBuilder(Product.class) .setInner(productSpec) .sample(); // Now product has id=1000, name=\u0026quot;Smartphone\u0026quot;, price=499.99 Visual Representation of InnerSpec # InnerSpec allows you to define customizations in a more structured way. Here\u0026rsquo;s a visual representation:
flowchart LR subgraph ArbitraryBuilder AB[\u0026#34;.setInner(innerSpec)\u0026#34;] end subgraph InnerSpec IS1[\u0026#34;.property(\u0026#39;id\u0026#39;, 1000)\u0026#34;] IS2[\u0026#34;.property(\u0026#39;options\u0026#39;, options -\u0026gt; options.size(3))\u0026#34;] IS3[\u0026#34;.property(\u0026#39;nested\u0026#39;, nested -\u0026gt; nested.property(\u0026#39;field\u0026#39;, \u0026#39;value\u0026#39;))\u0026#34;] end AB --\u0026gt;|applies| IS1 AB --\u0026gt;|applies| IS2 AB --\u0026gt;|applies| IS3 note[\u0026#34;InnerSpec can be reused across multiple builders\u0026#34;] InnerSpec --- note When to use InnerSpec vs Regular Expressions # Let\u0026rsquo;s compare how you would customize a nested structure:
Using path expressions: # builder.set(\u0026quot;merchantInfo.id\u0026quot;, 1001) .set(\u0026quot;merchantInfo.name\u0026quot;, \u0026quot;ABC Store\u0026quot;) .set(\u0026quot;merchantInfo.address.city\u0026quot;, \u0026quot;Seoul\u0026quot;) Using InnerSpec (more structured): # InnerSpec merchantSpec = new InnerSpec() .property(\u0026quot;id\u0026quot;, 1001) .property(\u0026quot;name\u0026quot;, \u0026quot;ABC Store\u0026quot;) .property(\u0026quot;address\u0026quot;, address -\u0026gt; address.property(\u0026quot;city\u0026quot;, \u0026quot;Seoul\u0026quot;)); builder.setInner( new InnerSpec().property(\u0026quot;merchantInfo\u0026quot;, merchantInfo -\u0026gt; merchantInfo.inner(merchantSpec)) ); When to choose InnerSpec:
When you need to customize Map properties (not possible with regular expressions) When you want to reuse the same customization patterns across multiple tests When you have complex nested object structures that are clearer to express as nested InnerSpecs When you want more structured and type-independent customizations When to choose regular expressions:
For simple property access and customization For less deeply nested structures When you want more concise code for simple customizations An added advantage of InnerSpec is its ability to customize map properties, unlike normal expressions.
ðŸ’¡ Kotlin EXP is not supported for InnerSpec, as it is designed to be type-independent. Instead, you need to specify the property by its name. Step-by-Step Tutorial: Customizing a Complex Object # Let\u0026rsquo;s walk through a complete example to see how InnerSpec can be used to customize a complex object structure.
Step 1: Define the classes # First, let\u0026rsquo;s define some classes that represent a typical e-commerce domain model:
// A simple Address class public class Address { private String street; private String city; private String country; private String zipCode; // getters and setters } // A store with location and contact information public class Store { private Long id; private String name; private Address address; private Map\u0026lt;String, String\u0026gt; contactInfo; // e.g., \u0026quot;phone\u0026quot; -\u0026gt; \u0026quot;123-456-7890\u0026quot; // getters and setters } // A product sold by the store public class Product { private Long id; private String name; private BigDecimal price; private List\u0026lt;String\u0026gt; categories; private Store store; // getters and setters } Step 2: Create an InnerSpec for Address # Let\u0026rsquo;s start by creating an InnerSpec for the Address:
InnerSpec addressSpec = new InnerSpec() .property(\u0026quot;street\u0026quot;, \u0026quot;123 Main St\u0026quot;) .property(\u0026quot;city\u0026quot;, \u0026quot;New York\u0026quot;) .property(\u0026quot;country\u0026quot;, \u0026quot;USA\u0026quot;) .property(\u0026quot;zipCode\u0026quot;, \u0026quot;10001\u0026quot;); Step 3: Create an InnerSpec for Store with the contactInfo Map # Now, let\u0026rsquo;s create an InnerSpec for the Store, incorporating the Address spec and setting up the contactInfo map:
InnerSpec storeSpec = new InnerSpec() .property(\u0026quot;id\u0026quot;, 500L) .property(\u0026quot;name\u0026quot;, \u0026quot;Electronics Store\u0026quot;) .property(\u0026quot;address\u0026quot;, address -\u0026gt; address.inner(addressSpec)) .property(\u0026quot;contactInfo\u0026quot;, contactInfo -\u0026gt; contactInfo .size(2) // Set map size to 2 entries .entry(\u0026quot;phone\u0026quot;, \u0026quot;123-456-7890\u0026quot;) .entry(\u0026quot;email\u0026quot;, \u0026quot;contact@electronics.com\u0026quot;)); Step 4: Create an InnerSpec for Product with categories List # Finally, let\u0026rsquo;s create an InnerSpec for the Product, incorporating the Store spec and setting up the categories list:
InnerSpec productSpec = new InnerSpec() .property(\u0026quot;id\u0026quot;, 1000L) .property(\u0026quot;name\u0026quot;, \u0026quot;Ultra HD TV\u0026quot;) .property(\u0026quot;price\u0026quot;, new BigDecimal(\u0026quot;1299.99\u0026quot;)) .property(\u0026quot;categories\u0026quot;, categories -\u0026gt; categories .size(3) // Set list size to 3 .listElement(0, \u0026quot;Electronics\u0026quot;) .listElement(1, \u0026quot;TVs\u0026quot;) .listElement(2, \u0026quot;Ultra HD\u0026quot;)) .property(\u0026quot;store\u0026quot;, store -\u0026gt; store.inner(storeSpec)); Step 5: Apply the InnerSpec to create a Product # Now, let\u0026rsquo;s use the InnerSpec to create a Product instance:
// Create a Fixture Monkey instance FixtureMonkey fixtureMonkey = FixtureMonkey.create(); // Apply the InnerSpec to create a Product Product product = fixtureMonkey.giveMeBuilder(Product.class) .setInner(productSpec) .sample(); // Now we have a fully customized Product with all its nested objects Step 6: Verify the result # You can verify that all properties were correctly set:
// Verify Product properties assertEquals(1000L, product.getId()); assertEquals(\u0026quot;Ultra HD TV\u0026quot;, product.getName()); assertEquals(new BigDecimal(\u0026quot;1299.99\u0026quot;), product.getPrice()); // Verify categories list List\u0026lt;String\u0026gt; expectedCategories = List.of(\u0026quot;Electronics\u0026quot;, \u0026quot;TVs\u0026quot;, \u0026quot;Ultra HD\u0026quot;); assertEquals(expectedCategories, product.getCategories()); // Verify Store properties Store store = product.getStore(); assertEquals(500L, store.getId()); assertEquals(\u0026quot;Electronics Store\u0026quot;, store.getName()); // Verify Address properties Address address = store.getAddress(); assertEquals(\u0026quot;123 Main St\u0026quot;, address.getStreet()); assertEquals(\u0026quot;New York\u0026quot;, address.getCity()); assertEquals(\u0026quot;USA\u0026quot;, address.getCountry()); assertEquals(\u0026quot;10001\u0026quot;, address.getZipCode()); // Verify contactInfo map Map\u0026lt;String, String\u0026gt; contactInfo = store.getContactInfo(); assertEquals(2, contactInfo.size()); assertEquals(\u0026quot;123-456-7890\u0026quot;, contactInfo.get(\u0026quot;phone\u0026quot;)); assertEquals(\u0026quot;contact@electronics.com\u0026quot;, contactInfo.get(\u0026quot;email\u0026quot;)); Applying InnerSpec to the ArbitraryBuilder # To apply your pre-defined InnerSpec to the builder, use the setInner() method as shown below:
Java Kotlin InnerSpec innerSpec = new InnerSpec().property(\u0026#34;id\u0026#34;, 1000); fixtureMonkey.giveMeBuilder(Product.class) .setInner(innerSpec); val innerSpec = InnerSpec().property(\u0026#34;id\u0026#34;, 1000) fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setInner(innerSpec) Customizing properties # property() # Similar to the set() method in ArbitraryBuilder, you can customize a property by specifying its name and providing the desired value.
ðŸš¨ Fixture Monkey expressions such as refering elements (\`[]\`) or nested fields(\`.\`) are not allowed as the property name. Only the property name itself is allowed. Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;id\u0026#34;, 1000); val innerSpec = InnerSpec() .property(\u0026#34;id\u0026#34;, 1000) size(), minSize(), maxSize() # size(), minSize(), and maxSize() can be used to specify the size of the property.
As previously mentioned, InnerSpec defines customizations in a nested manner. You can first select the container property using property() and then proceed to define an innerSpec consumer to set the size.
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;options\u0026#34;, options -\u0026gt; options.size(5)); // size:5 InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;options\u0026#34;, options -\u0026gt; options.size(3, 5)); // minSize:3, maxSize:5 InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;options\u0026#34;, options -\u0026gt; options.minSize(3)); // minSize:3 InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;options\u0026#34;, options -\u0026gt; options.maxSize(5)); // maxSize:5 val innerSpec = InnerSpec() .property(\u0026#34;options\u0026#34;) { it.size(5) } // size:5 val innerSpec = InnerSpec() .property(\u0026#34;options\u0026#34;) { it.size(3, 5) } // minSize:3, maxSize:5 val innerSpec = InnerSpec() .property(\u0026#34;options\u0026#34;) { it.minSize(3) } // minSize:3 val innerSpec = InnerSpec() .property(\u0026#34;options\u0026#34;) { it.maxSize(5) } // maxSize:5 postCondition() # postCondition() can be used when you require your property to match a specific condition.
ðŸš¨ Using setPostCondition can incur higher costs for narrow conditions. In such cases, it's recommended to use set instead. Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;id\u0026#34;, id -\u0026gt; id.postCondition(Long.class, it -\u0026gt; it \u0026gt; 0)); val innerSpec = InnerSpec() .property(\u0026#34;id\u0026#34;) { it.postCondition(Long::class.java) { it \u0026gt; 0 }} inner() # You can also customize a property using another pre-defined InnerSpec with the help of inner().
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;id\u0026#34;, 1000L); fixtureMonkey.giveMeBuilder(Product.class) .setInner( new InnerSpec() .property(\u0026#34;nestedObject\u0026#34;, nestedObject -\u0026gt; nestedObject.inner(innerSpec)) ); val innerSpec = InnerSpec() .property(\u0026#34;id\u0026#34;, 1000L) fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setInner( InnerSpec() .property(\u0026#34;nestedObject\u0026#34;) { it.inner(innerSpec) } ) Customizing list properties # listElement() # Individual elements within lists can be selected using listElement(). This is equivalent to referencing elements with \u0026ldquo;[n]\u0026rdquo; using expressions.
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;options\u0026#34;, options -\u0026gt; options.listElement(0, \u0026#34;red\u0026#34;)); val innerSpec = InnerSpec() .property(\u0026#34;options\u0026#34;) { it.listElement(0, \u0026#34;red\u0026#34;) } allListElement() # If you wish to set all elements of the list simultaneously, you can use allListElement(). This is equivalent to referencing elements with \u0026ldquo;[*]\u0026rdquo; using expressions.
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;options\u0026#34;, options -\u0026gt; options.allListElement(\u0026#34;red\u0026#34;)); val innerSpec = InnerSpec() .property(\u0026#34;options\u0026#34;) { it.allListElement(\u0026#34;red\u0026#34;) } Customizing map properties # InnerSpec provides special methods for customizing map property entries.
ðŸš¨ Similar to lists, setting a map entry without specifying the size first might lead to no change. Prior to setting a value, ensure that the map property has the intended size. key(), value(), entry() # You can customize map property entries using key(), value(), and entry() methods. Using key() assigns a specified value to the key of a map entry, while the entry\u0026rsquo;s value remains randomized. Similarly, value() assigns a specified value to the map entry\u0026rsquo;s value, while the key becomes randomized. If you want to specify both the key and value at once, you can use entry().
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.key(1000)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.value(\u0026#34;ABC Store\u0026#34;)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.entry(1000, \u0026#34;ABC Store\u0026#34;)); val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.key(1000) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.value(\u0026#34;ABC Store\u0026#34;) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.entry(1000, \u0026#34;ABC Store\u0026#34;) } keys(), values(), entries() # When setting multiple entries within a map, you can use keys(), values(), and entries() to pass multiple values.
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.keys(1000, 1001, 1002)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.values(\u0026#34;ABC Store\u0026#34;, \u0026#34;123 Convenience\u0026#34;, \u0026#34;XYZ Mart\u0026#34;)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.entries(1000, \u0026#34;ABC Store\u0026#34;, 1001, \u0026#34;123 Convenience\u0026#34;, 1002, \u0026#34;XYZ Mart\u0026#34;)); val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.keys(1000, 1001, 1002) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.values(\u0026#34;ABC Store\u0026#34;, \u0026#34;123 Convenience\u0026#34;, \u0026#34;XYZ Mart\u0026#34;) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.entries(1000, \u0026#34;ABC Store\u0026#34;, 1001, \u0026#34;123 Convenience\u0026#34;, 1002, \u0026#34;XYZ Mart\u0026#34;) } allKey(), allValue(), allEntry() # Similar to allListElement(), it is possible to set every entry within the map to the specified value with allKey(), allValue(), and allEntry().
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.allKey(1000)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.allValue(\u0026#34;ABC Store\u0026#34;)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.allEntry(1000, \u0026#34;ABC Store\u0026#34;)); val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.allKey(1000) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.allValue(\u0026#34;ABC Store\u0026#34;) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.allEntry(1000, \u0026#34;ABC Store\u0026#34;) } keyLazy(), valueLazy(), entryLazy() # Similar to the setLazy() method in ArbitraryBuilder, you can pass a Supplier to assign the value. The Supplier will run every time the ArbitraryBuilder with the InnerSpec applied is sampled.
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.keyLazy(this::generateMerchantKey)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.valueLazy(this::generateMerchantValue)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.entryLazy(this::generateMerchantKey, this::generateMerchantValue)); val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.keyLazy(this::generateMerchantKey) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.valueLazy(this::generateMerchantValue) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.entryLazy(this::generateMerchantKey, this::generateMerchantValue) } allKeyLazy(), allValueLazy(), allEntryLazy() # Just as with the allKey() method, you can use allKeyLazy() to apply keyLazy() to every entry within the map. Both allValueLazy() and allEntryLazy() function similarly.
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.allKeyLazy(this::generateMerchantKey)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.allValueLazy(this::generateMerchantValue)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.allEntryLazy(this::generateMerchantKey, this::generateMerchantValue)); val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.allKeyLazy(this::generateMerchantKey) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.allValueLazy(this::generateMerchantValue) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.allEntryLazy(this::generateMerchantKey, this::generateMerchantValue) } Customizing nested Maps # By combining methods within InnerSpec, you can effectively customize maps with map-type keys, map-type values, or both.
Consider the scenario of a nested map structure like the following:
public class Example { Map\u0026lt;Map\u0026lt;String, String\u0026gt;, String\u0026gt; mapByString; Map\u0026lt;String, Map\u0026lt;String, String\u0026gt;\u0026gt; stringByMap; } Setting map-type key # To set a map with a map-type key, you can access the map key using key(), and then further customize it.
general expression Kotlin Exp InnerSpec().property(\u0026#34;mapByString\u0026#34;, m -\u0026gt; m.key(k -\u0026gt; k.entry(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;))); InnerSpec().property(\u0026#34;mapByString\u0026#34;) { m -\u0026gt; m.key { k -\u0026gt; k.entry(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) } } If you need to set the entry itself, access the entry with entry() and further customize the key using InnerSpec, then set the specific value.
general expression Kotlin Exp InnerSpec().property(\u0026#34;mapByString\u0026#34;, m -\u0026gt; m.entry(k -\u0026gt; k.entry(\u0026#34;innerKey\u0026#34;, \u0026#34;innerValue\u0026#34;)), \u0026#34;value\u0026#34;) InnerSpec().property(\u0026#34;mapByString\u0026#34;) { m -\u0026gt; m.entry({ k -\u0026gt; k.entry(\u0026#34;innerKey\u0026#34;, \u0026#34;innerValue\u0026#34;) }, \u0026#34;value\u0026#34;) } Setting map-type value # For a map with a map-type value, access the map value using value(), and then further customize it.
general expression Kotlin Exp InnerSpec().property(\u0026#34;stringByMap\u0026#34;, m -\u0026gt; m.value(v -\u0026gt; v.entry(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;))) InnerSpec().property(\u0026#34;stringByMap\u0026#34;) { m -\u0026gt; m.value { v -\u0026gt; v.entry(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) } } If you need to set the entry itself, access the entry with entry() and further customize the value using InnerSpec, then set the specific key.
general expression Kotlin Exp InnerSpec().property(\u0026#34;stringByMap\u0026#34;, m -\u0026gt; m.entry(\u0026#34;key\u0026#34;, v -\u0026gt; v.entry(\u0026#34;innerKey\u0026#34;, \u0026#34;innerValue\u0026#34;))) InnerSpec().property(\u0026#34;stringByMap\u0026#34;) { m -\u0026gt; m.entry(\u0026#34;key\u0026#34;) {v -\u0026gt; v.entry(\u0026#34;innerKey\u0026#34;, \u0026#34;innerValue\u0026#34;)} } Real-World Use Case: Testing an E-commerce System # Let\u0026rsquo;s look at a practical example where InnerSpec shines - testing a method in an e-commerce system that calculates discounts based on a complex object structure.
The Domain Model # // Order with customer, items, and payment information public class Order { private Long id; private Customer customer; private List\u0026lt;OrderItem\u0026gt; items; private Map\u0026lt;String, PaymentInfo\u0026gt; paymentOptions; private String selectedPaymentMethod; // getters and setters } public class Customer { private Long id; private String name; private CustomerType type; // REGULAR, PREMIUM, VIP private LocalDate memberSince; // getters and setters } public class OrderItem { private Long productId; private String productName; private int quantity; private BigDecimal pricePerUnit; // getters and setters } public class PaymentInfo { private PaymentType type; private BigDecimal processingFeePercent; private boolean supportsInstallments; // getters and setters } public enum CustomerType { REGULAR, PREMIUM, VIP } public enum PaymentType { CREDIT_CARD, DEBIT_CARD, BANK_TRANSFER, DIGITAL_WALLET } The Service to Test # public class DiscountService { // Calculates the discount percentage based on order details // - VIP customers get at least 10% discount // - Premium customers get 5% discount // - Orders with more than 5 items get additional 3% discount // - Orders over $500 get additional 5% discount // - Payment method can add 1-2% discount depending on type public BigDecimal calculateDiscountPercentage(Order order) { // Implementation details... } } Creating a Test with InnerSpec # @Test public void testVipCustomerWithLargeOrderGetsMaxDiscount() { // Create a Fixture Monkey instance FixtureMonkey fixtureMonkey = FixtureMonkey.create(); // Create Customer InnerSpec InnerSpec customerSpec = new InnerSpec() .property(\u0026quot;id\u0026quot;, 500L) .property(\u0026quot;name\u0026quot;, \u0026quot;John Doe\u0026quot;) .property(\u0026quot;type\u0026quot;, CustomerType.VIP) .property(\u0026quot;memberSince\u0026quot;, LocalDate.of(2020, 1, 1)); // Create OrderItems InnerSpec (for multiple items) InnerSpec orderItemsSpec = new InnerSpec() .property(\u0026quot;items\u0026quot;, items -\u0026gt; items .size(6) // 6 items for additional discount .allListElement(item -\u0026gt; item .property(\u0026quot;pricePerUnit\u0026quot;, new BigDecimal(\u0026quot;100.00\u0026quot;)) .property(\u0026quot;quantity\u0026quot;, 1) ) ); // Create PaymentInfo InnerSpec InnerSpec paymentInfoSpec = new InnerSpec() .property(\u0026quot;paymentOptions\u0026quot;, options -\u0026gt; options .size(2) .entry(\u0026quot;creditCard\u0026quot;, creditCard -\u0026gt; creditCard .property(\u0026quot;type\u0026quot;, PaymentType.CREDIT_CARD) .property(\u0026quot;processingFeePercent\u0026quot;, new BigDecimal(\u0026quot;2.5\u0026quot;)) .property(\u0026quot;supportsInstallments\u0026quot;, true) ) .entry(\u0026quot;digitalWallet\u0026quot;, digitalWallet -\u0026gt; digitalWallet .property(\u0026quot;type\u0026quot;, PaymentType.DIGITAL_WALLET) .property(\u0026quot;processingFeePercent\u0026quot;, new BigDecimal(\u0026quot;1.0\u0026quot;)) .property(\u0026quot;supportsInstallments\u0026quot;, false) ) ); // Combine all specs into the Order spec InnerSpec orderSpec = new InnerSpec() .property(\u0026quot;id\u0026quot;, 1000L) .property(\u0026quot;customer\u0026quot;, customer -\u0026gt; customer.inner(customerSpec)) .inner(orderItemsSpec) // Merge the items spec .inner(paymentInfoSpec) // Merge the payment info spec .property(\u0026quot;selectedPaymentMethod\u0026quot;, \u0026quot;digitalWallet\u0026quot;); // Choose digital wallet for max discount // Create the Order using the combined spec Order order = fixtureMonkey.giveMeBuilder(Order.class) .setInner(orderSpec) .sample(); // Test the discount service DiscountService discountService = new DiscountService(); BigDecimal discount = discountService.calculateDiscountPercentage(order); // VIP (10%) + Items\u0026gt;5 (3%) + Order\u0026gt;$500 (5%) + Digital Wallet (2%) = 20% assertEquals(new BigDecimal(\u0026quot;20.00\u0026quot;), discount); } This real-world example demonstrates how InnerSpec makes it easy to create complex test scenarios with deeply nested objects, lists, and maps - all in a reusable, structured manner.
Useful Patterns and Techniques # Two Ways to Handle Nested Objects # There are two valid approaches when working with nested objects in InnerSpec:
Approach 1: Directly Passing an InnerSpec Object
You can directly pass a created InnerSpec object to the property() method:
// Approach 1: Directly passing an InnerSpec object InnerSpec addressSpec = new InnerSpec() .property(\u0026quot;street\u0026quot;, \u0026quot;123 Main St\u0026quot;) .property(\u0026quot;zipCode\u0026quot;, \u0026quot;12345\u0026quot;); // Directly pass the InnerSpec object as value to property() method InnerSpec personSpec = new InnerSpec() .property(\u0026quot;name\u0026quot;, \u0026quot;John Doe\u0026quot;) .property(\u0026quot;address\u0026quot;, addressSpec); // Directly passing the InnerSpec object This approach is concise and intuitive, making it suitable for simple nested structures.
Approach 2: Using the inner() Method
Alternatively, you can apply a nested InnerSpec using a lambda and the inner() method:
// Approach 2: Using the inner() method InnerSpec addressSpec = new InnerSpec() .property(\u0026quot;street\u0026quot;, \u0026quot;123 Main St\u0026quot;) .property(\u0026quot;zipCode\u0026quot;, \u0026quot;12345\u0026quot;); // Use lambda and inner() method to define nested structure InnerSpec personSpec = new InnerSpec() .property(\u0026quot;name\u0026quot;, \u0026quot;John Doe\u0026quot;) .property(\u0026quot;address\u0026quot;, address -\u0026gt; address .inner(addressSpec) // Advantage of this approach: you can apply additional customization here .property(\u0026quot;additionalField\u0026quot;, \u0026quot;extra information\u0026quot;) ); Both approaches work, but approach 2 is generally preferred because it offers more flexibility when dealing with complex nested objects, allowing for additional customization as shown in the example above.
Tip for beginners: Start with approach 1 for simplicity, and move to approach 2 when you need more complex nested structures or additional property settings.
Common Mistakes and Solutions # Here are some common issues beginners face when using InnerSpec and how to solve them:
1. Not Setting Collection Size First # Problem: If you try to add elements to a list or map without setting its size first, your changes may not be applied.
// Incorrect approach: InnerSpec innerSpec = new InnerSpec() .property(\u0026quot;options\u0026quot;, options -\u0026gt; options.listElement(0, \u0026quot;red\u0026quot;)); // Result: options list might be empty or not the expected size // For maps: InnerSpec innerSpec = new InnerSpec() .property(\u0026quot;merchantInfo\u0026quot;, merchantInfo -\u0026gt; merchantInfo.entry(1000, \u0026quot;ABC Store\u0026quot;)); // Result: entry might not be added to the merchantInfo map Solution: Always set the collection size before setting elements:
// Correct approach: InnerSpec innerSpec = new InnerSpec() .property(\u0026quot;options\u0026quot;, options -\u0026gt; options .size(1) // Set size first - important! .listElement(0, \u0026quot;red\u0026quot;) ); // For maps: InnerSpec innerSpec = new InnerSpec() .property(\u0026quot;merchantInfo\u0026quot;, merchantInfo -\u0026gt; merchantInfo .size(1) // Set size first - important! .entry(1000, \u0026quot;ABC Store\u0026quot;) ); 2. Map Key/Value Type Mismatch # Problem: You\u0026rsquo;ll get errors if the types of keys or values you\u0026rsquo;re trying to set don\u0026rsquo;t match the actual map types.
// When the map type is Map\u0026lt;Long, String\u0026gt;: InnerSpec innerSpec = new InnerSpec() .property(\u0026quot;merchantInfo\u0026quot;, merchantInfo -\u0026gt; merchantInfo .size(1) .entry(\u0026quot;key is a string\u0026quot;, \u0026quot;ABC Store\u0026quot;) // Error: Key should be Long but using String ); Solution: Check and match the map\u0026rsquo;s key and value types correctly:
// Correct approach: InnerSpec innerSpec = new InnerSpec() .property(\u0026quot;merchantInfo\u0026quot;, merchantInfo -\u0026gt; merchantInfo .size(1) .entry(1000L, \u0026quot;ABC Store\u0026quot;) // Using Long type for key ); 3. Confusing Lambda Syntax in Kotlin # Problem: The nested lambda expression syntax in Kotlin can be confusing.
Solution: In Kotlin, use curly braces to define lambdas and indent code blocks for clarity:
// Clear Kotlin syntax: val innerSpec = InnerSpec() .property(\u0026quot;options\u0026quot;) { it // Lambda starts with curly brace .size(3) .listElement(0, \u0026quot;red\u0026quot;) .listElement(1, \u0026quot;green\u0026quot;) .listElement(2, \u0026quot;blue\u0026quot;) } // Lambda ends When using nested lambdas, make them more readable with proper indentation and comments:
val spec = InnerSpec() .property(\u0026quot;person\u0026quot;) { person -\u0026gt; // Outer lambda person.property(\u0026quot;address\u0026quot;) { address -\u0026gt; // Nested lambda address .property(\u0026quot;city\u0026quot;, \u0026quot;New York\u0026quot;) .property(\u0026quot;zipCode\u0026quot;, \u0026quot;10001\u0026quot;) } } Avoiding these common mistakes will help you customize complex objects more easily with InnerSpec.
`}),e.add({id:27,href:"/v1-1-0/docs/fixture-monkey-options/",title:"Fixture Monkey Options",description:"",content:""}),e.add({id:28,href:"/v1-1-0/docs/fixture-monkey-options/overview/",title:"Overview",description:`When you\u0026rsquo;re starting with Fixture Monkey, using options can seem overwhelming. This guide helps you understand how to navigate the options and where to start.
Options vs ArbitraryBuilder API # There are two main ways to configure test data in Fixture Monkey:
Options
Set during FixtureMonkey instance creation Define global rules that apply to all test data generation Reusable configurations ArbitraryBuilder API
Set during individual test data creation One-time settings needed for specific test cases More fine-grained control Example:`,content:`When you\u0026rsquo;re starting with Fixture Monkey, using options can seem overwhelming. This guide helps you understand how to navigate the options and where to start.
Options vs ArbitraryBuilder API # There are two main ways to configure test data in Fixture Monkey:
Options
Set during FixtureMonkey instance creation Define global rules that apply to all test data generation Reusable configurations ArbitraryBuilder API
Set during individual test data creation One-time settings needed for specific test cases More fine-grained control Example:
// Using options - applies to all Product instances FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .defaultNotNull(true) // Set all fields to non-null .register(Product.class, fm -\u0026gt; fm.giveMeBuilder(Product.class) .size(\u0026quot;items\u0026quot;, 3)) // items always has 3 elements .build(); // Using ArbitraryBuilder API - applies only to this test Product specificProduct = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026quot;name\u0026quot;, \u0026quot;Test Product\u0026quot;) // Set name just for this test .set(\u0026quot;price\u0026quot;, 1000) // Set price just for this test .sample(); Why Should You Use Options? # There are important reasons to use options:
1. Test Data Consistency # Problem: Need to apply the same rules across multiple tests // Without options - need to repeat settings in every test Product product1 = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026quot;price\u0026quot;, Arbitraries.longs().greaterThan(0)) .sample(); Product product2 = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026quot;price\u0026quot;, Arbitraries.longs().greaterThan(0)) .sample(); // With options - set once, apply everywhere FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .register(Product.class, fm -\u0026gt; fm.giveMeBuilder(Product.class) .set(\u0026quot;price\u0026quot;, Arbitraries.longs().greaterThan(0))) .build(); Product product1 = fixtureMonkey.giveMeOne(Product.class); // Automatically positive price Product product2 = fixtureMonkey.giveMeOne(Product.class); // Automatically positive price 2. Test Maintainability # Problem: Need to modify all tests when rules change // Using options - manage rules in one place public class TestConfig { public static FixtureMonkey createFixtureMonkey() { return FixtureMonkey.builder() .defaultNotNull(true) .register(Product.class, fm -\u0026gt; fm.giveMeBuilder(Product.class) .set(\u0026quot;price\u0026quot;, Arbitraries.longs().greaterThan(0)) .set(\u0026quot;stock\u0026quot;, Arbitraries.integers().greaterThan(0))) .register(Order.class, fm -\u0026gt; fm.giveMeBuilder(Order.class) // Add orderRules() builder chaining here ) .build(); } } 3. Domain Rule Application # Problem: Need to apply business rules to test data // Applying domain rules through options FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .register(Order.class, fm -\u0026gt; fm.giveMeBuilder(Order.class) .thenApply((order, b) -\u0026gt; { b.set(\u0026quot;totalAmount\u0026quot;, order.getItems().stream() .mapToInt(Item::getPrice) .sum() ); }) ) .build(); Most Common Options for Beginners # Here are the essential options you\u0026rsquo;ll likely need first:
1. defaultNotNull Option - Preventing null Values # The defaultNotNull option ensures that properties not explicitly marked as nullable (with annotations like @Nullable in Java or ? in Kotlin) will not be null. This is useful when you want to avoid null-related issues in your tests.
Java Kotlin @Test void testDefaultNotNullOption() { // Create a FixtureMonkey instance with defaultNotNull option FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .defaultNotNull(true) // This option ensures properties without @Nullable annotation won\u0026#39;t be null .build(); // Generate a Product - all properties without annotations will be non-null Product product = fixtureMonkey.giveMeOne(Product.class); assertThat(product.getProductName()).isNotNull(); assertThat(product.getPrice()).isNotNull(); assertThat(product.getCategory()).isNotNull(); } @Test fun testDefaultNotNullOption() { // Create a FixtureMonkey instance with defaultNotNull option val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .defaultNotNull(true) // This option ensures properties without ? marker won\u0026#39;t be null .build() // Generate a Product - all non-nullable properties will be non-null val product = fixtureMonkey.giveMeOne\u0026lt;Product\u0026gt;() assertThat(product.productName).isNotNull() assertThat(product.price).isNotNull() assertThat(product.category).isNotNull() } 2. javaTypeArbitraryGenerator Option - Controlling Basic Type Generation # The javaTypeArbitraryGenerator option allows you to customize how basic Java types (String, Integer, etc.) are generated. This option is applied through the JqwikPlugin, which integrates Fixture Monkey with the Jqwik property-based testing library.
Java Kotlin @Test void testJavaTypeArbitraryGeneratorOption() { // Create a FixtureMonkey with custom string generation FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin( new JqwikPlugin() // JqwikPlugin provides integration with the Jqwik library .javaTypeArbitraryGenerator(new JavaTypeArbitraryGenerator() { @Override public StringArbitrary strings() { // Customize to generate strings with only alphabetic characters return Arbitraries.strings().alpha().ofLength(10); } }) ) .build(); // All generated strings will be 10-character alphabetic strings String generatedString = fixtureMonkey.giveMeOne(String.class); assertThat(generatedString).hasSize(10); assertThat(generatedString).matches(\u0026#34;[a-zA-Z]+\u0026#34;); } @Test fun testJavaTypeArbitraryGeneratorOption() { // Create a FixtureMonkey with custom string generation val fixtureMonkey = FixtureMonkey.builder() .plugin( JqwikPlugin() // JqwikPlugin provides integration with the Jqwik library .javaTypeArbitraryGenerator(object : JavaTypeArbitraryGenerator { override fun strings(): StringArbitrary { // Customize to generate strings with only alphabetic characters return Arbitraries.strings().alpha().ofLength(10) } }) ) .build() // All generated strings will be 10-character alphabetic strings val generatedString = fixtureMonkey.giveMeOne\u0026lt;String\u0026gt;() assertThat(generatedString).hasSize(10) assertThat(generatedString).matches(\u0026#34;[a-zA-Z]+\u0026#34;) } 3. register Option - Setting Type-Specific Default Rules # The register option allows you to configure default settings for specific types. This is useful when you have consistent requirements for a class across multiple tests.
Java Kotlin @Test void testRegisterOption() { // Create a FixtureMonkey with defaults for the Product class FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .register( Product.class, fm -\u0026gt; fm.giveMeBuilder(Product.class) .set(\u0026#34;price\u0026#34;, Arbitraries.longs().greaterThan(0)) // Allow only positive prices .set(\u0026#34;category\u0026#34;, \u0026#34;Electronics\u0026#34;) // Fixed category ) .build(); // All Products will have positive prices and \u0026#39;Electronics\u0026#39; category Product product = fixtureMonkey.giveMeOne(Product.class); assertThat(product.getPrice()).isPositive(); assertThat(product.getCategory()).isEqualTo(\u0026#34;Electronics\u0026#34;); } @Test fun testRegisterOption() { // Create a FixtureMonkey with defaults for the Product class val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .register(Product::class.java) { builder -\u0026gt; builder.giveMeBuilder\u0026lt;Product\u0026gt;() .set(\u0026#34;price\u0026#34;, Arbitraries.longs().greaterThan(0)) // Allow only positive prices .set(\u0026#34;category\u0026#34;, \u0026#34;Electronics\u0026#34;) // Fixed category } .build() // All Products will have positive prices and \u0026#39;Electronics\u0026#39; category val product = fixtureMonkey.giveMeOne\u0026lt;Product\u0026gt;() assertThat(product.price).isPositive() assertThat(product.category).isEqualTo(\u0026#34;Electronics\u0026#34;) } 4. plugin Option - Adding Extended Functionality # The plugin option allows you to integrate additional features provided by various plugins that Fixture Monkey offers. This option is essential when working with specific frameworks or libraries.
Java Kotlin @Test void testPluginOption() { // Create a FixtureMonkey with Jackson plugin for JSON support FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) // Add support for Jackson annotations .build(); // Now you can create objects with proper Jackson annotation support JsonProduct product = fixtureMonkey.giveMeOne(JsonProduct.class); // Jackson annotations on JsonProduct will be respected // (e.g., @JsonProperty, @JsonIgnore, etc.) } @Test fun testPluginOption() { // Create a FixtureMonkey with Jackson plugin for JSON support val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) // Support for Kotlin features .plugin(JacksonPlugin()) // Add support for Jackson annotations .build() // Now you can create objects with proper Jackson annotation support val product = fixtureMonkey.giveMeOne\u0026lt;JsonProduct\u0026gt;() // Jackson annotations on JsonProduct will be respected // (e.g., @JsonProperty, @JsonIgnore, etc.) } 5. defaultArbitraryContainerInfoGenerator Option - Controlling Container Sizes # The defaultArbitraryContainerInfoGenerator option allows you to control the size of generated container types such as lists, sets, and maps. This option is useful when you need containers of specific sizes in your tests.
Java Kotlin @Test void testContainerSizeOption() { // Create a FixtureMonkey with fixed container sizes FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .defaultArbitraryContainerInfoGenerator(context -\u0026gt; new ArbitraryContainerInfo(3, 3)) // All containers will have exactly 3 elements .build(); // Generate a list with exactly 3 elements List\u0026lt;String\u0026gt; stringList = fixtureMonkey.giveMeOne(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {}); assertThat(stringList).hasSize(3); // Generate a map with exactly 3 entries Map\u0026lt;Integer, String\u0026gt; map = fixtureMonkey.giveMeOne(new TypeReference\u0026lt;Map\u0026lt;Integer, String\u0026gt;\u0026gt;() {}); assertThat(map).hasSize(3); } @Test fun testContainerSizeOption() { // Create a FixtureMonkey with fixed container sizes val fixtureMonkey = FixtureMonkey.builder() .defaultArbitraryContainerInfoGenerator { context -\u0026gt; ArbitraryContainerInfo(3, 3) } // All containers will have exactly 3 elements .build() // Generate a list with exactly 3 elements val stringList: List\u0026lt;String\u0026gt; = fixtureMonkey.giveMeOne() assertThat(stringList).hasSize(3) // Generate a map with exactly 3 entries val map: Map\u0026lt;Int, String\u0026gt; = fixtureMonkey.giveMeOne() assertThat(map).hasSize(3) } Which Option to Use When? # Here\u0026rsquo;s a simple guide to help you choose which option to use:
Option When to Use defaultNotNull(true) When you want to ensure test objects have no null values (except explicitly nullable properties) javaTypeArbitraryGenerator When you need to customize how basic types like strings or numbers are generated register(Class, function) When you need consistent default values or constraints for a specific class plugin(Plugin) When you need additional features like support for frameworks (Jackson, Kotlin, etc.) defaultArbitraryContainerInfoGenerator When you need to control the size of generated containers (lists, sets, maps, etc.) Understanding Option Scope # There are important points to understand when using options:
Instance Scope Options only apply to the FixtureMonkey instance they\u0026rsquo;re configured on You can create multiple instances with different settings // Test settings FixtureMonkey testFixture = FixtureMonkey.builder() .defaultNotNull(true) .build(); // Development settings FixtureMonkey devFixture = FixtureMonkey.builder() .defaultNotNull(false) .build(); Option Priority More specific options take precedence over general ones Later options override earlier ones FixtureMonkey fixture = FixtureMonkey.builder() .defaultNotNull(true) // All fields non-null .register(Product.class, fm -\u0026gt; fm.giveMeBuilder(Product.class) .setNull(\u0026quot;description\u0026quot;)) // Allow null for description only .build(); Next Steps # We recommend following this learning path to make the most of Fixture Monkey:
Start here: Overview (this page) - Understand what options are and how they\u0026rsquo;re structured Next step for beginners: Essential Options for Beginners - Learn the most commonly used options for everyday testing needs Understand the concepts: Option Concepts - Gain deeper knowledge of how options work internally and learn key terminology Advanced features: Advanced Options for Experts - Explore options for complex testing scenarios `}),e.add({id:29,href:"/v1-1-0/docs/plugins/simple-value-plugin/",title:"Simple Value Plugin",description:"",content:""}),e.add({id:30,href:"/v1-1-0/docs/fixture-monkey-options/essential-options-for-beginners/",title:"Essential Options for Beginners",description:`When first starting with Fixture Monkey, understanding just a few key options can help you generate the test data you need without being overwhelmed by complexity. This guide focuses on the most essential options for beginners.
For a comprehensive understanding of core concepts like Introspectors, Generators, and Property types, see Concepts. When you\u0026rsquo;re ready for more advanced options, refer to Advanced Options for Experts.
General Builder Options # These options are set when creating your FixtureMonkey instance:`,content:`When first starting with Fixture Monkey, understanding just a few key options can help you generate the test data you need without being overwhelmed by complexity. This guide focuses on the most essential options for beginners.
For a comprehensive understanding of core concepts like Introspectors, Generators, and Property types, see Concepts. When you\u0026rsquo;re ready for more advanced options, refer to Advanced Options for Experts.
General Builder Options # These options are set when creating your FixtureMonkey instance:
FixtureMonkey fixtureMonkey = FixtureMonkey.builder() // Add options here .build(); Default NotNull Setting # By default, Fixture Monkey can generate null values for some fields. To have all fields with non-null values:
.defaultNotNull(true) This is one of the most useful options to start with as it helps prevent NullPointerException in your tests.
Default value: false - Without this setting, Fixture Monkey can generate null values for fields not marked with @NotNull annotation.
When to use: When you want to ensure all fields are non-null to avoid NullPointerExceptions.
Nullable Containers # Controls whether collection types (List, Set, Map, etc.) can be null:
.nullableContainer(false) Default value: false - By default, collection types cannot be null. Setting this to true allows collection types to be null.
When to use: When you need to allow or disallow null for entire container types.
Nullable Elements # Controls whether elements inside collections can be null:
.nullableElement(false) Default value: false - By default, elements inside collections cannot be null. Setting this to true allows elements in collections to be null.
When to use: When you want to control nullability of individual elements within collections.
Container Size Configuration # Control default size for collections and maps:
// Configure all containers to have between 2 and 5 elements .defaultArbitraryContainerInfoGenerator( new DefaultArbitraryContainerInfoGenerator(2, 5) ) Default value: By default, containers have between 0 and 3 elements.
When to use: When you need consistent collection sizes across your tests, or when you want to control the volume of generated data.
For more advanced container handling options, see Container Types vs. Object Types in the Concepts documentation.
Type Configuration # You can configure how specific types are generated:
// Configure how String values are generated .register(String.class, fm -\u0026gt; fm.giveMeBuilder(String.class) .set(\u0026quot;$\u0026quot;, \u0026quot;Default String\u0026quot;) ) // Configure how Integer values are generated .register(Integer.class, fm -\u0026gt; fm.giveMeBuilder(Integer.class) .set(\u0026quot;$\u0026quot;, Arbitraries.integers().between(1, 100)) ) // Configure how BigDecimal values are generated .register(BigDecimal.class, fm -\u0026gt; fm.giveMeBuilder(BigDecimal.class) .set(\u0026quot;$\u0026quot;, new BigDecimal(\u0026quot;10.00\u0026quot;)) ) // Configure how List\u0026lt;String\u0026gt; values are generated .register(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {}, fm -\u0026gt; fm.giveMeBuilder(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {}) .size(\u0026quot;$\u0026quot;, 1, 5) ) When to use: When you need to apply custom generation rules for specific types.
For a deeper understanding of the type registration system, see Type Registration System in the Concepts documentation.
JqwikPlugin Options # Fixture Monkey provides JqwikPlugin that integrates with the Jqwik library. This plugin offers several options to control how basic types are generated:
Customizing String, Number, and Boolean Generation # You can customize how Strings, Numbers, Booleans and other primitive types are generated:
FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin( new JqwikPlugin() .javaTypeArbitraryGenerator(new JavaTypeArbitraryGenerator() { @Override public StringArbitrary strings() { // Generate only 10-character alphabetic strings return Arbitraries.strings().alpha().ofLength(10); } @Override public IntegerArbitrary integers() { // Generate only positive integers return Arbitraries.integers().greaterOrEqual(1); } @Override public DoubleArbitrary doubles() { // Generate decimals between 0 and 1 return Arbitraries.doubles().between(0.0, 1.0); } }) ) .build(); Default behavior: Without customization, Fixture Monkey generates random values across the entire range of each type. When to use: When you need test data to follow specific patterns or ranges, such as positive numbers only or formatted strings.
Customizing Date and Time Generation # Similar to basic types, you can control how date and time values are generated:
.plugin( new JqwikPlugin() .javaTimeTypeArbitraryGenerator(new JavaTimeTypeArbitraryGenerator() { @Override public Arbitrary\u0026lt;LocalDate\u0026gt; localDates() { // Generate only dates within the next 30 days LocalDate today = LocalDate.now(); return Arbitraries.dates() .between(today, today.plusDays(30)); } @Override public Arbitrary\u0026lt;LocalTime\u0026gt; localTimes() { // Generate only business hours (9 AM to 5 PM) return Arbitraries.times() .between(LocalTime.of(9, 0), LocalTime.of(17, 0)); } }) ) Default behavior: Random dates and times across their entire possible ranges. When to use: When you need realistic date ranges or specific time patterns for your tests.
For more advanced customization of types and generators, see Advanced Options for Experts.
Custom Null Probability # Control how often null values are generated:
// Configure default null injection behavior (10% chance of null) FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .defaultNullInjectGenerator(context -\u0026gt; 0.1) .build(); // Configure type-specific null injection behavior (20% chance of null for Strings) FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .pushAssignableTypeNullInjectGenerator( String.class, context -\u0026gt; 0.2 ) .build(); Default value: By default, null generation probability is determined by the property\u0026rsquo;s annotations, typically 0 for fields with @NotNull and a non-zero value otherwise.
When to use: When you need to control how frequently null values appear in your test fixtures, either globally or for specific types.
Excluding Types from Generation # Control which types or packages should be excluded from test data generation:
// Exclude a specific class .addExceptGenerateClass(MyInternalClass.class) // Exclude multiple classes .addExceptGenerateClasses(ClassA.class, ClassB.class) // Exclude an entire package .addExceptGeneratePackage(\u0026quot;com.mycompany.internal\u0026quot;) // Exclude based on a custom matcher .pushExceptGenerateType(property -\u0026gt; property.getName().equals(\u0026quot;sensitiveField\u0026quot;)) Default value: None - By default, Fixture Monkey attempts to generate all properties.
When to use: When you want to exclude internal implementation details, sensitive fields, or complex dependencies from test data generation.
Registering Groups of Types # Use registerGroup to register multiple related types at once via a group class or implementation:
// Using a factory group class FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .registerGroup(MyArbitraryFactoryGroup.class) .build(); // Using an implementation of ArbitraryBuilderGroup FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .registerGroup(new MyArbitraryBuilderGroup()) .build(); When to use: When you have several related types with similar generation logic and want to register them together.
Custom Object Introspection # Controls how Fixture Monkey analyzes and understands your objects to generate test data:
// Set a custom introspector for all types FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(new CustomObjectIntrospector()) .build(); // Example: Using a built-in introspector for all types FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(FieldReflectionArbitraryIntrospector.INSTANCE) .build(); Default value: The default introspector depends on the plugins you\u0026rsquo;ve added. Without plugins, it uses field-based introspection.
When to use: When you need to change how Fixture Monkey discovers fields and properties in your classes. For example, if you want to use field-based introspection instead of getter/setter-based introspection, or if you need a custom strategy for handling specific object types.
For a deeper understanding of introspectors and generators, see Generators and Introspectors in the Concepts documentation.
Debugging and Reproducibility Options # These options help with debugging and ensuring test reproducibility:
// Enable detailed logging for generation failures .enableLoggingFail(true) // Set a fixed seed for deterministic test data generation .seed(1234L) Default values:
enableLoggingFail: false - detailed error logs are not shown by default seed: Current system time - making each run use different random values by default When to use:
Enable logging when you need to debug why fixture generation is failing Set a fixed seed when you need reproducible test data across test runs Using Options in Different Scenarios # When you need quick test data and specific values don\u0026rsquo;t matter:
Use the basic builder with defaultNotNull(true) When you need realistic values (e.g., for demos):
Register custom generators for each type Set min/max values for numeric fields When you need to test boundary conditions:
Use .set() for important properties with specific values or constraints Use predicates for complex conditions When you need to generate related data:
Use nested giveMeBuilder calls to create related objects Next Steps # Now that you understand the essential options, you can learn about:
â†’ Option Concepts - Gain deeper knowledge of how options work internally
â†’ JavaBean Validation - Use validation annotations to guide data generation
`}),e.add({id:31,href:"/v1-1-0/docs/plugins/simple-value-plugin/features/",title:"Features",description:`Fixture Monkey generates an arbitrary value to avoid edge case that could cause the problem. It may be useful in some situations, but it is useless in most situations. Especially it is embarrassing for beginners, who expect the readable and valid data.
Fixture Monkey provides a new Plugin SimpleValueJqwikPlugin for beginners, who expect the readable and valid value. It generates a readable and short String and narrow range of Number and Date value.`,content:`Fixture Monkey generates an arbitrary value to avoid edge case that could cause the problem. It may be useful in some situations, but it is useless in most situations. Especially it is embarrassing for beginners, who expect the readable and valid data.
Fixture Monkey provides a new Plugin SimpleValueJqwikPlugin for beginners, who expect the readable and valid value. It generates a readable and short String and narrow range of Number and Date value.
It is compatible with other plugins such as JavaxValidationPlugin, JakartaValidationPlugin. It applies XXValidationPlugin if the property has the validation annotation, applies SimpleValueJqwikPlugin without it.
If you use the custom Plugin to constrain the generated value, the latter plugin would work.
For beginners who want to restrict the generated value, looking at the code of SimpleValueJqwikPlugin is a good start.
Default value # String # The plugin generates a short size of limited String whose length is 0 to 5.
alphabet number some special symbols allowed in HTTP query parameter ., -, _, ~ It can be customised by the options below.
minStringLength maxStringLength characterPredicate Number # The plugin generates a numeric number and decimal number in the range -10000 to 10000.
It can be customised, whether negative or positive, using the options below.
minNumberValue maxNumberValue Date # The plugin generates a Date in the range of last year to next year from today.
It can be customised on a per date basis, using the options below.
minusDaysFromToday plusDaysFromToday Container # The term of Container refers to the implementations of Collection such as List, Set, Iterator Iterable, and Map, Entry. The plugin generates a Container whose size is in the range of 0 to 3.
It can be customised by the options below.
minContainerSize maxContainerSize Plugin # val fixtureMonkey = FixtureMonkey.builder() .plugin(SimpleValueJqwikPlugin()) .build() `}),e.add({id:32,href:"/v1-1-0/docs/fixture-monkey-options/concepts/",title:"Concepts",description:`This document explains the core concepts and terminology of Fixture Monkey\u0026rsquo;s option system. Understanding these concepts will help you navigate and use Fixture Monkey more effectively.
For practical implementation of these concepts, see:
Essential Options for Beginners - Start here if you\u0026rsquo;re new to Fixture Monkey Advanced Options for Experts - Explore more complex options Key Terms to Know # Before diving into detailed concepts, let\u0026rsquo;s understand the fundamental terminology used throughout Fixture Monkey:`,content:`This document explains the core concepts and terminology of Fixture Monkey\u0026rsquo;s option system. Understanding these concepts will help you navigate and use Fixture Monkey more effectively.
For practical implementation of these concepts, see:
Essential Options for Beginners - Start here if you\u0026rsquo;re new to Fixture Monkey Advanced Options for Experts - Explore more complex options Key Terms to Know # Before diving into detailed concepts, let\u0026rsquo;s understand the fundamental terminology used throughout Fixture Monkey:
Term Description Introspection How Fixture Monkey analyzes the structure and properties of objects Arbitrary A generator that produces random values for a specific type Container A structure that holds multiple values, like collections, maps, or arrays Property A characteristic of an object that can hold a value - can be implemented as a field, getter/setter method, or Kotlin property. Properties contain information about their type, annotations, and name. Constraint A rule that limits the range of values that can be generated (e.g., min/max values) Fixture Monkey provides numerous options that can be configured through the FixtureMonkeyBuilder. This page explains core option concepts to help you understand how they work together.
Core Components of Option Architecture # Understanding these core components will help you navigate the options more effectively:
1. Generators and Introspectors # These are the primary components that work together to create objects:
Generator:
Has a broader scope for creating values with specific characteristics Focuses on the \u0026ldquo;what\u0026rdquo; of value generation (unique values, patterns, ranges, etc.) Examples: UniqueArbitraryGenerator In simple terms: Generators are like cookie cutters that determine what shape your test data will take Introspector:
Specifies the concrete method of object creation Focuses on the \u0026ldquo;how\u0026rdquo; of object instantiation (via constructors, factories, etc.) Examples: ConstructorArbitraryIntrospector, FieldReflectionArbitraryIntrospector In simple terms: Introspectors are like bakers who figure out how to actually make your object using the available ingredients For a beginner, you can think of generators as defining \u0026ldquo;what kind of data\u0026rdquo; to create, while introspectors determine \u0026ldquo;how to actually construct\u0026rdquo; the object.
Practical example: When you need to test a payment system with valid credit card numbers, generators help you create properly formatted numbers, while introspectors determine whether to create them through a constructor, builder pattern, or factory method.
For implementation details on generators, see:
Type Configuration in Essential Options Custom Type Registration and Generation in Advanced Options 2. Builder Pattern and Option Chaining # Fixture Monkey uses a builder pattern for configuration. Understanding option application order is important:
FixtureMonkey monkey = FixtureMonkey.builder() .plugin(new KotlinPlugin()) // Applied first .nullableContainer(true) // Applied second .defaultArbitraryContainerSize(3, 5) // Applied third .build(); Options are applied in the order they\u0026rsquo;re defined. Later options can override earlier ones if they target the same settings.
Practical example: If you need to test how your application handles different product lists, you might set a default container size, but override it for specific test cases to test boundary conditions.
3. Option Scoping # Options can be applied at different scopes or levels:
Global Scope:
Applied to all objects generated by the Fixture Monkey instance Set in FixtureMonkeyBuilder Example use case: Setting defaultNotNull(true) to avoid null values throughout your tests Type Scope:
Applied to specific types or interfaces Example: .pushAssignableTypePropertyGenerator(String.class, generator) Example use case: Configuring all String values to follow a specific pattern like email addresses Path Expression Scope:
Applied to specific properties identified by path expressions Example: .register(String.class, fixtureMonkey -\u0026gt; fixtureMonkey.giveMeBuilder(String.class).set(\u0026quot;$\u0026quot;, Arbitraries.strings().ofMinLength(3))) Example use case: Setting a specific property like \u0026ldquo;price\u0026rdquo; to be always positive The more specific scope overrides the more general one - similar to how CSS specificity works if you\u0026rsquo;re familiar with web development.
For practical usage of option scoping, see:
General Builder Options in Essential Options Property Customization in Advanced Options 4. Type Registration System # Fixture Monkey\u0026rsquo;s type registration system determines how to generate values for specific types:
FixtureMonkey monkey = FixtureMonkey.builder() .register(String.class, fixtureMonkey -\u0026gt; fixtureMonkey.giveMeBuilder(String.class) .set(\u0026quot;$\u0026quot;, Arbitraries.strings().ofMinLength(5).ofMaxLength(10))) .register(Integer.class, fixtureMonkey -\u0026gt; fixtureMonkey.giveMeBuilder(Integer.class) .set(\u0026quot;$\u0026quot;, Arbitraries.integers().between(1, 100))) .build(); This registers custom generators for specific types, which can then be used in all objects that contain these types.
Practical example: If your application requires all user IDs to be between 1 and 100, you can register this rule once and all test objects will follow it.
For details on implementing type registration, see:
Type Configuration in Essential Options Custom Type Registration and Generation in Advanced Options 5. Plugin System # Plugins provide pre-configured settings for common use cases:
FixtureMonkey monkey = FixtureMonkey.builder() .plugin(new KotlinPlugin()) .plugin(new JacksonPlugin()) .build(); Plugins can:
Register type-specific generators and introspectors Configure default behaviors Add support for third-party libraries In simple terms: Plugins are like recipe books with pre-configured settings for common scenarios.
Practical example: If you\u0026rsquo;re working with a Kotlin project, the KotlinPlugin automatically configures everything to work well with Kotlin classes, saving you from writing lots of manual configuration.
For plugin usage examples, see:
JqwikPlugin Options in Essential Options Properties and Containers # Fixture Monkey uses a broader concept of property instead of just field when working with objects. This flexibility allows Fixture Monkey to work with various programming paradigms and frameworks.
Properties in Fixture Monkey # A property in Fixture Monkey contains:
Its Type (String, Integer, custom class, etc.) Any Annotations applied to it Its name Fixture Monkey distinguishes between two main property types:
1. ObjectProperty # Represents information about a regular object property, including:
The property itself How the property name is resolved If it\u0026rsquo;s part of a collection, its index Example use in code:
// ObjectProperty in action - setting a value on a specific property Product product = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026quot;name\u0026quot;, \u0026quot;Smartphone\u0026quot;) // ObjectProperty: name .set(\u0026quot;price\u0026quot;, BigDecimal.valueOf(599.99)) // ObjectProperty: price .sample(); 2. ContainerProperty # Represents collections with information about:
The list of element properties Information about the container\u0026rsquo;s size Example use in code:
// ContainerProperty in action - working with a collection List\u0026lt;Product\u0026gt; products = fixtureMonkey.giveMeBuilder(new TypeReference\u0026lt;List\u0026lt;Product\u0026gt;\u0026gt;() {}) .size(3) // Set container size .set(\u0026quot;$[0].name\u0026quot;, \u0026quot;First Product\u0026quot;) // Access first element's property .sample(); Container Types vs. Object Types # Fixture Monkey treats container types (like List, Set, or Map) differently from regular object types. This distinction is important for testing scenarios involving collections.
Why this matters for your tests: Understanding this distinction helps you correctly configure collection sizes, element properties, and uniqueness constraints.
Real-world example:
// Testing a shopping cart with multiple items ShoppingCart cart = fixtureMonkey.giveMeBuilder(ShoppingCart.class) .size(\u0026quot;items\u0026quot;, 3) // ContainerProperty: 3 items in the cart .set(\u0026quot;items[0].productName\u0026quot;, \u0026quot;Special Item\u0026quot;) // First item has a specific name .set(\u0026quot;customer.address.country\u0026quot;, \u0026quot;USA\u0026quot;) // ObjectProperty with nested path .sample(); For deeper details on property handling, see:
Custom Object Introspection in Essential Options Object Property Generators in Advanced Options Container Handling Options in Advanced Options How Options Interact # When Fixture Monkey generates an object:
It first determines which introspector to use for the object The introspector analyzes the object structure For each property, it selects the appropriate generator Property generators create values according to configuration The introspector assembles the final object Options at more specific scopes take precedence over more general ones.
Practical example: If you set a global rule that all numbers should be positive, but then specify that a particular \u0026ldquo;discount\u0026rdquo; field should be negative, the specific rule for the discount field will override the global rule.
Visual Explanation # Here\u0026rsquo;s a simplified view of how these components interact:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ FixtureMonkeyBuilder â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â–¼ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Option Resolution â”‚â—„â”€â”€â”€â”¤ Plugins â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â–¼ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Type/Property Selection â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â–¼ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Introspector â”‚â—„â”€â”€â”€â”€â”€â”¤ Generators â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â–¼ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Generated Object â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Example: Option Interaction # Let\u0026rsquo;s see a more concrete example where multiple options interact:
FixtureMonkey monkey = FixtureMonkey.builder() .plugin(new JavaTimePlugin()) // Global plugin .defaultArbitraryContainerSize(1, 5) // Global container size .nullableContainer(true) // Global container nullability .register(String.class, fixtureMonkey -\u0026gt; fixtureMonkey.giveMeBuilder(String.class) .set(\u0026quot;$\u0026quot;, Arbitraries.strings().ofMinLength(3))) // Type-specific configuration .register( new MatcherOperator\u0026lt;\u0026gt;( property -\u0026gt; property.getName().equals(\u0026quot;price\u0026quot;), // Match any property named \u0026quot;price\u0026quot; fixtureMonkey -\u0026gt; fixtureMonkey.giveMeBuilder(BigDecimal.class) .set(\u0026quot;$\u0026quot;, Arbitraries.bigDecimals().greaterOrEqual(BigDecimal.ZERO)) ) ) // Simple property name matcher .build(); When generating an object:
The JavaTimePlugin configures date/time types Containers are set to have 1-5 elements and can be null All String values have minimum length 3 Any property named \u0026ldquo;price\u0026rdquo; is always non-negative Real-world scenario: This configuration would be useful for testing an e-commerce application where:
You need to test with various product counts (1-5 items) Product descriptions need to be at least 3 characters long Prices must always be positive or zero For examples of complex configuration, see Real-World Advanced Configuration in Advanced Options.
Conclusion # Understanding these concepts will help you:
Configure Fixture Monkey more effectively for your specific testing needs Troubleshoot issues when generators don\u0026rsquo;t work as expected Create complex test data with precise control By leveraging properties, containers, and the option system effectively, you can create more realistic and targeted test data that closely matches your production requirements.
Next Steps # After understanding these concepts, you can:
â†’ Essential Options for Beginners - Learn practical implementation of these concepts
â†’ Advanced Options for Experts - Explore advanced options for complex testing scenarios
â†’ Creating Custom Introspector - Implement your own introspector for special domain requirements
`}),e.add({id:33,href:"/v1-1-0/docs/fixture-monkey-options/advanced-options-for-experts/",title:"Advanced Options for Experts",description:`This guide covers advanced Fixture Monkey options that experienced users can leverage to solve complex testing scenarios.
Note for beginners: If you\u0026rsquo;re new to Fixture Monkey, we recommend starting with the Essential Options for Beginners guide first. The options covered here are more advanced and typically needed for complex use cases.
Make sure you understand the core Concepts before diving into these advanced options.
Table of Contents # Recommended Usage Sequence Performance Optimization Options Custom Type Registration and Generation Default Arbitrary Generator Object Property Generators Container Handling Options Validation \u0026amp; Constraints Property Customization Custom Introspection Settings Expression Strict Mode Real-World Advanced Configuration Common Advanced Testing Scenarios What\u0026rsquo;s Next?`,content:`This guide covers advanced Fixture Monkey options that experienced users can leverage to solve complex testing scenarios.
Note for beginners: If you\u0026rsquo;re new to Fixture Monkey, we recommend starting with the Essential Options for Beginners guide first. The options covered here are more advanced and typically needed for complex use cases.
Make sure you understand the core Concepts before diving into these advanced options.
Table of Contents # Recommended Usage Sequence Performance Optimization Options Custom Type Registration and Generation Default Arbitrary Generator Object Property Generators Container Handling Options Validation \u0026amp; Constraints Property Customization Custom Introspection Settings Expression Strict Mode Real-World Advanced Configuration Common Advanced Testing Scenarios What\u0026rsquo;s Next? Recommended Usage Sequence # Follow this sequence to quickly apply the most common advanced options:
Performance Optimization Options Custom Type Registration and Generation Default Arbitrary Generator Object Property Generators Container Handling Options Validation \u0026amp; Constraints Property Customization Custom Introspection Settings Expression Strict Mode Real-World Advanced Configuration Common Advanced Testing Scenarios Performance Optimization Options # Manipulator Optimizer # Allows customizing or optimizing the sequence of ArbitraryManipulator instances applied during fixture generation. You can implement ManipulatorOptimizer to combine, filter, or reorder manipulators, reducing redundant operations and improving performance for complex object graphs:
// Example custom ManipulatorOptimizer implementation class CustomManipulatorOptimizer implements ManipulatorOptimizer { // Implement combine, filter, or reorder manipulators here } FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .manipulatorOptimizer(new CustomManipulatorOptimizer()) .build(); Default behavior: No manipulator optimizer is applied (uses NoneManipulatorOptimizer).
Adjust Maximum Generation Attempts # Default behavior: 1000 retry attempts. generateMaxTries sets the maximum number of retry attempts when fixture generation fails due to value constraints or expression strict mode. Reducing this can help tests fail fast in worst-case scenarios:
FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .generateMaxTries(50) .build(); Adjust Unique Generation Attempts # Default behavior: 1000 retry attempts. generateUniqueMaxTries sets the maximum number of retry attempts when generating unique elements in collections (e.g., ensuring list or set elements are distinct). Lowering this helps tests fail fast if uniqueness cannot be achieved:
FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .generateUniqueMaxTries(20) .build(); Default behavior: 1000 retry attempts.
When to use: When testing scenarios require unique values in collections and you want generation to fail fast on duplicates.
Streamlining Container Generation # For efficient container (lists, sets, maps) handling:
FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .pushArbitraryContainerInfoGenerator( new MatcherOperator\u0026lt;\u0026gt;( property -\u0026gt; property.getType().isAssignableFrom(List.class), context -\u0026gt; new ArbitraryContainerInfo(2, 10) ) ) .build(); Default behavior: Without customization, Fixture Monkey uses a default container size generator that creates containers with sizes from 0 to 3.
When to use:
When dealing with complex, deeply nested object structures in performance-sensitive tests. When you need different container size rules for different collection types (e.g., lists vs. sets). When you need to control container sizes based on the specific container type or context. For basic container configuration, refer to Container Size Configuration in the Essential Options guide.
Custom Type Registration and Generation # Registering Custom Generators for Specific Types # When you need complete control over how certain types are generated:
// Simplified credit card generator example FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .register(CreditCard.class, fm -\u0026gt; fm .giveMeBuilder(CreditCard.class) .set(\u0026quot;number\u0026quot;, Arbitraries.strings().numeric().ofLength(16).startsWith(\u0026quot;4\u0026quot;)) // formatted 16-digit starting with VISA .set(\u0026quot;expiryDate\u0026quot;, () -\u0026gt; LocalDate.now().plusYears(2)) // 2 years from now .set(\u0026quot;cvv\u0026quot;, Arbitraries.integers().between(100, 999)) // 3-digit between 100-999 ) .build(); CreditCard card = fixtureMonkey.giveMeOne(CreditCard.class); When to use each approach:
Using Arbitraries API with transformations
Best for: Creating complex patterns and formats with built-in randomization Use when: You need to generate values following specific formats or algorithms Examples: Credit card numbers, ISBN codes, formatted identifiers Lambda expressions (() -\u0026gt; LocalDate.now().plusYears(2))
Best for: Dynamic or time-dependent values evaluated at test runtime Use when: Values need to be based on current time or change with each execution Examples: Expiration dates, timestamps, incremental IDs Standard Arbitraries API (Arbitraries.integers().between(100, 999))
Best for: Applying simple constraints to random values Use when: You need values within specific ranges or matching patterns Examples: Age ranges, postal codes, constrained numeric values When to use: When standard generation doesn\u0026rsquo;t meet your requirements for domain-specific objects.
For basic type registration, see Type Configuration in the Essential Options guide. For more on the type registration system, see Type Registration System in the Concepts documentation.
Using registerExactType vs registerAssignableType # For precise control over which classes are affected by your custom generators:
// Only applies to exactly Vehicle class, not subclasses fixtureMonkey.registerExactType( Vehicle.class, fm -\u0026gt; fm.giveMeBuilder(Vehicle.class) .set(\u0026quot;manufacturer\u0026quot;, \u0026quot;Tesla\u0026quot;) ); // Applies to Car class and all its subclasses (SportsCar, etc.) fixtureMonkey.registerAssignableType( Car.class, fm -\u0026gt; fm.giveMeBuilder(Car.class) .set(\u0026quot;hasFourWheels\u0026quot;, true) ); When to use: When you want fine-grained control over your inheritance hierarchy in tests.
Note: When both registerExactType and registerAssignableType are applied to the same type, the option added last takes precedence.
Default Arbitrary Generator # When to use: When you want to customize how default values are generated across all types, such as ensuring uniqueness or applying custom formatting.
Use these options to customize the base arbitrary generator for all types. Below is an example that ensures generated values are unique by filtering out duplicates:
public static class UniqueArbitraryGenerator implements ArbitraryGenerator { private static final Set\u0026lt;Object\u0026gt; UNIQUE = new HashSet\u0026lt;\u0026gt;(); private final ArbitraryGenerator delegate; public UniqueArbitraryGenerator(ArbitraryGenerator delegate) { this.delegate = delegate; } @Override public CombinableArbitrary generate(ArbitraryGeneratorContext context) { return delegate.generate(context) .filter(obj -\u0026gt; { if (!UNIQUE.contains(obj)) { UNIQUE.add(obj); return true; } return false; }); } } // Usage FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .defaultArbitraryGenerator(UniqueArbitraryGenerator::new) .build(); For a conceptual understanding of generators, see Generators and Introspectors in the Concepts documentation.
Property Customization # Matcher-Based Property Generators # Use pushPropertyGenerator(MatcherOperator\u0026lt;PropertyGenerator\u0026gt;) to register a custom PropertyGenerator for any matching condition. For example, apply a generator to all instances of a class or package:
FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .pushPropertyGenerator( MatcherOperator.assignableTypeMatchOperator( MyClass.class, new CustomPropertyGenerator() ) ) .build(); When to use: When you need to apply custom property generation logic across multiple types or conditions.
Adding Custom Object Property Generators # Use pushExactTypePropertyGenerator to customize property generation for specific types:
FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .pushExactTypePropertyGenerator( PropertyAddress.class, new FieldPropertyGenerator() ) .build(); See the table below for available PropertyGenerator implementations.
Various PropertyGenerator Implementations # Implementation Description When to Use FieldPropertyGenerator Generates properties based on class fields, including inherited and interface fields. Use for objects where field access is important. Useful when you need direct access to all fields. JavaBeansPropertyGenerator Generates properties based on JavaBeans convention with getter methods. Use for POJO classes with getter methods. Suitable for objects with encapsulation where access is only through public APIs. ConstructorParameterPropertyGenerator Generates properties based on constructor parameters. Use for immutable objects or objects with constructor injection. Particularly useful for objects using annotations like lombok's @AllArgsConstructor. CompositePropertyGenerator Combines multiple PropertyGenerators. Use for complex object structures where you need to combine different property generation strategies. For example, when you want to handle some properties via fields and others via constructors. ElementPropertyGenerator Generates properties for container elements. Use when dealing with elements in container types like collections, arrays, or maps. LazyPropertyGenerator Delays property generation until needed. Use for objects with expensive generation costs or circular references. When custom property generation is needed, you can choose the most appropriate implementation for your situation or combine multiple implementations. For example, you could generate most properties using FieldPropertyGenerator while handling specific fields with custom logic.
Real-world application scenarios:
When your system has objects with special formats or validations like addresses, product codes, or identification numbers When you need to completely control how an object is generated and override the default generation logic When you want to apply exact business rules or constraints to generate only valid test data When to use: When you need complete control over how properties of a specific object are discovered and generated, especially for complex domain rules or special formats.
Custom Property Name Resolution # Default Property Name Resolver # Use defaultPropertyNameResolver to set a global resolver applied to all properties when no specific resolver matches:
FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .defaultPropertyNameResolver(property -\u0026gt; \u0026quot;'\u0026quot; + property.getName() + \u0026quot;'\u0026quot;) .build(); When to use: When you want to customize the default naming convention for all path expressions globally.
Specific Type Resolvers # Use the Jackson plugin or pushExactTypePropertyNameResolver to handle JSON property names:
FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .pushExactTypePropertyNameResolver( UserProfile.class, new JacksonPropertyNameResolver() ) .build(); When to use: Classes with @JsonProperty or naming conventions that differ from field names.
Object Property Generators # When to use: When you need to customize the discovery and generation of object properties, for example for nested or complex types.
Use these options to configure how object properties are found and generated:
// Default generator for all object properties FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .defaultObjectPropertyGenerator(new CustomObjectPropertyGenerator()) .build(); // Conditional generator for specific types FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .pushObjectPropertyGenerator( MatcherOperator.assignableTypeMatchOperator( MyClass.class, new CustomObjectPropertyGenerator() ) ) .build(); When to use: When you need to customize the discovery and generation of object properties, for example for nested or complex types.
Container Handling Options # When to use: When you need to customize how Fixture Monkey handles collection types such as lists, sets, and maps, including element generation, introspection, and decomposition.
These options let you control how Fixture Monkey interacts with collection types:
Container Property Generators # Use these options to control property generation within container elements:
// Custom generator for container elements FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .pushContainerPropertyGenerator( MatcherOperator.assignableTypeMatchOperator( List.class, new CustomContainerPropertyGenerator() ) ) .build(); Container Introspection # Use these options to customize how container types are analyzed:
// Add custom introspection for container types FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .pushContainerIntrospector(new CustomContainerIntrospector()) .build(); // Configure a container type with custom handling FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .addContainerType( MyContainer.class, new MyContainerPropertyGenerator(), new MyContainerArbitraryIntrospector(), new MyContainerDecomposedContainerValueFactory() ) .build(); Container Value Decomposition Options # Use these options to configure how elements in containers are processed:
// Set default container value factory FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .defaultDecomposedContainerValueFactory( new CustomDecomposedContainerValueFactory() ) .build(); // Add container value factory for a specific type FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .addDecomposedContainerValueFactory( MyCollection.class, new CustomDecomposedContainerValueFactory() ) .build(); For basic container handling, see Container Size Configuration in the Essential Options guide. For more on how containers are conceptually different, see Container Types vs. Object Types in the Concepts documentation.
Validation \u0026amp; Constraints # When to use: When you need to enforce custom validation logic or apply Java Bean Validation constraints to generated fixtures.
Use these options to enforce custom validation and constraint logic:
// Custom arbitrary validator FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .arbitraryValidator(new CustomArbitraryValidator()) .build(); // Java constraint handling and valid-only paths FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .javaConstraintGenerator(new CustomJavaConstraintGenerator()) .pushJavaConstraintGeneratorCustomizer( g -\u0026gt; g.overrideConstraint(MyConstraint.class, prop -\u0026gt; Arbitraries.strings().alpha()) ) .pushCustomizeValidOnly( TreeMatcher.exactPath(\u0026quot;root.child.property\u0026quot;), true ) .build(); When to use: When you need to enforce custom validation logic or apply Java Bean Validation constraints to generated fixtures.
Custom Introspection Settings # pushArbitraryIntrospector, pushAssignableTypeArbitraryIntrospector, pushExactTypeArbitraryIntrospector
Use pushArbitraryIntrospector(MatcherOperator\u0026lt;ArbitraryIntrospector\u0026gt;) to register a custom introspector based on matching conditions:
FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .pushArbitraryIntrospector( new MatcherOperator\u0026lt;\u0026gt;( new ExactTypeMatcher(MyClass.class), new CustomArbitraryIntrospector() ) ) .build(); For generic classes, you can also include the number of type parameters in the matching condition.
SingleGenericTypeMatcher, DoubleGenericTypeMatcher, TripleGenericTypeMatcher
FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .pushArbitraryIntrospector( new MatcherOperator\u0026lt;\u0026gt;( new AssignableTypeMatcher(MyParameterizedClass.class).intersect(new SingleGenericTypeMatcher()), new CustomArbitraryIntrospector() ) ) .build(); When to use: When you want to control how objects are introspected based on specific conditions.
Note: Options registered later are applied first.
For information on implementing custom introspectors, see the Creating Custom Introspector guide.
Expression Strict Mode # When enabled, path expressions provided to setter APIs (e.g., .set()) must match existing object properties; otherwise, an exception is thrown.
FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .useExpressionStrictMode() .build(); // Throws an exception at sample() if 'nonExistingField' is not a property of Product Product invalid = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026quot;nonExistingField\u0026quot;, 123) .sample(); When to use: When you want to strictly enforce property path validity in setter expressions.
Real-World Advanced Configuration # Complex real-world configuration combining multiple advanced options:
FixtureMonkey fixtureMonkey = FixtureMonkey.builder() // Framework integrations .plugin(new JacksonPlugin()) .plugin(new JavaxValidationPlugin()) // Performance optimizations .generateMaxTries(50) .manipulatorOptimizer(new DefaultManipulatorOptimizer()) // Domain-specific customizations .register(Money.class, fm -\u0026gt; fm.giveMeBuilder(Money.class) .set(\u0026quot;amount\u0026quot;, Arbitraries.longs().between(1, 1_000_000)) .set(\u0026quot;currency\u0026quot;, Arbitraries.of(\u0026quot;USD\u0026quot;, \u0026quot;EUR\u0026quot;, \u0026quot;GBP\u0026quot;)) ) .register(User.class, fm -\u0026gt; fm.giveMeBuilder(User.class) .set(\u0026quot;email\u0026quot;, Arbitraries.emails().endingWith(\u0026quot;@company.com\u0026quot;)) .set(\u0026quot;roles\u0026quot;, Arbitraries.of(Role.class)) .set(\u0026quot;lastLoginDate\u0026quot;, () -\u0026gt; LocalDateTime.now().minusDays( ThreadLocalRandom.current().nextLong(0, 30)) ) ) // Global settings .defaultNotNull(true) .nullableContainer(false) .seed(1234L) // Reproducible tests .build(); When to use: For enterprise-grade test suites requiring precise control over object generation with domain constraints.
Common Advanced Testing Scenarios # Complex Domain Models with Relationship Constraints # @Test void testComplexDomainRelationships() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .defaultNotNull(true) // Register company with specific departments .register(Company.class, fm -\u0026gt; fm.giveMeBuilder(Company.class) .size(\u0026quot;departments\u0026quot;, 3) ) // Register departments with employees .register(Department.class, fm -\u0026gt; fm.giveMeBuilder(Department.class) .size(\u0026quot;employees\u0026quot;, 5) ) .build(); // Generate a complex company structure Company company = fixtureMonkey.giveMeOne(Company.class); // Test complex operations ReorganizationResult result = reorganizationService.optimizeStructure(company); assertThat(result.getEfficiencyGain()).isGreaterThan(0.15); // 15% improvement } Performance Testing with Large Data Sets # @Test void testLargeDataSetPerformance() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .manipulatorOptimizer(new DefaultManipulatorOptimizer()) .defaultArbitraryContainerInfoGenerator( new DefaultArbitraryContainerInfoGenerator(500, 500) // Large containers ) .build(); // Generate large dataset List\u0026lt;Transaction\u0026gt; transactions = fixtureMonkey.giveMe( new TypeReference\u0026lt;List\u0026lt;Transaction\u0026gt;\u0026gt;() {}, 1).get(0); // Measure performance long startTime = System.currentTimeMillis(); ProcessingResult result = batchProcessor.process(transactions); long endTime = System.currentTimeMillis(); assertThat(endTime - startTime).isLessThan(2000); // Process in under 2 seconds } What\u0026rsquo;s Next? # After mastering these advanced options, you can consider:
â†’ Creating Custom Introspector - Implement your own introspector for special domain requirements
â†’ Contributing to Fixture Monkey - Join the open source community
`}),e.add({id:34,href:"/v1-1-0/docs/plugins/kotlin-plugin/",title:"Kotlin Plugin",description:"",content:""}),e.add({id:35,href:"/v1-1-0/docs/plugins/",title:"Plugins",description:"",content:""}),e.add({id:36,href:"/v1-1-0/docs/plugins/kotlin-plugin/features/",title:"Features",description:`To help you take full advantage of the concise, safe, and pragmatic nature of Kotlin, Fixture Monkey provides a Kotlin plugin.
Using PrimaryConstructorArbitraryIntrospector as the default introspector to generate Kotlin classes with its primary constructor. Fixture Monkey Extension Functions Kotlin DSL Exp, Kotlin instantiateBy DSL Dependencies # fixture-monkey-kotlin # Gradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-kotlin:1.1.15\u0026quot;) Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-kotlin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.15\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; fixture-monkey-starter-kotlin # To help you get started using Fixture Monkey in a Kotlin environment, there is also a starter dependency fixture-monkey-starter-kotlin that comes with pre-configured dependencies such as fixture-monkey-starter or fixture-monkey-jakarta-validation.`,content:`To help you take full advantage of the concise, safe, and pragmatic nature of Kotlin, Fixture Monkey provides a Kotlin plugin.
Using PrimaryConstructorArbitraryIntrospector as the default introspector to generate Kotlin classes with its primary constructor. Fixture Monkey Extension Functions Kotlin DSL Exp, Kotlin instantiateBy DSL Dependencies # fixture-monkey-kotlin # Gradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-kotlin:1.1.15\u0026quot;) Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-kotlin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.15\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; fixture-monkey-starter-kotlin # To help you get started using Fixture Monkey in a Kotlin environment, there is also a starter dependency fixture-monkey-starter-kotlin that comes with pre-configured dependencies such as fixture-monkey-starter or fixture-monkey-jakarta-validation.
Gradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-starter-kotlin:1.1.15\u0026quot;) Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-starter-kotlin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.15\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; Plugin # val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .build() `}),e.add({id:37,href:"/v1-1-0/docs/plugins/kotlin-plugin/introspectors-for-kotlin/",title:"Introspectors for Kotlin",description:`Fixture Monkey provides some additional introspectors that support the generation of Kotlin classes.
PrimaryConstructorArbitraryIntrospector # The PrimaryConstructorArbitraryIntrospector becomes the default introspector when the Kotlin plugin is added. It creates a Kotlin class with its primary constructor.
In the case of using PrimaryConstructorArbitraryIntrospector, it only contains the properties of the Kotlin constructor parameter.
If you use your own ArbitraryIntrospector instead of PrimaryConstructorArbitraryIntrospector, it will contain the properties of the Kotlin constructor parameter, Field, Getter.`,content:`Fixture Monkey provides some additional introspectors that support the generation of Kotlin classes.
PrimaryConstructorArbitraryIntrospector # The PrimaryConstructorArbitraryIntrospector becomes the default introspector when the Kotlin plugin is added. It creates a Kotlin class with its primary constructor.
In the case of using PrimaryConstructorArbitraryIntrospector, it only contains the properties of the Kotlin constructor parameter.
If you use your own ArbitraryIntrospector instead of PrimaryConstructorArbitraryIntrospector, it will contain the properties of the Kotlin constructor parameter, Field, Getter. So it contains the properties of the parent Field and Getter. You can customize the all properties by ArbitraryBuilder APIs.
For example, if you apply the JacksonPlugin after applying the KotlinPlugin, you can generate an instance of the Kotlin type by Jackson. In this case, you can customize the parent fields.
Example Kotlin Class :
data class Product ( val id: Long?, val productName: String, val price: Long, val options: List\u0026lt;String\u0026gt;, val createdAt: Instant ) Using PrimaryConstructorArbitraryIntrospector :
@Test fun test() { val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .build() val product: Product = fixtureMonkey.giveMeOne() } KotlinAndJavaCompositeArbitraryIntrospector # The KotlinAndJavaCompositeArbitraryIntrospector is an introspector designed to assist in the creation of Kotlin classes that reference Java classes.
Example Kotlin Class :
class KotlinClassWithJavaClass(val javaObject: JavaObject) Example Java Class :
public class JavaObject { private String value; private Map\u0026lt;String, String\u0026gt; map; public JavaObject() { } public String getValue() { return value; } public void setValue(String value) { this.value = value; } public Map\u0026lt;String, String\u0026gt; getMap() { return map; } public void setMap(Map\u0026lt;String, String\u0026gt; map) { this.map = map; } } Using PrimaryConstructorArbitraryIntrospector :
fun kotlinClassWithJavaClass() { // given val sut: FixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .objectIntrospector(KotlinAndJavaCompositeArbitraryIntrospector()) .build() // when val actual = sut.giveMeOne\u0026lt;KotlinClassWithJavaClass\u0026gt;() then(actual).isNotNull then(actual.javaObject).isNotNull } For Kotlin and Java classes respectively, it uses the PrimaryConstructorArbitraryIntrospector and the BeanArbitraryIntrospector by default.
If changes are desired, these can be injected as arguments.
// given val sut: FixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .objectIntrospector( KotlinAndJavaCompositeArbitraryIntrospector( kotlinArbitraryIntrospector = PrimaryConstructorArbitraryIntrospector.INSTANCE, javaArbitraryIntrospector = ConstructorPropertiesArbitraryIntrospector.INSTANCE ) ) .build() `}),e.add({id:38,href:"/v1-1-0/docs/plugins/kotlin-plugin/kotlin-exp/",title:"Kotlin DSL Exp",description:`Fixture Monkey utilizes Kotlin\u0026rsquo;s DSL feature to ensure type-safety with expressions. Let\u0026rsquo;s explore how we can employ Kotlin Exp instead of the standard Java String Expression.
Referencing a property # Suppose we have an object structure similar to the one described earlier, written in both Java and Kotlin:
@Value public class JavaClass { String field; List\u0026lt;String\u0026gt; list; Nested nestedObject; List\u0026lt;Nested\u0026gt; nestedObjectList; @Value public static class Nested { String nestedField; } } data class KotlinClass( val field: String, val list: List\u0026lt;String\u0026gt;, val nestedObject: Nested, val nestedObjectList: List\u0026lt;Nested\u0026gt; ) { data class Nested( val nestedField: String ) } To use Kotlin Exp to reference a property, you need to use the Exp or ExpGetter suffix to the normal Fixture Customization APIs.`,content:`Fixture Monkey utilizes Kotlin\u0026rsquo;s DSL feature to ensure type-safety with expressions. Let\u0026rsquo;s explore how we can employ Kotlin Exp instead of the standard Java String Expression.
Referencing a property # Suppose we have an object structure similar to the one described earlier, written in both Java and Kotlin:
@Value public class JavaClass { String field; List\u0026lt;String\u0026gt; list; Nested nestedObject; List\u0026lt;Nested\u0026gt; nestedObjectList; @Value public static class Nested { String nestedField; } } data class KotlinClass( val field: String, val list: List\u0026lt;String\u0026gt;, val nestedObject: Nested, val nestedObjectList: List\u0026lt;Nested\u0026gt; ) { data class Nested( val nestedField: String ) } To use Kotlin Exp to reference a property, you need to use the Exp or ExpGetter suffix to the normal Fixture Customization APIs.
Let\u0026rsquo;s look at the example of customizing properties with Kotlin Exp using setExp() and setExpGetter().
@Test fun test() { // given val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .plugin(JacksonPlugin()) .build() // when val javaClass = fixtureMonkey.giveMeBuilder\u0026lt;JavaClass\u0026gt;() .setExpGetter(JavaClass::getField, \u0026quot;field\u0026quot;) .sample() val kotlinClass = fixtureMonkey.giveMeBuilder\u0026lt;KotlinClass\u0026gt;() .setExp(KotlinClass::field, \u0026quot;field\u0026quot;) .sample() // then then(javaClass.field).isEqualTo(\u0026quot;field\u0026quot;) then(kotlinClass.field).isEqualTo(\u0026quot;field\u0026quot;) } In the code above, we can see that we are using Kotlin\u0026rsquo;s method reference to select a property.
setExp() takes an argument of type KProperty, while setExpGetter() takes an argument of type KFunction.
If the class is defined in Java, the expression (e.g. JavaClass::getField) is of type KFunction because it is a reference to a Java getter. Therefore you can only use the setExpGetter() method.
If it is a Kotlin class, the expression (e.g. KotlinClass::field) is KProperty, so you should use setExp().
Referencing a nested property # To access a nested field, the infix functions into and intoGetter are used. into takes a parameter of type KProperty, while intoGetter takes a parameter of type KFunction.
@Test fun test() { // given val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .plugin(JacksonPlugin()) .build() // when val javaClass = fixtureMonkey.giveMeBuilder\u0026lt;JavaClass\u0026gt;() .setExp(JavaClass::getNestedObject intoGetter JavaClass.Nested::getNestedField, \u0026quot;nestedField\u0026quot;) .sample() val kotlinClass = fixtureMonkey.giveMeBuilder\u0026lt;KotlinClass\u0026gt;() .setExp(KotlinClass::nestedObject into KotlinClass.Nested::nestedField, \u0026quot;nestedField\u0026quot;) .sample() then(javaClass.nestedObject.nestedField).isEqualTo(\u0026quot;nestedField\u0026quot;) then(kotlinClass.nestedObject.nestedField).isEqualTo(\u0026quot;nestedField\u0026quot;) } An expression that contains an into or intoGetter operator becomes an ExpressionGenerator type in fixture monkey. Both setExp() and setExpGetter()) are defined to take ExpressionGenerator types as arguments, so you can use both.
Selecting Properties Using Kotlin DSL Expressions # Selecting the root object: # Currently Not Supported Selecting a specific field: # JavaClass::getField // java class KotlinClass::field // kotlin class Selecting a nested field: # JavaClass::getNestedObject intoGetter JavaClass.Nested::getNestedField // java class KotlinClass::nestedObject into KotlinClass.Nested::nestedField // kotlin class Selecting the n-th element of a collection: # JavaClass::getNestedObjectList[\u0026quot;0\u0026quot;] // java class KotlinClass::nestedObjectList[\u0026quot;0\u0026quot;] // kotlin class Selecting all elements of a collection: # JavaClass::getNestedObjectList[\u0026quot;*\u0026quot;] // java class KotlinClass::nestedObjectList[\u0026quot;*\u0026quot;] // kotlin class Combining expressions to select a nested field: # JavaClass::getNestedObject intoGetter JavaClass.Nested::getNestedField // java class KotlinClass::nestedObject into KotlinClass.Nested::nestedField // kotlin class `}),e.add({id:39,href:"/v1-1-0/docs/plugins/jackson-plugin/",title:"Jackson Plugin",description:"",content:""}),e.add({id:40,href:"/v1-1-0/docs/plugins/jackson-plugin/features/",title:"Features",description:`Fixture monkey supports Jackson with the Fixture Monkey Jackson plugin.
Supports the use of JacksonObjectArbitraryIntrospector as the default introspector to create objects using the Jackson object mapper. Supports Jackson Annotations such as, @JsonIgnore, @JsonProperty Dependencies # Gradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-jackson:1.1.15\u0026quot;) Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-jackson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.15\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; Plugin # Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .build(); val fixtureMonkey = FixtureMonkey.builder() .plugin(JacksonPlugin()) .build() Pass the object mapper to the JacksonPlugin constructor if you are using Jackson with a custom object mapper.`,content:`Fixture monkey supports Jackson with the Fixture Monkey Jackson plugin.
Supports the use of JacksonObjectArbitraryIntrospector as the default introspector to create objects using the Jackson object mapper. Supports Jackson Annotations such as, @JsonIgnore, @JsonProperty Dependencies # Gradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-jackson:1.1.15\u0026quot;) Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-jackson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.15\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; Plugin # Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .build(); val fixtureMonkey = FixtureMonkey.builder() .plugin(JacksonPlugin()) .build() Pass the object mapper to the JacksonPlugin constructor if you are using Jackson with a custom object mapper.
Java Kotlin ObjectMapper objectMapper = JsonMapper.builder() .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES) .build() FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin(objectMapper)) .build(); val objectMapper = JsonMapper.builder() .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES) .build() val fixtureMonkey = FixtureMonkey.builder() .plugin(JacksonPlugin(objectMapper)) .build() `}),e.add({id:41,href:"/v1-1-0/docs/plugins/jackson-plugin/jackson-object-arbitrary-introspector/",title:"JacksonObjectArbitraryIntrospector",description:`JacksonObjectArbitraryIntrospector # The JacksonObjectArbitraryIntrospector becomes the default introspector when the Jackson plugin is added. It puts the created properties of the given class into a map and deserializes them using Jackson\u0026rsquo;s object mapper.
Example Java Class :
@Value public class Product { long id; String productName; long price; List\u0026lt;String\u0026gt; options; Instant createdAt; } Using JacksonObjectArbitraryIntrospector : Java Kotlin @Test void test() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .build(); Product product = fixtureMonkey.`,content:`JacksonObjectArbitraryIntrospector # The JacksonObjectArbitraryIntrospector becomes the default introspector when the Jackson plugin is added. It puts the created properties of the given class into a map and deserializes them using Jackson\u0026rsquo;s object mapper.
Example Java Class :
@Value public class Product { long id; String productName; long price; List\u0026lt;String\u0026gt; options; Instant createdAt; } Using JacksonObjectArbitraryIntrospector : Java Kotlin @Test void test() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .build(); Product product = fixtureMonkey.giveMeOne(Product.class); } testImplementation(\u0026#34;com.navercorp.fixturemonkey:fixture-monkey-starter-kotlin:1.1.15\u0026#34;) testImplementation(\u0026#34;com.fasterxml.jackson.module:jackson-module-kotlin\u0026#34;) @Test fun test() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .plugin(JacksonPlugin()) .build(); val product: Product = fixtureMonkey.giveMeOne() } ðŸ’¡ To generate Kotlin classes with JacksonObjectArbitraryIntrospector, both Kotlin plugin and Jackson plugin need to be added. In addition, fasterxml jackson-module-kotlin should be added to the dependency for serialization/deserialization of Kotlin classes. It has the advantage of being a general purpose introspector because it relies on the widely used Jackson for object creation. If your production code has both Kotlin and Java classes, it is recommended to use JacksonObjectArbitraryIntrospector.
However, it does have the disadvantage of potentially not performing as efficiently as other introspectors, as deserialization with Jackson can be more time-consuming.
`}),e.add({id:42,href:"/v1-1-0/docs/plugins/jackson-plugin/jackson-annotations/",title:"Jackson Annotations",description:`With the Jackson plugin, some Jackson annotations are also supported.
@JsonProperty, @JsonIgnore # We can use the property name specified by @JsonProperty when using the String Expression to customize this property.
The property with @JsonIgnore will have a null value when Fixture Monkey generates the object.
The following example shows how @JsonProperty, @JsonIgnore works with Fixture Monkey.
Example Java Class :
@Value // lombok getter, setter public class Product { long id; @JsonProperty(\u0026quot;name\u0026quot;) String productName; long price; @JsonIgnore List\u0026lt;String\u0026gt; options; Instant createdAt; } Java Kotlin @Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.`,content:`With the Jackson plugin, some Jackson annotations are also supported.
@JsonProperty, @JsonIgnore # We can use the property name specified by @JsonProperty when using the String Expression to customize this property.
The property with @JsonIgnore will have a null value when Fixture Monkey generates the object.
The following example shows how @JsonProperty, @JsonIgnore works with Fixture Monkey.
Example Java Class :
@Value // lombok getter, setter public class Product { long id; @JsonProperty(\u0026quot;name\u0026quot;) String productName; long price; @JsonIgnore List\u0026lt;String\u0026gt; options; Instant createdAt; } Java Kotlin @Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .build(); // when Product actual = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026#34;name\u0026#34;, \u0026#34;book\u0026#34;) .sample(); // then then(actual.getProductName()).isEqualTo(\u0026#34;book\u0026#34;); // @JsonProperty then(actual.getOptions()).isNull(); // @JsonIgnore } @Test fun test() { // given val fixtureMonkey = FixtureMonkey.builder() .plugin(JacksonPlugin()) .build() // when val actual = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .set(\u0026#34;name\u0026#34;, \u0026#34;book\u0026#34;) .sample() // then then(actual.productName).isEqualTo(\u0026#34;book\u0026#34;) // @JsonProperty then(actual.options).isNull() // @JsonIgnore } @JsonTypeInfo, @JsonSubTypes # Fixture Monkey also supports Jackson\u0026rsquo;s polymorphic type handling annotations @JsonTypeInfo and @JsonSubTypes.
We can generate an inheritance-implementation relationship object with the help of FixtureMonkey.
`}),e.add({id:43,href:"/v1-1-0/docs/plugins/jakarta-validation-plugin/",title:"Jakarta Validation Plugin",description:"",content:""}),e.add({id:44,href:"/v1-1-0/docs/plugins/jakarta-validation-plugin/features/",title:"Features",description:`Fixture monkey supports generating valid data based on Jakarta Bean Validation 3.0 annotations with the Fixture Monkey Jakarta Validation Plugin.
ðŸ’¡ Javax Bean Validation is also supported with the Fixture Monkey Javax Validation Plugin Dependencies # Gradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-jakarta-validation:1.1.15\u0026quot;) Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-jakarta-validation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.15\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; The jakarta validation API and the Hibernate validator are already provided as part of the dependency.
Plugin # Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.`,content:`Fixture monkey supports generating valid data based on Jakarta Bean Validation 3.0 annotations with the Fixture Monkey Jakarta Validation Plugin.
ðŸ’¡ Javax Bean Validation is also supported with the Fixture Monkey Javax Validation Plugin Dependencies # Gradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-jakarta-validation:1.1.15\u0026quot;) Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-jakarta-validation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.15\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; The jakarta validation API and the Hibernate validator are already provided as part of the dependency.
Plugin # Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JakartaValidationPlugin()) .build(); val fixtureMonkey = FixtureMonkey.builder() .plugin(JakartaValidationPlugin()) .build() `}),e.add({id:45,href:"/v1-1-0/docs/plugins/jakarta-validation-plugin/bean-validation/",title:"Bean Validation",description:`Generating valid data # Using the Jakarta Validation plugin, we can generate valid data based on Jakarta Bean validation annotations on properties.
For example, there can be a Product class annotated as follows:
@Value public class Product { @Min(1) long id; @NotBlank String productName; @Max(100000) long price; @Size(min = 3) List\u0026lt;@NotBlank String\u0026gt; options; @Past Instant createdAt; } An instance of the Product class that is compliant with the annotations can be created in the following manner:`,content:`Generating valid data # Using the Jakarta Validation plugin, we can generate valid data based on Jakarta Bean validation annotations on properties.
For example, there can be a Product class annotated as follows:
@Value public class Product { @Min(1) long id; @NotBlank String productName; @Max(100000) long price; @Size(min = 3) List\u0026lt;@NotBlank String\u0026gt; options; @Past Instant createdAt; } An instance of the Product class that is compliant with the annotations can be created in the following manner:
@Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .plugin(new JakartaValidationPlugin()) .build(); // when Product actual = fixtureMonkey.giveMeOne(Product.class); // then then(actual).isNotNull(); then(actual.getId()).isGreaterThan(0); then(actual.getProductName()).isNotBlank(); then(actual.getPrice()).isLessThanOrEqualTo(100000); then(actual.getOptions().size()).isGreaterThanOrEqualTo(3); then(actual.getOptions()).allSatisfy(it -\u0026gt; then(it).isNotEmpty()); then(actual.getCreatedAt()).isNotNull().isLessThanOrEqualTo(Instant.now()); } Supported Annotations # Every annotation from the jakarta.validation.constraints package is supported. Different types support different annotation constraints.
Numeric Type # Supported Types: BigDecimal, BigInteger, byte, double, float, int, long, short
@Digits (fraction is currently not supported) @Max @Min @Negative @NegativeOrZero @DecimalMax @DecimalMin @Positive @PositiveOrZero Boolean Type # @AssertFalse @AssertTrue String Type # @Null @NotNull @NotBlank @NotEmpty @Size @Digits @Pattern @Email Time Type # Supported Types: Calendar, Date, Instant, LocalDate, LocalDateTime, LocalTime, ZonedDateTime, Year, YearMonth, MonthDay, OffsetDateTime, OffsetTime
@Past @PastOrPresent @Future @FutureOrPresent Container Type # @Size @NotEmpty `}),e.add({id:46,href:"/v1-1-0/docs/intellij-plugin/",title:"Intellij Plugin",description:"",content:""}),e.add({id:47,href:"/v1-1-0/docs/plugins/kotest-plugin/",title:"Kotest Plugin",description:"",content:""}),e.add({id:48,href:"/v1-1-0/docs/plugins/kotest-plugin/features/",title:"Features",description:`The Kotest plugin provided by Fixture Monkey allows you to enhance your testing experience within the Kotest framework.
Replaces the default generator for generating random values for primitive types from Jqwik to Kotest\u0026rsquo;s property generator (Arb). Use of bean validation annotations also works. Support for Kotest\u0026rsquo;s property-based testing functions, including forAll and checkAll. ðŸ’¡ Adding the Kotest Plugin doesn't mean you have to use Kotest as your testing framework. You can still use Junit.`,content:`The Kotest plugin provided by Fixture Monkey allows you to enhance your testing experience within the Kotest framework.
Replaces the default generator for generating random values for primitive types from Jqwik to Kotest\u0026rsquo;s property generator (Arb). Use of bean validation annotations also works. Support for Kotest\u0026rsquo;s property-based testing functions, including forAll and checkAll. ðŸ’¡ Adding the Kotest Plugin doesn't mean you have to use Kotest as your testing framework. You can still use Junit. Dependencies # fixture-monkey-kotlin # Gradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-kotest:1.1.15\u0026quot;) Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-kotest\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.15\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; Plugin # val fixtureMonkey = FixtureMonkey.builder() .plugin(KotestPlugin()) .plugin(KotlinPlugin()) .build() `}),e.add({id:49,href:"/v1-1-0/docs/intellij-plugin/fixture-monkey-helper/",title:"Fixture Monkey Helper",description:`Fixture Monkey Helper is an IntelliJ plugin that helps to use Fixture Monkey on the IntelliJ IDE.
It provides some features that make using String Expressions and Kotlin DSL Expressions easier, and also add some IntelliJ inspections to detect and fix abnormal code.
ðŸš¨ This plugin currently operates only within Java source code and Kotlin test code. Plans for expansion are in progress. Features # Fixture Monkey Expression support
Seamless Conversion: Transform string expressions into the Kotlin DSL provided by Fixture Monkey for ArbitraryBuilder.`,content:`Fixture Monkey Helper is an IntelliJ plugin that helps to use Fixture Monkey on the IntelliJ IDE.
It provides some features that make using String Expressions and Kotlin DSL Expressions easier, and also add some IntelliJ inspections to detect and fix abnormal code.
ðŸš¨ This plugin currently operates only within Java source code and Kotlin test code. Plans for expansion are in progress. Features # Fixture Monkey Expression support
Seamless Conversion: Transform string expressions into the Kotlin DSL provided by Fixture Monkey for ArbitraryBuilder. Expression Validation: Ensure the accuracy of your string expressions before execution. Intuitive Auto-Completion: Speed up your coding with smart suggestions as you type. Easy Navigation: Jump directly to field references within your codebase. FixtureMonkey Kotlin DSL Enhancements
Bidirectional Transformation: Switch between Kotlin DSL and Fixture Monkey string expressions effortlessly. Support for on-the-fly bidirectional Transformation (Beta) Code Folding: Simplify your view by collapsing DSL expressions into a single line. Lambda Expression Generator: Craft fixture specifications with ease using generated lambda expressions. Lambda to DSL Conversion: Convert complex lambda expressions into readable and maintainable Fixture Monkey Kotlin DSL. Inspection
Change type information passed as method arguments in Fixture Monkey factory methods to generic type arguments Change generic type arguments to variable types in Fixture Monkey factory methods when possible Fixture Monkey Property Overview Tool Window (Alpha)
This tool window allows you to view all properties registered with ArbitraryBuilder at a glance, presented in a tree format. `}),e.add({id:50,href:"/v1-1-0/docs/plugins/kotest-plugin/property-based-testing/",title:"Kotest Property Based Testing",description:`Fixture Monkey\u0026rsquo;s Kotest plugin introduces two primary features that enhance property-based testing within the Kotest framework: forAll and checkAll.
The KotestPlugin and KotlinPlugin should be added to enable this feature.
val fixtureMonkey: FixtureMonkey = FixtureMonkey.builder() .plugin(KotestPlugin()) .plugin(KotlinPlugin()) .build() ForAll # Kotest provides a forAll function that accepts an n-arity function (a, ..., n) -\u0026gt; Boolean to test a property. The test passes if, for all input values, the function returns true.`,content:`Fixture Monkey\u0026rsquo;s Kotest plugin introduces two primary features that enhance property-based testing within the Kotest framework: forAll and checkAll.
The KotestPlugin and KotlinPlugin should be added to enable this feature.
val fixtureMonkey: FixtureMonkey = FixtureMonkey.builder() .plugin(KotestPlugin()) .plugin(KotlinPlugin()) .build() ForAll # Kotest provides a forAll function that accepts an n-arity function (a, ..., n) -\u0026gt; Boolean to test a property. The test passes if, for all input values, the function returns true.
This function accepts type parameters for the argument types, which Kotest uses to locate a generator that provides random values of a suitable type.
class PropertyExample: StringSpec({ \u0026quot;String size\u0026quot; { forAll\u0026lt;String, String\u0026gt; { a, b -\u0026gt; (a + b).length == a.length + b.length } } }) For cases when a custom generator is needed, it\u0026rsquo;s possible to specify generators (called Arb in Kotest). However, only generators of limited types are provided with kotest, and it is hard to customize.
Fixture Monkey offers a way to generate Arb for custom types using the giveMeArb() function. You can further customize the generator using Fixture Monkey\u0026rsquo;s customization APIs.
Here\u0026rsquo;s an example of performing property-based testing with forAll using Fixture Monkey:
class KotestInKotestTest : StringSpec({ \u0026quot;forAll\u0026quot; { forAll(fixtureMonkey.giveMeArb\u0026lt;StringObject\u0026gt; { it.set(\u0026quot;value\u0026quot;, \u0026quot;test\u0026quot;) }) { a -\u0026gt; a.value == \u0026quot;test\u0026quot; } } }) { data class StringObject(val value: String) } CheckAll # Fixture Monkey also provides the extension function checkAll similar to Kotest\u0026rsquo;s checkAll.
Primitive Type Input # With checkAll, you can test assertions against primitive data types, as shown in the example below:
class Test : StringSpec({ \u0026quot;checkAll\u0026quot; { SUT.checkAll { string: String, int: Int -\u0026gt; string shouldNotBeSameInstanceAs int string shouldBe string } } }) Custom Type Input # Fixture Monkey\u0026rsquo;s checkAll extension function goes beyond primitive types. You can also use custom types as input data, generated with Fixture Monkey.
class Test : StringSpec({ \u0026quot;checkAllObject\u0026quot; { SUT.checkAll { stringObject: StringObject -\u0026gt; stringObject.value shouldNotBe null } } }) { data class StringObject(val value: String) } ArbitraryBuilder Input # Additionally, you can work with ArbitraryBuilder instances and further customize them to execute assertions.
class Test : StringSpec({ \u0026quot;checkAllArbitraryBuilder\u0026quot; { SUT.checkAll { string: ArbitraryBuilder\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; -\u0026gt; string .size(\u0026quot;$\u0026quot;, 3) .sample() shouldHaveSize 3 } } }) { data class StringObject(val value: String) } `}),e.add({id:51,href:"/v1-1-0/docs/cheat-sheet/best-practices/",title:"Best Practices",description:`This guide provides practical tips and best practices for using Fixture Monkey effectively in your tests.
1. Keep Tests Simple and Focused # Only customize what matters for the test: Don\u0026rsquo;t set values for fields that don\u0026rsquo;t affect the test\u0026rsquo;s behavior. Java Kotlin // Good - only set what\u0026#39;s relevant to the test @Test void shouldCalculateDiscount() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026#34;price\u0026#34;, 100.0) // Only price matters for discount calculation .`,content:`This guide provides practical tips and best practices for using Fixture Monkey effectively in your tests.
1. Keep Tests Simple and Focused # Only customize what matters for the test: Don\u0026rsquo;t set values for fields that don\u0026rsquo;t affect the test\u0026rsquo;s behavior. Java Kotlin // Good - only set what\u0026#39;s relevant to the test @Test void shouldCalculateDiscount() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026#34;price\u0026#34;, 100.0) // Only price matters for discount calculation .sample(); double discount = productService.calculateDiscount(product); assertThat(discount).isEqualTo(10.0); } // Good - only set what\u0026#39;s relevant to the test @Test fun shouldCalculateDiscount() { val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setExpGetter(Product::getPrice, 100.0) // Only price matters for discount calculation .sample() val discount = productService.calculateDiscount(product) assertThat(discount).isEqualTo(10.0) } 2. Prefer Direct Property Setting Over Post-Conditions # Use direct property setting when possible: Instead of using setPostCondition which can cause performance issues due to rejection sampling, prefer direct configuration with set or size. Java Kotlin // Less efficient - uses post-conditions with rejection sampling @Test void lessEfficientOrderTest() { Order order = fixtureMonkey.giveMeBuilder(Order.class) .setPostCondition(o -\u0026gt; o.getItems().size() \u0026gt; 0) // Performance cost: may reject many samples .setPostCondition(o -\u0026gt; o.getTotalAmount() \u0026gt; 100) // Additional performance cost .sample(); OrderResult result = orderService.process(order); assertThat(result.isSuccessful()).isTrue(); } // More efficient - uses direct property setting @Test void moreEfficientOrderTest() { Order order = fixtureMonkey.giveMeBuilder(Order.class) .size(\u0026#34;items\u0026#34;, 1, 5) // Directly set collection size .set(\u0026#34;totalAmount\u0026#34;, Arbitraries.integers().greaterThan(100)) // Directly set valid range .sample(); OrderResult result = orderService.process(order); assertThat(result.isSuccessful()).isTrue(); } // When to use setPostCondition - for truly complex validation that cannot be expressed with property setting @Test void complexValidationTest() { // Only use setPostCondition for complex validations that cannot be expressed otherwise Invoice invoice = fixtureMonkey.giveMeBuilder(Invoice.class) .set(\u0026#34;items\u0026#34;, fixtureMonkey.giveMe(InvoiceItem.class, 3)) .set(\u0026#34;customerType\u0026#34;, CustomerType.BUSINESS) .setPostCondition(inv -\u0026gt; inv.calculateTotal().compareTo(inv.getItems().stream() .map(InvoiceItem::getAmount).reduce(BigDecimal.ZERO, BigDecimal::add)) == 0) .sample(); assertThat(invoiceService.validate(invoice)).isTrue(); } // Less efficient - uses post-conditions with rejection sampling @Test fun lessEfficientOrderTest() { val order = fixtureMonkey.giveMeBuilder\u0026lt;Order\u0026gt;() .setPostCondition { it.items.isNotEmpty() } // Performance cost: may reject many samples .setPostCondition { it.totalAmount \u0026gt; 100 } // Additional performance cost .sample() val result = orderService.process(order) assertThat(result.isSuccessful).isTrue() } // More efficient - uses direct property setting @Test fun moreEfficientOrderTest() { val order = fixtureMonkey.giveMeBuilder\u0026lt;Order\u0026gt;() .setExpSize(Order::getItems, 1, 5) // Directly set collection size .setExpGetter(Order::getTotalAmount, Arbitraries.integers().greaterThan(100)) // Directly set valid range .sample() val result = orderService.process(order) assertThat(result.isSuccessful).isTrue() } // When to use setPostCondition - for truly complex validation that cannot be expressed with property setting @Test fun complexValidationTest() { // Only use setPostCondition for complex validations that cannot be expressed otherwise val invoice = fixtureMonkey.giveMeBuilder\u0026lt;Invoice\u0026gt;() .setExpGetter(Invoice::getItems, fixtureMonkey.giveMe\u0026lt;InvoiceItem\u0026gt;(3)) .setExpGetter(Invoice::getCustomerType, CustomerType.BUSINESS) .setPostCondition { inv -\u0026gt; inv.calculateTotal() == inv.items.map { it.amount }.fold(BigDecimal.ZERO, BigDecimal::add) } .sample() assertThat(invoiceService.validate(invoice)).isTrue() } 3. Avoid Over-Specification in Tests # Don\u0026rsquo;t overspecify test requirements: Test only what needs to be tested. Java Kotlin // Bad - overspecified test with unnecessary details @Test void badTestTooManyDetails() { User user = fixtureMonkey.giveMeBuilder(User.class) .set(\u0026#34;id\u0026#34;, 1L) .set(\u0026#34;name\u0026#34;, \u0026#34;John\u0026#34;) .set(\u0026#34;email\u0026#34;, \u0026#34;john@example.com\u0026#34;) .set(\u0026#34;address.street\u0026#34;, \u0026#34;123 Main St\u0026#34;) .set(\u0026#34;address.city\u0026#34;, \u0026#34;New York\u0026#34;) .set(\u0026#34;address.zipCode\u0026#34;, \u0026#34;10001\u0026#34;) .set(\u0026#34;registrationDate\u0026#34;, LocalDate.of(2023, 1, 1)) .sample(); // Test is just checking if email is valid assertThat(userValidator.isEmailValid(user)).isTrue(); } // Good - only specify what\u0026#39;s needed for the test @Test void goodTestOnlyNeededDetails() { User user = fixtureMonkey.giveMeBuilder(User.class) .set(\u0026#34;email\u0026#34;, \u0026#34;john@example.com\u0026#34;) // Only email matters for this test .sample(); assertThat(userValidator.isEmailValid(user)).isTrue(); } // Bad - overspecified test with unnecessary details @Test fun badTestTooManyDetails() { val user = fixtureMonkey.giveMeBuilder\u0026lt;User\u0026gt;() .setExpGetter(User::getId, 1L) .setExpGetter(User::getName, \u0026#34;John\u0026#34;) .setExpGetter(User::getEmail, \u0026#34;john@example.com\u0026#34;) .setExpGetter(User::getAddress, { address -\u0026gt; address.setExpGetter(Address::getStreet, \u0026#34;123 Main St\u0026#34;) .setExpGetter(Address::getCity, \u0026#34;New York\u0026#34;) .setExpGetter(Address::getZipCode, \u0026#34;10001\u0026#34;) }) .setExpGetter(User::getRegistrationDate, LocalDate.of(2023, 1, 1)) .sample() // Test is just checking if email is valid assertThat(userValidator.isEmailValid(user)).isTrue() } // Good - only specify what\u0026#39;s needed for the test @Test fun goodTestOnlyNeededDetails() { val user = fixtureMonkey.giveMeBuilder\u0026lt;User\u0026gt;() .setExpGetter(User::getEmail, \u0026#34;john@example.com\u0026#34;) // Only email matters for this test .sample() assertThat(userValidator.isEmailValid(user)).isTrue() } 4. Make Tests Readable with Helper Methods # Create helper methods to improve test readability: Encapsulate fixture setup for better readability. Java Kotlin @Test void testOrderProcessing() { // Helper methods returning ArbitraryBuilder for more flexibility Order standardOrder = standardOrderBuilder() .set(\u0026#34;customerNote\u0026#34;, \u0026#34;Please deliver quickly\u0026#34;) // Test-specific customization .sample(); Customer premiumCustomer = premiumCustomerBuilder() .set(\u0026#34;membershipYears\u0026#34;, 5) // Test-specific customization .sample(); OrderResult result = orderService.process(standardOrder, premiumCustomer); assertThat(result.hasDiscount()).isTrue(); assertThat(result.getDiscount()).isGreaterThanOrEqualTo(standardOrder.getTotalAmount() * 0.1); } // Helper methods return ArbitraryBuilder instead of instances private ArbitraryBuilder\u0026lt;Order\u0026gt; standardOrderBuilder() { return fixtureMonkey.giveMeBuilder(Order.class) .size(\u0026#34;items\u0026#34;, 3, 5) .set(\u0026#34;totalAmount\u0026#34;, Arbitraries.integers().between(100, 500)); } private ArbitraryBuilder\u0026lt;Customer\u0026gt; premiumCustomerBuilder() { return fixtureMonkey.giveMeBuilder(Customer.class) .set(\u0026#34;premiumMember\u0026#34;, true) .set(\u0026#34;membershipYears\u0026#34;, 2); } @Test void testOrderWithSpecialDiscount() { // Reuse the same builder with different customizations Order bulkOrder = standardOrderBuilder() .size(\u0026#34;items\u0026#34;, 10, 20) // Different configuration for this test .set(\u0026#34;totalAmount\u0026#34;, Arbitraries.integers().between(500, 1000)) .sample(); Customer vipCustomer = premiumCustomerBuilder() .set(\u0026#34;membershipYears\u0026#34;, 10) // Different configuration for this test .set(\u0026#34;vipStatus\u0026#34;, true) .sample(); OrderResult result = orderService.processWithSpecialDiscount(bulkOrder, vipCustomer); assertThat(result.getDiscount()).isGreaterThanOrEqualTo(bulkOrder.getTotalAmount() * 0.2); } @Test fun testOrderProcessing() { // Helper methods returning ArbitraryBuilder for more flexibility val standardOrder = standardOrderBuilder() .setExpGetter(Order::getCustomerNote, \u0026#34;Please deliver quickly\u0026#34;) // Test-specific customization .sample() val premiumCustomer = premiumCustomerBuilder() .setExpGetter(Customer::getMembershipYears, 5) // Test-specific customization .sample() val result = orderService.process(standardOrder, premiumCustomer) assertThat(result.hasDiscount()).isTrue() assertThat(result.discount).isGreaterThanOrEqualTo(standardOrder.totalAmount * 0.1) } // Helper methods return ArbitraryBuilder instead of instances private fun standardOrderBuilder(): ArbitraryBuilder\u0026lt;Order\u0026gt; { return fixtureMonkey.giveMeBuilder\u0026lt;Order\u0026gt;() .setExpSize(Order::getItems, 3, 5) .setExpGetter(Order::getTotalAmount, Arbitraries.integers().between(100, 500)) } private fun premiumCustomerBuilder(): ArbitraryBuilder\u0026lt;Customer\u0026gt; { return fixtureMonkey.giveMeBuilder\u0026lt;Customer\u0026gt;() .setExpGetter(Customer::isPremiumMember, true) .setExpGetter(Customer::getMembershipYears, 2) } @Test fun testOrderWithSpecialDiscount() { // Reuse the same builder with different customizations val bulkOrder = standardOrderBuilder() .setExpSize(Order::getItems, 10, 20) // Different configuration for this test .setExpGetter(Order::getTotalAmount, Arbitraries.integers().between(500, 1000)) .sample() val vipCustomer = premiumCustomerBuilder() .setExpGetter(Customer::getMembershipYears, 10) // Different configuration for this test .setExpGetter(Customer::isVipStatus, true) .sample() val result = orderService.processWithSpecialDiscount(bulkOrder, vipCustomer) assertThat(result.discount).isGreaterThanOrEqualTo(bulkOrder.totalAmount * 0.2) } 5. Configure Once, Reuse Everywhere # Create specialized fixture configurations: Define common configurations once and reuse them. Java Kotlin // Define common configurations public class TestFixtures { public static final FixtureMonkey TEST_FIXTURE_MONKEY = FixtureMonkey.builder() .nullInject(0.0) // No null values .build(); public static ArbitraryBuilder\u0026lt;User\u0026gt; validUser() { return TEST_FIXTURE_MONKEY.giveMeBuilder(User.class) .set(\u0026#34;email\u0026#34;, \u0026#34;test@example.com\u0026#34;) .set(\u0026#34;active\u0026#34;, true); } } // Use in tests @Test void testUserRegistration() { User user = TestFixtures.validUser().sample(); userService.register(user); assertThat(userRepository.findByEmail(user.getEmail())).isNotNull(); } // Define common configurations object TestFixtures { val TEST_FIXTURE_MONKEY = FixtureMonkey.builder() .nullInject(0.0) // No null values .build() fun validUser(): ArbitraryBuilder\u0026lt;User\u0026gt; { return TEST_FIXTURE_MONKEY.giveMeBuilder\u0026lt;User\u0026gt;() .setExpGetter(User::getEmail, \u0026#34;test@example.com\u0026#34;) .setExpGetter(User::isActive, true) } } // Use in tests @Test fun testUserRegistration() { val user = TestFixtures.validUser().sample() userService.register(user) assertThat(userRepository.findByEmail(user.email)).isNotNull() } 6. Test Edge Cases and Boundary Conditions # Generate test cases with boundary values: Test min/max values and edge cases. Java Kotlin @Test void testUnderageUserCannotAccessAdultContent() { // Test with underage user User underage = fixtureMonkey.giveMeBuilder(User.class) .set(\u0026#34;age\u0026#34;, 17) // Just below legal age .sample(); assertThat(userService.canAccessAdultContent(underage)).isFalse(); } @Test void testOfAgeUserCanAccessAdultContent() { // Test with exactly of-age user User ofAge = fixtureMonkey.giveMeBuilder(User.class) .set(\u0026#34;age\u0026#34;, 18) // Exactly legal age .sample(); assertThat(userService.canAccessAdultContent(ofAge)).isTrue(); } @Test fun testUnderageUserCannotAccessAdultContent() { // Test with underage user val underage = fixtureMonkey.giveMeBuilder\u0026lt;User\u0026gt;() .setExpGetter(User::getAge, 17) // Just below legal age .sample() assertThat(userService.canAccessAdultContent(underage)).isFalse() } @Test fun testOfAgeUserCanAccessAdultContent() { // Test with exactly of-age user val ofAge = fixtureMonkey.giveMeBuilder\u0026lt;User\u0026gt;() .setExpGetter(User::getAge, 18) // Exactly legal age .sample() assertThat(userService.canAccessAdultContent(ofAge)).isTrue() } 7. Make Tests Reproducible # Use a fixed seed for tests that need reproducibility: This ensures consistent test results. Java Kotlin @Test @Seed(123L) // Makes the test reproducible void testComplexBehavior() { List\u0026lt;Order\u0026gt; orders = fixtureMonkey.giveMe(Order.class, 100); OrderSummary summary = orderService.summarize(orders); assertThat(summary.getTotalAmount()).isGreaterThan(0); } @Test @Seed(123L) // Makes the test reproducible fun testComplexBehavior() { val orders = fixtureMonkey.giveMe\u0026lt;Order\u0026gt;(100) val summary = orderService.summarize(orders) assertThat(summary.totalAmount).isGreaterThan(0) } 8. Define Type-Specific Generation Rules # Register custom rules for specific types: Define how types should be generated consistently across all tests. When to use: Use this approach when you need to control how a specific type is generated everywhere it appears in your tests. Java Kotlin // Create custom Fixture Monkey with type-specific generation rules FixtureMonkey fixtureMonkey = FixtureMonkey.builder() // Register a custom value for a simple type .register(String.class, it -\u0026gt; it.giveMeBuilder(\u0026#34;custom-string\u0026#34;)) // Register a custom rule for Email type // This affects ALL Email instances created by this fixture monkey .register(Email.class, fixture -\u0026gt; fixture.giveMeBuilder(new Email(\u0026#34;test@example.com\u0026#34;))) // Register a custom rule for a complex type with validation // Applies these rules whenever User instances are created .register(User.class, fixture -\u0026gt; fixture .setPostCondition(user -\u0026gt; user.getAge() \u0026gt;= 18) .set(\u0026#34;status\u0026#34;, \u0026#34;ACTIVE\u0026#34;)) // Register a factory method for a type .register(Product.class, fixture -\u0026gt; fixture .instantiate(factoryMethod(\u0026#34;createDefault\u0026#34;) .parameter(String.class, \u0026#34;productName\u0026#34;)) .set(\u0026#34;productName\u0026#34;, \u0026#34;Standard Product\u0026#34;)) .build(); // Using the custom registered instance String customString = fixtureMonkey.giveMeOne(String.class); // Returns \u0026#34;custom-string\u0026#34; Email email = fixtureMonkey.giveMeOne(Email.class); // Returns Email with \u0026#34;test@example.com\u0026#34; User user = fixtureMonkey.giveMeOne(User.class); // Returns an adult user with ACTIVE status // Create custom Fixture Monkey with type-specific generation rules val fixtureMonkey = FixtureMonkey.builder() // Register a custom value for a simple type .register(String::class.java) { it.giveMeBuilder(\u0026#34;custom-string\u0026#34;) } // Register a custom rule for Email type // This affects ALL Email instances created by this fixture monkey .register(Email::class.java) { fixture -\u0026gt; fixture.giveMeBuilder(Email(\u0026#34;test@example.com\u0026#34;)) } // Register a custom rule for a complex type with validation // Applies these rules whenever User instances are created .register(User::class.java) { fixture -\u0026gt; fixture .setPostCondition { user -\u0026gt; user.age \u0026gt;= 18 } .set(\u0026#34;status\u0026#34;, \u0026#34;ACTIVE\u0026#34;) } // Register a factory method for a type .register(Product::class.java) { fixture -\u0026gt; fixture .instantiate(factoryMethod(\u0026#34;createDefault\u0026#34;) .parameter(String::class.java, \u0026#34;productName\u0026#34;)) .set(\u0026#34;productName\u0026#34;, \u0026#34;Standard Product\u0026#34;) } .build() // Using the custom registered instance val customString = fixtureMonkey.giveMeOne\u0026lt;String\u0026gt;() // Returns \u0026#34;custom-string\u0026#34; val email = fixtureMonkey.giveMeOne\u0026lt;Email\u0026gt;() // Returns Email with \u0026#34;test@example.com\u0026#34; val user = fixtureMonkey.giveMeOne\u0026lt;User\u0026gt;() // Returns an adult user with ACTIVE status 9. Configure Field-Level Rules for Complex Objects # Define rules for individual fields within objects: Customize how individual properties are generated within complex objects. When to use: Use this approach when you need fine-grained control over individual fields within a complex object, applying different rules to different properties within the same class. Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() // Register rules for each field in a complex type // This provides field-by-field control, unlike the type-level register method .registerGroup(ProductDetails.class, group -\u0026gt; group // Each field can have its own specific generation rules .register(\u0026#34;name\u0026#34;, Arbitraries.strings().alpha().ofMinLength(3).ofMaxLength(50)) .register(\u0026#34;sku\u0026#34;, Arbitraries.strings().numeric().ofLength(10)) .register(\u0026#34;description\u0026#34;, Arbitraries.strings().ofMinLength(10).ofMaxLength(500)) .register(\u0026#34;inStock\u0026#34;, true) // Always in stock for tests .register(\u0026#34;price\u0026#34;, Arbitraries.doubles().between(1.0, 999.99)) .register(\u0026#34;weight\u0026#34;, Arbitraries.doubles().between(0.1, 100.0)) ) .build(); // The generated ProductDetails will have each field following its specific rule ProductDetails product = fixtureMonkey.giveMeOne(ProductDetails.class); // name - alphabetic string between 3-50 chars // sku - numeric string of exactly 10 chars // description - any string between 10-500 chars // inStock - always true // price - between 1.0 and 999.99 // weight - between 0.1 and 100.0 val fixtureMonkey = FixtureMonkey.builder() // Register rules for each field in a complex type // This provides field-by-field control, unlike the type-level register method .registerGroup(ProductDetails::class.java) { group -\u0026gt; group // Each field can have its own specific generation rules .register(\u0026#34;name\u0026#34;, Arbitraries.strings().alpha().ofMinLength(3).ofMaxLength(50)) .register(\u0026#34;sku\u0026#34;, Arbitraries.strings().numeric().ofLength(10)) .register(\u0026#34;description\u0026#34;, Arbitraries.strings().ofMinLength(10).ofMaxLength(500)) .register(\u0026#34;inStock\u0026#34;, true) // Always in stock for tests .register(\u0026#34;price\u0026#34;, Arbitraries.doubles().between(1.0, 999.99)) .register(\u0026#34;weight\u0026#34;, Arbitraries.doubles().between(0.1, 100.0)) } .build() // The generated ProductDetails will have each field following its specific rule val product = fixtureMonkey.giveMeOne\u0026lt;ProductDetails\u0026gt;() // name - alphabetic string between 3-50 chars // sku - numeric string of exactly 10 chars // description - any string between 10-500 chars // inStock - always true // price - between 1.0 and 999.99 // weight - between 0.1 and 100.0 `}),e.add({id:52,href:"/v1-1-0/docs/cheat-sheet/",title:"Cheat sheet",description:"",content:""}),e.add({id:53,href:"/v1-1-0/docs/plugins/datafaker-plugin/",title:"DataFaker Plugin",description:"",content:""}),e.add({id:54,href:"/v1-1-0/docs/cheat-sheet/faq/",title:"FAQ",description:`How do I get started with Fixture Monkey? # Fixture Monkey provides a simple way to create test objects with random values. Here\u0026rsquo;s how to get started:
Java Kotlin // Create a FixtureMonkey instance FixtureMonkey fixtureMonkey = FixtureMonkey.create(); // Generate a random object Person person = fixtureMonkey.giveMeOne(Person.class); // Create a FixtureMonkey instance val fixtureMonkey = FixtureMonkey.create() // Generate a random object val person = fixtureMonkey.giveMeOne\u0026lt;Person\u0026gt;() How do I add Fixture Monkey to my project?`,content:`How do I get started with Fixture Monkey? # Fixture Monkey provides a simple way to create test objects with random values. Here\u0026rsquo;s how to get started:
Java Kotlin // Create a FixtureMonkey instance FixtureMonkey fixtureMonkey = FixtureMonkey.create(); // Generate a random object Person person = fixtureMonkey.giveMeOne(Person.class); // Create a FixtureMonkey instance val fixtureMonkey = FixtureMonkey.create() // Generate a random object val person = fixtureMonkey.giveMeOne\u0026lt;Person\u0026gt;() How do I add Fixture Monkey to my project? # You can easily add Fixture Monkey to your Maven or Gradle project:
Gradle (Kotlin) Gradle (Groovy) Maven implementation(\u0026#34;com.navercorp.fixturemonkey:fixture-monkey:1.1.x\u0026#34;) implementation \u0026#39;com.navercorp.fixturemonkey:fixture-monkey:1.1.x\u0026#39; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.x\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; How do I specify values for certain fields while keeping others random? # You can use the set() method to specify values for specific fields:
Java Kotlin Person person = fixtureMonkey.giveMeBuilder(Person.class) .set(\u0026#34;name\u0026#34;, \u0026#34;John Doe\u0026#34;) .set(\u0026#34;age\u0026#34;, 25) .sample(); val person = fixtureMonkey.giveMeBuilder\u0026lt;Person\u0026gt;() .setExpGetter(Person::getName, \u0026#34;John Doe\u0026#34;) .setExpGetter(Person::getAge, 25) .sample() How do I control the size of collections like List, Set or Map? # You can control the size of collections using the size() method:
Java Kotlin Person person = fixtureMonkey.giveMeBuilder(Person.class) .size(\u0026#34;friends\u0026#34;, 5) // Sets the size of the friends list to 5 .sample(); // Setting a range for size Product product = fixtureMonkey.giveMeBuilder(Product.class) .size(\u0026#34;tags\u0026#34;, 2, 5) // The tags list will have between 2 and 5 elements .sample(); val person = fixtureMonkey.giveMeBuilder\u0026lt;Person\u0026gt;() .setExpSize(Person::getFriends, 5) // Sets the size of the friends list to 5 .sample() // Setting a range for size val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setExpSize(Product::getTags, 2, 5) // The tags list will have between 2 and 5 elements .sample() How do I handle null values? # You can control null probability using the nullInject option:
Java Kotlin // Create a FixtureMonkey with no null values FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .nullInject(0.0) // Set null probability to 0 .build(); // Create a FixtureMonkey with 50% null probability FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .nullInject(0.5) // Set null probability to 50% .build(); // Set a specific field to null Person person = fixtureMonkey.giveMeBuilder(Person.class) .set(\u0026#34;address\u0026#34;, null) .sample(); // Create a FixtureMonkey with no null values val fixtureMonkey = FixtureMonkey.builder() .nullInject(0.0) // Set null probability to 0 .build() // Create a FixtureMonkey with 50% null probability val fixtureMonkey = FixtureMonkey.builder() .nullInject(0.5) // Set null probability to 50% .build() // Set a specific field to null val person = fixtureMonkey.giveMeBuilder\u0026lt;Person\u0026gt;() .setExpGetter(Person::getAddress, null) .sample() How do I make my tests reproducible? # You can use a fixed seed to generate the same data across test runs:
Java Kotlin // Create a FixtureMonkey with a fixed seed FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .seed(123L) .build(); // Create a FixtureMonkey with a fixed seed val fixtureMonkey = FixtureMonkey.builder() .seed(123L) .build() With JUnit, you can also use the @Seed annotation:
Java Kotlin @Test @Seed(123L) void testWithSeed() { Person person = fixtureMonkey.giveMeOne(Person.class); // The same Person will be generated every time } @Test @Seed(123L) fun testWithSeed() { val person = fixtureMonkey.giveMeOne\u0026lt;Person\u0026gt;() // The same Person will be generated every time } How do I ensure generated objects satisfy certain conditions? # You can use setPostCondition() to filter generated objects that don\u0026rsquo;t meet your criteria:
Java Kotlin // Ensure the person is an adult Person adult = fixtureMonkey.giveMeBuilder(Person.class) .setPostCondition(person -\u0026gt; person.getAge() \u0026gt;= 18) .sample(); // Ensure a specific field meets a condition Product product = fixtureMonkey.giveMeBuilder(Product.class) .setPostCondition(\u0026#34;price\u0026#34;, Double.class, price -\u0026gt; price \u0026gt; 0 \u0026amp;\u0026amp; price \u0026lt; 1000) .sample(); // Ensure the person is an adult val adult = fixtureMonkey.giveMeBuilder\u0026lt;Person\u0026gt;() .setPostCondition { it.age \u0026gt;= 18 } .sample() // Ensure a specific field meets a condition val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setPostConditionExpGetter(Product::getPrice, Double::class.java) { it \u0026gt; 0 \u0026amp;\u0026amp; it \u0026lt; 1000 } .sample() How can I exclude certain values from being generated? # You can use set() with a filter to exclude certain values:
Java Kotlin Product product = sut.giveMeBuilder(Product.class) .set(\u0026#34;productType\u0026#34;, ArbitraryUtils.toCombinableArbitrary(Arbitraries.of(ProductType)).filter(it -\u0026gt; it != CLOTHING \u0026amp;\u0026amp; it != ELECTRONICS)) .sample(); val product = sut.giveMeBuilder\u0026lt;Product\u0026gt;() .setExpGetter(Product::getProductType, ArbitraryUtils.toCombinableArbitrary(Arbitraries.of(ProductType::class.java)).filter { it != ProductType.CLOTHING \u0026amp;\u0026amp; it != ProductType.ELECTRONICS }) .sample() Or you can use setPostCondition() which works like a filter:
Java Kotlin Product product = sut.giveMeBuilder(Product.class) .setPostCondition(\u0026#34;productType\u0026#34;, ProductType.class, it -\u0026gt; it != CLOTHING \u0026amp;\u0026amp; it != ELECTRONICS) .sample(); val product = sut.giveMeBuilder\u0026lt;Product\u0026gt;() .setPostConditionExpGetter(Product::getProductType, ProductType::class.java) { it != ProductType.CLOTHING \u0026amp;\u0026amp; it != ProductType.ELECTRONICS } .sample() Please note that using setPostCondition() can incur higher costs for narrow conditions because it filters after the Product instance has been created. In such cases, it\u0026rsquo;s recommended to use set() instead.
How do I handle nested objects? # Fixture Monkey automatically generates nested objects. You can customize them using a property path:
Java Kotlin Order order = fixtureMonkey.giveMeBuilder(Order.class) .set(\u0026#34;customer.name\u0026#34;, \u0026#34;John Doe\u0026#34;) .set(\u0026#34;customer.address.city\u0026#34;, \u0026#34;New York\u0026#34;) .size(\u0026#34;items\u0026#34;, 3) .set(\u0026#34;items[0].productName\u0026#34;, \u0026#34;Laptop\u0026#34;) .sample(); val order = fixtureMonkey.giveMeBuilder\u0026lt;Order\u0026gt;() .setExp(\u0026#34;customer.name\u0026#34;, \u0026#34;John Doe\u0026#34;) .setExp(\u0026#34;customer.address.city\u0026#34;, \u0026#34;New York\u0026#34;) .sizeExp(\u0026#34;items\u0026#34;, 3) .setExp(\u0026#34;items[0].productName\u0026#34;, \u0026#34;Laptop\u0026#34;) .sample() One of my fields depends on the value of another field. How can I customize my fixture? # The thenApply() method comes in handy when you need to customize a field that relies on another field:
Java Kotlin Money money = fixtureMonkey.giveMeBuilder(Money.class) .set(\u0026#34;currency\u0026#34;, Currency.getInstance(\u0026#34;USD\u0026#34;)) .thenApply((m, builder) -\u0026gt; builder.set(\u0026#34;amount\u0026#34;, m.getCurrency().equals(Currency.getInstance(\u0026#34;USD\u0026#34;)) ? 100.0 : 120.0)) .sample(); val money = fixtureMonkey.giveMeBuilder\u0026lt;Money\u0026gt;() .setExpGetter(Money::getCurrency, Currency.getInstance(\u0026#34;USD\u0026#34;)) .thenApply { money, builder -\u0026gt; builder.setExpGetter(Money::getAmount, if (money.currency == Currency.getInstance(\u0026#34;USD\u0026#34;)) 100.0 else 120.0) } .sample() For more information, check the thenApply() section.
How can I limit the range of characters for my generated Strings? # Related - How can I constrain the range of my generated Instant values?
If you want each generated primitive type to adhere to specific constraints, you can use the javaTypeArbitaryGenerator and javaTimeTypeArbitraryGenerator options.
Java Kotlin // Configure String generation with specific character ranges FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .javaTypeArbitraryGenerator(new JavaTypeArbitraryGenerator() { @Override public StringArbitrary strings() { return Arbitraries.strings().alpha().ofLength(5, 10); } }) .build(); // Configure time generation with specific ranges FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .javaTimeTypeArbitraryGenerator(new JavaTimeTypeArbitraryGenerator() { @Override public Arbitrary\u0026lt;Instant\u0026gt; instant() { Instant start = Instant.parse(\u0026#34;2023-01-01T00:00:00Z\u0026#34;); Instant end = Instant.parse(\u0026#34;2023-12-31T23:59:59Z\u0026#34;); return Arbitraries.instants().between(start, end); } }) .build(); // Configure String generation with specific character ranges val fixtureMonkey = FixtureMonkey.builder() .javaTypeArbitraryGenerator(object : JavaTypeArbitraryGenerator() { override fun strings(): StringArbitrary { return Arbitraries.strings().alpha().ofLength(5, 10) } }) .build() // Configure time generation with specific ranges val fixtureMonkey = FixtureMonkey.builder() .javaTimeTypeArbitraryGenerator(object : JavaTimeTypeArbitraryGenerator() { override fun instant(): Arbitrary\u0026lt;Instant\u0026gt; { val start = Instant.parse(\u0026#34;2023-01-01T00:00:00Z\u0026#34;) val end = Instant.parse(\u0026#34;2023-12-31T23:59:59Z\u0026#34;) return Arbitraries.instants().between(start, end) } }) .build() Throws an exception when generating a certain type # If you encounter exceptions when generating certain types, try using PriorityConstructorArbitraryIntrospector:
Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .pushExactTypeArbitraryIntrospector(ProblematicType.class, PriorityConstructorArbitraryIntrospector.INSTANCE) .build(); // Now generation should work ProblematicType instance = fixtureMonkey.giveMeOne(ProblematicType.class); val fixtureMonkey = FixtureMonkey.builder() .pushExactTypeArbitraryIntrospector(ProblematicType::class.java, PriorityConstructorArbitraryIntrospector.INSTANCE) .build() // Now generation should work val instance = fixtureMonkey.giveMeOne\u0026lt;ProblematicType\u0026gt;() If it does not work, please try to make your own ArbitraryIntrospector or create an issue on GitHub and ask for help.
`}),e.add({id:55,href:"/v1-1-0/docs/plugins/datafaker-plugin/features/",title:"Features",description:`The DataFaker plugin provided by Fixture Monkey allows you to generate more realistic and meaningful test data automatically.
Automatically generates realistic data based on field names (names, addresses, emails, etc.) Leverages the DataFaker library to provide various types of fake data Supports multiple locales to generate country-specific data ðŸ’¡ The DataFaker plugin analyzes String field names and automatically generates appropriate fake data based on keyword matching. Dependencies # Gradle # testImplementation(\u0026quot;com.`,content:`The DataFaker plugin provided by Fixture Monkey allows you to generate more realistic and meaningful test data automatically.
Automatically generates realistic data based on field names (names, addresses, emails, etc.) Leverages the DataFaker library to provide various types of fake data Supports multiple locales to generate country-specific data ðŸ’¡ The DataFaker plugin analyzes String field names and automatically generates appropriate fake data based on keyword matching. Dependencies # Gradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-datafaker:1.1.15\u0026quot;) Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-datafaker\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.15\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; Plugin Setup # FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new DataFakerPlugin()) .build(); Supported Field Types # The DataFaker plugin automatically recognizes String fields containing specific keywords and generates corresponding fake data.
Name Fields # Field names containing: name, firstName, lastName, fullName Generated data: Realistic person names public class User { private String fullName; // \u0026quot;John Doe\u0026quot; private String firstName; // \u0026quot;Jane\u0026quot; private String lastName; // \u0026quot;Smith\u0026quot; } User user = fixtureMonkey.giveMeOne(User.class); Address Fields # Field names containing: address, city Generated data: Realistic address information public class Address { private String homeAddress; // \u0026quot;123 Main Street, Springfield\u0026quot; private String city; // \u0026quot;New York\u0026quot; } Address address = fixtureMonkey.giveMeOne(Address.class); Email Fields # Field names containing: email Generated data: Valid email addresses public class Contact { private String email; // \u0026quot;john.doe@example.com\u0026quot; } Contact contact = fixtureMonkey.giveMeOne(Contact.class); Phone Number Fields # Field names containing: phone, phoneNumber Generated data: Valid phone numbers public class Contact { private String phoneNumber; // \u0026quot;555-123-4567\u0026quot; } Contact contact = fixtureMonkey.giveMeOne(Contact.class); Finance Fields # Field names containing: creditCard Generated data: Valid credit card numbers public class Payment { private String creditCard; // \u0026quot;4532-1234-5678-9012\u0026quot; } Payment payment = fixtureMonkey.giveMeOne(Payment.class); Direct Usage # Direct DataFaker Arbitrary Generation # You can directly use DataFaker arbitrary generators without the plugin:
// Name generation String fullName = DataFakerStringArbitrary.name().fullName(); String firstName = DataFakerStringArbitrary.name().firstName(); String lastName = DataFakerStringArbitrary.name().lastName(); // Address generation String city = DataFakerStringArbitrary.address().city(); String streetName = DataFakerStringArbitrary.address().streetName(); String streetAddress = DataFakerStringArbitrary.address().streetAddress(); String fullAddress = DataFakerStringArbitrary.address().fullAddress(); String zipCode = DataFakerStringArbitrary.address().zipCode(); String state = DataFakerStringArbitrary.address().state(); String country = DataFakerStringArbitrary.address().country(); // Internet-related generation String email = DataFakerStringArbitrary.internet().emailAddress(); String url = DataFakerStringArbitrary.internet().url(); String domainName = DataFakerStringArbitrary.internet().domainName(); String password = DataFakerStringArbitrary.internet().password(); String ipV4 = DataFakerStringArbitrary.internet().ipV4Address(); String ipV6 = DataFakerStringArbitrary.internet().ipV6Address(); // Phone number generation String phone = DataFakerStringArbitrary.phoneNumber().phoneNumber(); String cellPhone = DataFakerStringArbitrary.phoneNumber().cellPhone(); String extension = DataFakerStringArbitrary.phoneNumber().extension(); // Finance-related generation String creditCard = DataFakerStringArbitrary.finance().creditCard(); String iban = DataFakerStringArbitrary.finance().iban(); String bic = DataFakerStringArbitrary.finance().bic(); Locale Support # To generate locale-specific data:
// Generate Korean names String koreanName = DataFakerStringArbitrary.name(Locale.KOREAN).fullName(); // Generate Japanese addresses String japaneseAddress = DataFakerStringArbitrary.address(Locale.JAPANESE).city(); Real-world Example # public class UserProfile { private String userName; private String email; private String homeAddress; private String phoneNumber; private String creditCard; private int age; // Not affected by DataFaker (not String type) private String description; // Not affected by DataFaker (no keyword match) } FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new DataFakerPlugin()) .build(); UserProfile profile = fixtureMonkey.giveMeOne(UserProfile.class); // userName: \u0026quot;Michael Johnson\u0026quot; // email: \u0026quot;sarah.wilson@example.org\u0026quot; // homeAddress: \u0026quot;456 Oak Avenue, Boston\u0026quot; // phoneNumber: \u0026quot;555-987-6543\u0026quot; // creditCard: \u0026quot;4532-8765-4321-0987\u0026quot; // age: random integer (uses default generator) // description: random string (uses default generator) âš ï¸ The DataFaker plugin only applies to String type fields that contain specific keywords in their names. Other field types or fields without matching keywords will use the default generators. `}),e.add({id:56,href:"/v1-1-0/docs/migration-guide/",title:"Migration guide",description:"",content:""}),e.add({id:57,href:"/v1-1-0/docs/",title:"Docs",description:"",content:""}),search.addEventListener("input",t,!0);function t(){const s=4,o=300;var n=this.value,i=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of i.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[c,r]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href="/fixture-monkey"+c,n.appendChild(e);const i=document.createElement("span");i.textContent=r.title,i.classList.add("suggestion__title"),e.appendChild(i);const a=document.createElement("span");if(a.textContent=r.description.substring(0,o),a.classList.add("suggestion__description"),e.appendChild(a),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()
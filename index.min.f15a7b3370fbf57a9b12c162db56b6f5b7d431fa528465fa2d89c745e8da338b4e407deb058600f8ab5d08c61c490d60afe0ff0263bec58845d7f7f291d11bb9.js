var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",resolution:9,minlength:3,optimize:!0,fastupdate:!0,cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/v1-1-0/docs/introduction/",title:"Introduction",description:"",content:""}),e.add({id:1,href:"/v1-1-0/docs/migration-guide/migration-guide/",title:"From 1.0.x",description:`Migrating from 1.0.x to 1.1.x # This guide helps you update your code from Fixture Monkey 1.0.x to 1.1.x. We\u0026rsquo;ve made several improvements to make the library easier to use while maintaining backward compatibility where possible.
Major Changes at a Glance # Better handling of Kotlin types Separate APIs for Java and Kotlin Simpler way to handle abstract types and interfaces Kotlin Type Handling Improvements # What Changed # Before (1.`,content:`Migrating from 1.0.x to 1.1.x # This guide helps you update your code from Fixture Monkey 1.0.x to 1.1.x. We\u0026rsquo;ve made several improvements to make the library easier to use while maintaining backward compatibility where possible.
Major Changes at a Glance # Better handling of Kotlin types Separate APIs for Java and Kotlin Simpler way to handle abstract types and interfaces Kotlin Type Handling Improvements # What Changed # Before (1.0.x): When using KotlinPlugin, both Java and Kotlin types were created using Kotlin\u0026rsquo;s primary constructor approach. This caused errors when creating Java types. Now (1.1.x): Each language uses its appropriate object creation strategy: Java types â†’ Created using bean properties (getters/setters) Kotlin types â†’ Created using Kotlin primary constructors What You Need to Do # No changes needed. Your Java types will now work correctly with the KotlinPlugin.
Java and Kotlin Now Have Separate APIs # What Changed # Before (1.0.x): Same ArbitraryBuilder API for both Java and Kotlin Now (1.1.x): Specialized APIs for each language to provide a more natural experience Java API # Use one of these methods to get a Java-optimized builder:
// Java style API ArbitraryBuilder\u0026lt;User\u0026gt; userBuilder = fixtureMonkey.giveMeBuilder(User.class); // or explicitly request Java builder ArbitraryBuilder\u0026lt;User\u0026gt; userBuilder = fixtureMonkey.giveMeJavaBuilder(User.class); Kotlin API # Use Kotlin extension functions for a more idiomatic Kotlin experience:
// Kotlin style API with extension function val userBuilder = fixtureMonkey.giveMeKotlinBuilder\u0026lt;User\u0026gt;() Note: You can still use Java APIs with Kotlin types and vice versa if needed.
Simpler Way to Handle Abstract Types # What Changed # Before (1.0.x): Required complex ObjectPropertyGenerator configuration to implement abstract types or interfaces Now (1.1.x): Simpler CandidateConcretePropertyResolver lets you focus only on which implementations to use Example: Handling Sealed Classes # Before (1.0.x) - Complex Configuration # You needed to understand many details about ObjectProperty:
public final class SealedTypeObjectPropertyGenerator implements ObjectPropertyGenerator { @Override public ObjectProperty generate(ObjectPropertyGeneratorContext context) { Property sealedTypeProperty = context.getProperty(); double nullInject = context.getNullInjectGenerator().generate(context); Class\u0026lt;?\u0026gt; actualType = Types.getActualType(sealedTypeProperty.getType()); Set\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; permittedSubclasses = collectPermittedSubclasses(actualType); Map\u0026lt;Property, List\u0026lt;Property\u0026gt;\u0026gt; childPropertiesByProperty = permittedSubclasses.stream() .collect( toUnmodifiableMap( Function.identity(), it -\u0026gt; context.getPropertyGenerator().generateChildProperties(it) ) ); return new ObjectProperty( sealedTypeProperty, context.getPropertyNameResolver(), nullInject, context.getElementIndex(), childPropertiesByProperty ); } private static Set\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; collectPermittedSubclasses(Class\u0026lt;?\u0026gt; type) { Set\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; subclasses = new HashSet\u0026lt;\u0026gt;(); doCollectPermittedSubclasses(type, subclasses); return subclasses; } private static void doCollectPermittedSubclasses(Class\u0026lt;?\u0026gt; type, Set\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; subclasses) { if (type.isSealed()) { for (Class\u0026lt;?\u0026gt; subclass : type.getPermittedSubclasses()) { doCollectPermittedSubclasses(subclass, subclasses); } } else { subclasses.add(type); } } } Now (1.1.x) - Simpler Approach # Just focus on which implementation classes to use:
public final class SealedTypeCandidateConcretePropertyResolver implements CandidateConcretePropertyResolver { @Override public List\u0026lt;Property\u0026gt; resolve(Property property) { Class\u0026lt;?\u0026gt; actualType = Types.getActualType(property.getType()); Set\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; permittedSubclasses = collectPermittedSubclasses(actualType); return permittedSubclasses.stream() .map(PropertyUtils::toProperty) .toList(); } private static Set\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; collectPermittedSubclasses(Class\u0026lt;?\u0026gt; type) { Set\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; subclasses = new HashSet\u0026lt;\u0026gt;(); doCollectPermittedSubclasses(type, subclasses); return subclasses; } private static void doCollectPermittedSubclasses(Class\u0026lt;?\u0026gt; type, Set\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; subclasses) { if (type.isSealed()) { for (Class\u0026lt;?\u0026gt; subclass : type.getPermittedSubclasses()) { doCollectPermittedSubclasses(subclass, subclasses); } } else { subclasses.add(type); } } } Summary of Benefits # Better Language Support: Each language (Java/Kotlin) now uses its natural creation approach More Intuitive APIs: Language-specific APIs that feel more natural to use Simpler Complex Type Handling: Less boilerplate code when working with interfaces, abstract classes, and sealed types These changes make Fixture Monkey 1.1.x easier to use while maintaining compatibility with most of your existing code.
`}),e.add({id:2,href:"/v1-1-0/docs/introduction/overview/",title:"Overview",description:`Fixture Monkey # Fixture Monkey is a Java \u0026amp; Kotlin library designed to generate controllable arbitrary test objects. Its most distinctive feature is the ability to freely access and configure any nested fields through path-based expressions.
It focuses on simplifying test writing, by facilitating the generation of necessary test fixtures. Whether you\u0026rsquo;re dealing with basic or complex test fixtures, Fixture Monkey helps you to effortlessly create the test objects you need and easily customize them to match your desired configurations.`,content:`Fixture Monkey # Fixture Monkey is a Java \u0026amp; Kotlin library designed to generate controllable arbitrary test objects. Its most distinctive feature is the ability to freely access and configure any nested fields through path-based expressions.
It focuses on simplifying test writing, by facilitating the generation of necessary test fixtures. Whether you\u0026rsquo;re dealing with basic or complex test fixtures, Fixture Monkey helps you to effortlessly create the test objects you need and easily customize them to match your desired configurations.
Make your JVM tests more concise and safe with Fixture Monkey.
Quick Start # Add Fixture Monkey to your project:
Java Kotlin dependencies { testImplementation \u0026#39;com.navercorp.fixturemonkey:fixture-monkey-starter:1.1.11\u0026#39; } dependencies { testImplementation(\u0026#34;com.navercorp.fixturemonkey:fixture-monkey-starter-kotlin:1.1.11\u0026#34;) } Create your first test object:
FixtureMonkey fixtureMonkey = FixtureMonkey.create(); // Basic type generation String randomString = fixtureMonkey.giveMeOne(String.class); Integer randomNumber = fixtureMonkey.giveMeOne(Integer.class); // Collection generation List\u0026lt;String\u0026gt; randomStrings = fixtureMonkey.giveMe(String.class, 3); Set\u0026lt;Integer\u0026gt; randomNumbers = fixtureMonkey.giveMe(Set.class, Integer.class, 5); // Complex object generation class User { String name; int age; List\u0026lt;Address\u0026gt; addresses; } class Address { String city; String street; } // Single object generation User user = fixtureMonkey.giveMeOne(User.class); // Multiple objects generation List\u0026lt;User\u0026gt; users = fixtureMonkey.giveMe(User.class, 3); // Nested object generation User userWithAddresses = fixtureMonkey.giveMeBuilder(User.class) .size(\u0026quot;addresses\u0026quot;, 2) .sample(); Why use Fixture Monkey? # 1. One-Line Test Object Generation # // Before: Manual object creation Product product = new Product(); product.setId(1L); product.setName(\u0026quot;Test Product\u0026quot;); product.setPrice(1000); product.setCreatedAt(LocalDateTime.now()); // After: With Fixture Monkey Product product = fixtureMonkey.giveMeOne(Product.class); Stop writing boilerplate code for test object creation. Fixture Monkey generates any test object with a single line of code. Transform your test preparation from a tedious chore into a simple, elegant solution. No changes to production code or test environment required.
2. Intuitive Path-Based Configuration # class Order { List\u0026lt;OrderItem\u0026gt; items; Customer customer; Address shippingAddress; } class OrderItem { Product product; int quantity; } class Product { String name; List\u0026lt;Review\u0026gt; reviews; } // Set all product names to \u0026quot;Special Product\u0026quot; ArbitraryBuilder\u0026lt;Order\u0026gt; orderBuilder = fixtureMonkey.giveMeBuilder(Order.class) .set(\u0026quot;items[*].product.name\u0026quot;, \u0026quot;Special Product\u0026quot;); // Set all review ratings to 5 stars ArbitraryBuilder\u0026lt;Order\u0026gt; orderWithGoodReviews = fixtureMonkey.giveMeBuilder(Order.class) .set(\u0026quot;items[*].product.reviews[*].rating\u0026quot;, 5); // Set all quantities to 2 ArbitraryBuilder\u0026lt;Order\u0026gt; orderWithFixedQuantity = fixtureMonkey.giveMeBuilder(Order.class) .set(\u0026quot;items[*].quantity\u0026quot;, 2); Bid farewell to endless getter/setter chains. Fixture Monkey\u0026rsquo;s path expressions let you configure any nested field with a single line. The [*] wildcard operator empowers you to manipulate entire collections effortlessly, dramatically reducing boilerplate code and enhancing test maintainability.
3. Reusable Test Specifications # // Define a reusable builder ArbitraryBuilder\u0026lt;Product\u0026gt; productBuilder = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026quot;category\u0026quot;, \u0026quot;Book\u0026quot;) .set(\u0026quot;price\u0026quot;, 1000); // Reuse in different tests @Test void testProductCreation() { Product product = productBuilder.sample(); assertThat(product.getCategory()).isEqualTo(\u0026quot;Book\u0026quot;); assertThat(product.getPrice()).isEqualTo(1000); } @Test void testProductWithReviews() { Product product = productBuilder .size(\u0026quot;reviews\u0026quot;, 3) .sample(); assertThat(product.getReviews()).hasSize(3); } @Test void testProductWithSpecificReview() { Product product = productBuilder .set(\u0026quot;reviews[0].rating\u0026quot;, 5) .set(\u0026quot;reviews[0].comment\u0026quot;, \u0026quot;Excellent!\u0026quot;) .sample(); assertThat(product.getReviews().get(0).getRating()).isEqualTo(5); assertThat(product.getReviews().get(0).getComment()).isEqualTo(\u0026quot;Excellent!\u0026quot;); } Eliminate test code duplication. Define complex object specifications once and reuse them across your test suite. ArbitraryBuilder\u0026rsquo;s lazy evaluation ensures objects are only created when needed, optimizing your test performance.
4. Universal Object Generation # // inheritance class Foo { String foo; } class Bar extends Foo { String bar; } Foo foo = FixtureMonkey.create().giveMeOne(Foo.class); Bar bar = FixtureMonkey.create().giveMeOne(Bar.class); // circular-reference class Foo { String value; Foo foo; } Foo foo = FixtureMonkey.create().giveMeOne(Foo.class); // anonymous objects interface Foo { Bar getBar(); } class Bar { String value; } Foo foo = FixtureMonkey.create().giveMeOne(Foo.class); From simple POJOs to complex object graphs, Fixture Monkey handles it all. Generate lists, nested collections, enums, generic types, and even objects with inheritance relationships or circular references. No object structure is too complex for Fixture Monkey.
5. Dynamic Test Data # ArbitraryBuilder\u0026lt;Product\u0026gt; actual = fixtureMonkey.giveMeBuilder(Product.class); then(actual.sample()).isNotEqualTo(actual.sample()); Move beyond static test data. Fixture Monkey\u0026rsquo;s random value generation helps you discover edge cases that static data might miss. Make your tests more robust by testing with varied data in every run.
Real Test Example # @Test void testOrderProcessing() { // Given Order order = fixtureMonkey.giveMeBuilder(Order.class) .set(\u0026quot;items[*].quantity\u0026quot;, 2) .set(\u0026quot;items[*].product.price\u0026quot;, 1000) .sample(); OrderProcessor processor = new OrderProcessor(); // When OrderResult result = processor.process(order); // Then assertThat(result.getTotalAmount()).isEqualTo(4000); // 2 items * 2 quantity * 1000 price assertThat(result.getStatus()).isEqualTo(OrderStatus.COMPLETED); } Battle-Tested in Production # Originally developed at Naver, Fixture Monkey played a pivotal role in the Plasma project, revolutionizing Naver Pay\u0026rsquo;s architecture. Supporting over 10,000 tests for South Korea\u0026rsquo;s leading mobile payment service, Fixture Monkey has proven its reliability in handling complex business requirements at scale. Now available as open-source, bring this battle-tested solution to your projects and write more reliable tests with confidence.
`}),e.add({id:3,href:"/v1-1-0/docs/get-started/",title:"Getting Started",description:"",content:""}),e.add({id:4,href:"/v1-1-0/docs/get-started/requirements/",title:"Requirements",description:"ðŸ’¡ Fixture Monkey is designed for test environments. It is not recommended for production use. Prerequisites # JDK 1.8 or higher (Or Kotlin 1.8 or higher) JUnit 5 platform jqwik 1.7.3 Dependencies # Dependency Description fixture-monkey Core library fixture-monkey-starter Starter dependency for fixture monkey fixture-monkey-kotlin Kotlin support fixture-monkey-starter-kotlin Starter dependency for fixture monkey kotlin fixture-monkey-starter is a starter dependency that comes with pre-configured dependencies such as fixture-monkey-jakarta-validation to help you get started using Fixture Monkey.",content:` ðŸ’¡ Fixture Monkey is designed for test environments. It is not recommended for production use. Prerequisites # JDK 1.8 or higher (Or Kotlin 1.8 or higher) JUnit 5 platform jqwik 1.7.3 Dependencies # Dependency Description fixture-monkey Core library fixture-monkey-starter Starter dependency for fixture monkey fixture-monkey-kotlin Kotlin support fixture-monkey-starter-kotlin Starter dependency for fixture monkey kotlin fixture-monkey-starter is a starter dependency that comes with pre-configured dependencies such as fixture-monkey-jakarta-validation to help you get started using Fixture Monkey.
For Kotlin environments, you can use fixture-monkey-starter-kotlin
Gradle # Add junit-platform-launcher as a runtime dependency. The dependency is optional below Gradle 9, but it will be mandatory from Gradle 9 onwards.
ðŸ“” Gradle Offical Documentation âš ï¸ Issue
testRuntimeOnly(\u0026quot;org.junit.platform:junit-platform-launcher:{version}\u0026quot;) testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-starter:1.1.11\u0026quot;) Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.11\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; Third party library support # Dependency Description fixture-monkey-jackson Jackson support for serialization and deserialization of objects fixture-monkey-jakarta-validation Support for Jakarta Bean Validation (JSR 380) annotations fixture-monkey-javax-validation Support for Javax Bean Validation (JSR 303/349) annotations fixture-monkey-mockito Support for Mockito mocking framework fixture-monkey-autoparams Support for AutoParams test data generation fixture-monkey-junit-jupiter Support for JUnit Jupiter test framework fixture-monkey-kotest Support for Kotest test framework `}),e.add({id:5,href:"/v1-1-0/docs/get-started/creating-objects/",title:"Creating objects",description:`Fixture Monkey works in both Java and Kotlin. We have a separate \u0026lsquo;Getting Started\u0026rsquo; page for each environment you can use: Java, Java without Lombok, and Kotlin.
This page explains the Java environment. Please refer to the appropriate page for your environment.
Creating test objects with Fixture Monkey is remarkably simple. Here\u0026rsquo;s how you can use it:
@Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build(); // when Product actual = fixtureMonkey.`,content:` Fixture Monkey works in both Java and Kotlin. We have a separate \u0026lsquo;Getting Started\u0026rsquo; page for each environment you can use: Java, Java without Lombok, and Kotlin.
This page explains the Java environment. Please refer to the appropriate page for your environment.
Creating test objects with Fixture Monkey is remarkably simple. Here\u0026rsquo;s how you can use it:
@Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build(); // when Product actual = fixtureMonkey.giveMeOne(Product.class); // then then(actual).isNotNull(); } When you run this code, Fixture Monkey will generate a Product instance with random values. Below is just an example, and the actual values will be different each time:
Product( id=42, productName=\u0026quot;product-value-1\u0026quot;, price=1000, options=[\u0026quot;option1\u0026quot;, \u0026quot;option2\u0026quot;], createdAt=2024-03-21T10:15:30Z, productType=ELECTRONICS, merchantInfo={1=\u0026quot;merchant1\u0026quot;, 2=\u0026quot;merchant2\u0026quot;} ) First, create a FixtureMonkey instance that facilitates the creation of test fixtures. There are several custom options available in Fixture Monkey that allow you to generate instances according to your specific requirements.
Here we are configuring the objectIntrospector to use ConstructorPropertiesArbitraryIntrospector, which means that the object will be constructed using the constructor annotated with @ConstructorProperties. An Introspector defines how Fixture Monkey generates objects.
For example, consider a Product class like this:
ðŸ’¡ lombok.anyConstructor.addConstructorProperties=true should be added in lombok.config @Value public class Product { long id; String productName; long price; List\u0026lt;String\u0026gt; options; Instant createdAt; ProductType productType; Map\u0026lt;Integer, String\u0026gt; merchantInfo; } (Note that the Lombok annotation @Value is used to make Immutable classes. If you\u0026rsquo;re working in an environment without Lombok, go to creating test objects without lombok)
For ConstructorPropertiesArbitraryIntrospector, the generated class should have a constructor with @ConstructorProperties or you can add lombok.anyConstructor.addConstructorProperties=true in the lombok.config file. (There are alternative Introspectors available, each with their own requirements. Check out the Introspectors section for more details.)
As shown in the then section above, an instance of the Product class is created.
`}),e.add({id:6,href:"/v1-1-0/docs/get-started/creating-objects-without-lombok/",title:"Creating objects without Lombok",description:`ðŸ’¡ If you're using Lombok in your project, feel free to move on to the next page. Creating test objects with Fixture Monkey is remarkably simple, even without Lombok. Here\u0026rsquo;s how you can use it:
@Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.create(); // when Product actual = fixtureMonkey.giveMeOne(Product.class); // then then(actual).isNotNull(); } When you run this code, Fixture Monkey will generate a Product instance with random values.`,content:` ðŸ’¡ If you're using Lombok in your project, feel free to move on to the next page. Creating test objects with Fixture Monkey is remarkably simple, even without Lombok. Here\u0026rsquo;s how you can use it:
@Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.create(); // when Product actual = fixtureMonkey.giveMeOne(Product.class); // then then(actual).isNotNull(); } When you run this code, Fixture Monkey will generate a Product instance with random values. Below is just an example, and the actual values will be different each time:
Product( id=42, productName=\u0026quot;product-value-1\u0026quot;, price=1000, options=[\u0026quot;option1\u0026quot;, \u0026quot;option2\u0026quot;], createdAt=2024-03-21T10:15:30Z, productType=ELECTRONICS, merchantInfo={1=\u0026quot;merchant1\u0026quot;, 2=\u0026quot;merchant2\u0026quot;} ) First, create a FixtureMonkey instance that facilitates the creation of test fixtures. You can use create() to generate a Fixture Monkey instance with default options. There are also several custom options available in Fixture Monkey that allow you to generate instances according to your specific requirements.
Fixture Monkey uses BeanArbitraryIntrospector as its default method for generating objects. An Introspector defines how Fixture Monkey generates objects.
For example, consider a Product class like this:
public class Product { private long id; private String productName; private long price; private List\u0026lt;String\u0026gt; options; private Instant createdAt; private ProductType productType; private Map\u0026lt;Integer, String\u0026gt; merchantInfo; public Product() { } public void setId(long id) { this.id = id; } public void setProductName(String productName) { this.productName = productName; } public void setPrice(long price) { this.price = price; } public void setOptions(List\u0026lt;String\u0026gt; options) { this.options = options; } public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; } public void setProductType(ProductType productType) { this.productType = productType; } public void setMerchantInfo(Map\u0026lt;Integer, String\u0026gt; merchantInfo) { this.merchantInfo = merchantInfo; } } For BeanArbitraryIntrospector, the class being generated needs to have a no-args constructor and setters, as shown in the Product class above. The introspector will create an instance using the no-args constructor and then set random values using the setter methods. (There are alternative Introspectors available, each with their own requirements. Check out the Introspectors section for more details.)
`}),e.add({id:7,href:"/v1-1-0/docs/get-started/creating-objects-in-kotlin/",title:"Creating objects in Kotlin",description:`Fixture Monkey helps you create test objects for your Kotlin classes easily. For example, suppose you have a Kotlin data class:
data class Product ( val id: Long, val productName: String, val price: Long, val options: List\u0026lt;String\u0026gt;, val createdAt: Instant, val productType: ProductType, val merchantInfo: Map\u0026lt;Int, String\u0026gt; ) With Fixture Monkey, you can create test instances of this class with just one line of code:
val product: Product = fixtureMonkey.giveMeOne() The generated object will contain random values that make sense for each field type.`,content:`Fixture Monkey helps you create test objects for your Kotlin classes easily. For example, suppose you have a Kotlin data class:
data class Product ( val id: Long, val productName: String, val price: Long, val options: List\u0026lt;String\u0026gt;, val createdAt: Instant, val productType: ProductType, val merchantInfo: Map\u0026lt;Int, String\u0026gt; ) With Fixture Monkey, you can create test instances of this class with just one line of code:
val product: Product = fixtureMonkey.giveMeOne() The generated object will contain random values that make sense for each field type. Here\u0026rsquo;s an example of what you might get:
Product( id=42, productName=\u0026quot;product-value-1\u0026quot;, price=1000, options=[\u0026quot;option1\u0026quot;, \u0026quot;option2\u0026quot;], createdAt=2024-03-21T10:15:30Z, productType=ELECTRONICS, merchantInfo={1=\u0026quot;merchant1\u0026quot;, 2=\u0026quot;merchant2\u0026quot;} ) To start using Fixture Monkey with Kotlin, follow these steps:
Add the fixture-monkey-starter-kotlin dependency to your project.
Create a FixtureMonkey instance with the Kotlin plugin:
@Test fun test() { val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .build() } The Kotlin plugin enables Fixture Monkey to work with Kotlin\u0026rsquo;s features, using the primary constructor to create objects.
Here\u0026rsquo;s a complete test example:
@Test fun test() { // given val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .build() // when val actual: Product = fixtureMonkey.giveMeOne() // then then(actual).isNotNull } You can also customize the generated objects using Kotlin\u0026rsquo;s property references:
@Test fun test() { // given val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .build(); // when val actual = fixtureMonkey.giveMeKotlinBuilder\u0026lt;Product\u0026gt;() .set(Product::id, 1000L) // Set specific id .size(Product::options, 3) // Set options list size .set(Product::options[1], \u0026quot;red\u0026quot;) // Set specific option .sample() // then then(actual.id).isEqualTo(1000L) then(actual.options).hasSize(3) then(actual.options[1]).isEqualTo(\u0026quot;red\u0026quot;) } For more Kotlin-specific features, check out the Kotlin Plugin documentation.
`}),e.add({id:8,href:"/v1-1-0/docs/get-started/adding-bean-validation/",title:"Adding Bean Validation",description:`Sometimes, you might want to create a valid test object that adheres to the constraints specified by the Bean Validation annotations on your class. Fixture Monkey makes this easy with support for jakarta.validation.constraints and javax.validation.constraints packages.
For example, consider a Product class with validation constraints:
@Value public class Product { @Min(1) long id; @NotBlank String productName; @Max(100000) long price; @Size(min = 3) List\u0026lt;@NotBlank String\u0026gt; options; @Past Instant createdAt; } To generate objects that satisfy these constraints, first add the appropriate dependency:`,content:`Sometimes, you might want to create a valid test object that adheres to the constraints specified by the Bean Validation annotations on your class. Fixture Monkey makes this easy with support for jakarta.validation.constraints and javax.validation.constraints packages.
For example, consider a Product class with validation constraints:
@Value public class Product { @Min(1) long id; @NotBlank String productName; @Max(100000) long price; @Size(min = 3) List\u0026lt;@NotBlank String\u0026gt; options; @Past Instant createdAt; } To generate objects that satisfy these constraints, first add the appropriate dependency:
Gradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-jakarta-validation:1.1.11\u0026quot;) Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-jakarta-validation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.11\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; Then, add the validation plugin to your FixtureMonkey configuration:
FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JakartaValidationPlugin()) // or new JavaxValidationPlugin() .build(); Note: If you\u0026rsquo;re using fixture-monkey-starter, the validation plugin is already included.
Now you can generate valid objects that satisfy all constraints:
@Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .plugin(new JakartaValidationPlugin()) .build(); // when Product actual = fixtureMonkey.giveMeOne(Product.class); // then then(actual).isNotNull(); then(actual.getId()).isGreaterThan(0); then(actual.getProductName()).isNotBlank(); then(actual.getPrice()).isLessThanOrEqualTo(100000); then(actual.getOptions().size()).isGreaterThanOrEqualTo(3); then(actual.getOptions()).allSatisfy(it -\u0026gt; then(it).isNotEmpty()); then(actual.getCreatedAt()).isNotNull().isLessThanOrEqualTo(Instant.now()); } When you run this code, Fixture Monkey will generate a Product instance that satisfies all validation constraints. Below is just an example, and the actual values will be different each time:
Product( id=42, // Satisfies @Min(1) productName=\u0026quot;product-1\u0026quot;, // Satisfies @NotBlank price=75000, // Satisfies @Max(100000) options=[ // Satisfies @Size(min = 3) \u0026quot;option1\u0026quot;, // Each string satisfies @NotBlank \u0026quot;option2\u0026quot;, \u0026quot;option3\u0026quot; ], createdAt=2024-03-20T10:15:30Z // Satisfies @Past ) `}),e.add({id:9,href:"/v1-1-0/docs/get-started/customizing-objects/",title:"Customizing objects",description:`Fixture Monkey allows you to customize test objects to match your specific test requirements. Let\u0026rsquo;s see how it works with a real-world example.
Why Customize Test Objects? # Suppose you\u0026rsquo;re testing a discount service that applies a 10% discount only to products priced over 1000. You need to test both scenarios:
Products that should get a discount (price \u0026gt; 1000) Products that shouldn\u0026rsquo;t get a discount (price â‰¤ 1000) Without Fixture Monkey, you might write code like this:`,content:`Fixture Monkey allows you to customize test objects to match your specific test requirements. Let\u0026rsquo;s see how it works with a real-world example.
Why Customize Test Objects? # Suppose you\u0026rsquo;re testing a discount service that applies a 10% discount only to products priced over 1000. You need to test both scenarios:
Products that should get a discount (price \u0026gt; 1000) Products that shouldn\u0026rsquo;t get a discount (price â‰¤ 1000) Without Fixture Monkey, you might write code like this:
// Without Fixture Monkey Product expensiveProduct = new Product(1, \u0026quot;Expensive Product\u0026quot;, 2000, ...); Product cheapProduct = new Product(2, \u0026quot;Cheap Product\u0026quot;, 500, ...); With Fixture Monkey, you can create these test objects more easily and flexibly.
Step-by-Step Guide # Let\u0026rsquo;s start with a simple Product class:
@Value public class Product { long id; String productName; long price; List\u0026lt;String\u0026gt; options; Instant createdAt; } Step 1: Create a FixtureMonkey Instance # First, create a FixtureMonkey instance with the appropriate introspector:
Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build(); val fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build() Step 2: Create a Product with Specific Price # Now, let\u0026rsquo;s create a product with a price of 2000 to test the discount scenario:
Java Kotlin @Test void testDiscountApplied() { // given Product expensiveProduct = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026#34;price\u0026#34;, 2000L) // Set price to 2000 .sample(); // when double discount = discountService.calculateDiscount(expensiveProduct); // then then(discount).isEqualTo(200.0); // 10% of 2000 } @Test fun testDiscountApplied() { // given val expensiveProduct = fixtureMonkey.giveMeBuilder(Product::class.java) .set(\u0026#34;price\u0026#34;, 2000L) // Set price to 2000 .sample() // when val discount = discountService.calculateDiscount(expensiveProduct) // then then(discount).isEqualTo(200.0) // 10% of 2000 } Step 3: Create a Product with Customized List # You can also customize collections. For example, to test a product with specific options:
Java Kotlin @Test void testProductWithOptions() { // given Product actual = fixtureMonkey.giveMeBuilder(Product.class) .size(\u0026#34;options\u0026#34;, 3) // Set list size to 3 .set(\u0026#34;options[1]\u0026#34;, \u0026#34;red\u0026#34;) // Set second element to \u0026#34;red\u0026#34; .sample(); // then then(actual.getOptions()).hasSize(3); then(actual.getOptions().get(1)).isEqualTo(\u0026#34;red\u0026#34;); } @Test fun testProductWithOptions() { // given val actual = fixtureMonkey.giveMeBuilder(Product::class.java) .size(\u0026#34;options\u0026#34;, 3) // Set list size to 3 .set(\u0026#34;options[1]\u0026#34;, \u0026#34;red\u0026#34;) // Set second element to \u0026#34;red\u0026#34; .sample() // then then(actual.options).hasSize(3) then(actual.options[1]).isEqualTo(\u0026#34;red\u0026#34;) } The generated Product will look like this:
Product( id=42, // Random value productName=\u0026quot;product-value-1\u0026quot;, // Random value price=2000, // Customized value options=[\u0026quot;option1\u0026quot;, \u0026quot;option2\u0026quot;], // Random values createdAt=2024-03-21T10:15:30Z // Random value ) Common Pitfalls and Tips # Field Names Use exact field names as they appear in your class Wrong: set(\u0026quot;product_name\u0026quot;, \u0026quot;test\u0026quot;) (field name mismatch) Right: set(\u0026quot;productName\u0026quot;, \u0026quot;test\u0026quot;) Tip: Use IDE\u0026rsquo;s code completion to avoid typos in field names Tip: Use setExp or setExpGetter for type-safe field access Tip: Install the Fixture Monkey Helper for enhanced code completion and type safety Java Kotlin // Type-safe field access .set(javaGetter(Product::getProductName), \u0026#34;test\u0026#34;) // Type-safe field access .setExp(Product::productName, \u0026#34;test\u0026#34;) // or .setExpGetter(Product::productName, { \u0026#34;test\u0026#34; }) Collection Indexing
Remember that list indices start at 0 Wrong: set(\u0026quot;options[3]\u0026quot;, \u0026quot;red\u0026quot;) (for a list of size 3) Right: set(\u0026quot;options[2]\u0026quot;, \u0026quot;red\u0026quot;) Tip: Use size() before setting specific indices to ensure the list is large enough Type Safety
Make sure to use the correct type for values Wrong: set(\u0026quot;price\u0026quot;, \u0026quot;1000\u0026quot;) (String instead of Long) Right: set(\u0026quot;price\u0026quot;, 1000L) Tip: Use IDE\u0026rsquo;s type hints to ensure correct value types Comparison: Before and After # Before Fixture Monkey:
// Creating a product with specific options List\u0026lt;String\u0026gt; options = new ArrayList\u0026lt;\u0026gt;(); options.add(\u0026quot;option1\u0026quot;); options.add(\u0026quot;red\u0026quot;); options.add(\u0026quot;option3\u0026quot;); Product product = new Product(1, \u0026quot;Test Product\u0026quot;, 1000, options, Instant.now()); After Fixture Monkey:
// Same result with much less code Product product = fixtureMonkey.giveMeBuilder(Product.class) .size(\u0026quot;options\u0026quot;, 3) .set(\u0026quot;options[1]\u0026quot;, \u0026quot;red\u0026quot;) .sample(); For more examples of how to select properties with expressions and set property values, check out the customizing section.
`}),e.add({id:10,href:"/v1-1-0/docs/get-started/tips/",title:"Tips for Beginners",description:"Essential Tips for Using Fixture Monkey # 1. Use Type-Safe Methods # Prefer type-safe methods over string-based ones Example: // Instead of .set(\u0026quot;price\u0026quot;, 1000L) // Use .set(javaGetter(Product::getPrice), 1000L) 2. Use Meaningful Test Data # Use values that make sense in your test context Avoid using arbitrary values like \u0026ldquo;test\u0026rdquo; or \u0026ldquo;123\u0026rdquo; Consider business rules and constraints when setting values Benefits: Makes tests more readable and self-documenting Helps identify test failures more quickly Makes it easier to understand test scenarios Reduces the need for additional comments Example: // Use meaningful values Product product = fixtureMonkey.",content:`Essential Tips for Using Fixture Monkey # 1. Use Type-Safe Methods # Prefer type-safe methods over string-based ones Example: // Instead of .set(\u0026quot;price\u0026quot;, 1000L) // Use .set(javaGetter(Product::getPrice), 1000L) 2. Use Meaningful Test Data # Use values that make sense in your test context Avoid using arbitrary values like \u0026ldquo;test\u0026rdquo; or \u0026ldquo;123\u0026rdquo; Consider business rules and constraints when setting values Benefits: Makes tests more readable and self-documenting Helps identify test failures more quickly Makes it easier to understand test scenarios Reduces the need for additional comments Example: // Use meaningful values Product product = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026quot;price\u0026quot;, 1000L) // Use realistic price that matches business rules .set(\u0026quot;name\u0026quot;, \u0026quot;Premium Product\u0026quot;) // Use descriptive name that indicates product type .set(\u0026quot;category\u0026quot;, \u0026quot;ELECTRONICS\u0026quot;) // Use valid category from your domain .set(\u0026quot;stock\u0026quot;, 50) // Use reasonable stock quantity .sample(); 3. Keep Tests Readable # Add comments to explain why specific values are set Example: Product product = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026quot;price\u0026quot;, 2000L) // Price above discount threshold .set(\u0026quot;category\u0026quot;, \u0026quot;PREMIUM\u0026quot;) // Category that gets special treatment .sample(); 4. Handle Collections Properly # Set collection size before accessing specific indices Example: Product product = fixtureMonkey.giveMeBuilder(Product.class) .size(\u0026quot;options\u0026quot;, 3) // Set size first .set(\u0026quot;options[1]\u0026quot;, \u0026quot;red\u0026quot;) // Then access specific index .sample(); 5. Reuse FixtureMonkey Instance # Create one instance and reuse it across tests Example: public class ProductTest { private static final FixtureMonkey FIXTURE_MONKEY = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build(); @Test void test1() { Product product = FIXTURE_MONKEY.giveMeBuilder(Product.class).sample(); // ... } @Test void test2() { Product product = FIXTURE_MONKEY.giveMeBuilder(Product.class).sample(); // ... } } 6. Reuse ArbitraryBuilder # Reuse ArbitraryBuilder instances to maintain consistent test data structure Share common configurations across multiple tests Improve code readability by centralizing test data setup Example: public class ProductTest { private static final FixtureMonkey FIXTURE_MONKEY = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build(); // Base configuration for premium products private static final ArbitraryBuilder\u0026lt;Product\u0026gt; PREMIUM_PRODUCT_BUILDER = FIXTURE_MONKEY.giveMeBuilder(Product.class) .set(\u0026quot;category\u0026quot;, \u0026quot;PREMIUM\u0026quot;) .set(\u0026quot;price\u0026quot;, 1000L); @Test void testDiscountForPremiumProduct() { // Test discount for premium product with price above threshold Product product = PREMIUM_PRODUCT_BUILDER .set(\u0026quot;price\u0026quot;, 2000L) // Price above discount threshold .sample(); // Test discount logic } @Test void testShippingForPremiumProduct() { // Test shipping for premium product with minimum order amount Product product = PREMIUM_PRODUCT_BUILDER .set(\u0026quot;price\u0026quot;, 5000L) // Price above free shipping threshold .sample(); // Test shipping logic } } 7. Start with Simple Objects # Begin with basic objects before moving to complex ones Example: public class ProductTest { private static final FixtureMonkey FIXTURE_MONKEY = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build(); @Test void testBasicProduct() { // Start with a simple object Product product = FIXTURE_MONKEY.giveMeBuilder(Product.class) .set(\u0026quot;name\u0026quot;, \u0026quot;Test Product\u0026quot;) .sample(); // ... } } 8. Use the IntelliJ Plugin # Install the Fixture Monkey Helper plugin to enhance your development experience:
Smart code completion for Fixture Monkey methods Type-safe field access suggestions using method references Quick navigation to field definitions Automatic import suggestions for Fixture Monkey classes Real-time validation of field names and types 9. Common Use Cases # Testing validation rules Testing business logic with specific conditions Creating test data for integration tests Generating random but valid test data 10. Best Practices # Keep test data generation close to where it\u0026rsquo;s used Use meaningful variable names Document complex test scenarios Use constants for frequently used values `}),e.add({id:11,href:"/v1-1-0/docs/generating-objects/",title:"Generating Objects",description:`Creating test data is one of the most important and time-consuming parts of writing tests. Fixture Monkey simplifies this task by providing an easy and flexible way to generate test objects of any complexity.
This section covers:
Creating a FixtureMonkey instance - the main entry point for generating test objects Basic object generation methods for simple and common use cases Handling complex types like interfaces and generic types Customizing how objects are created and initialized Whether you need a simple POJO or a complex object graph with specific constraints, Fixture Monkey\u0026rsquo;s intuitive API makes test data generation straightforward and maintainable.`,content:`Creating test data is one of the most important and time-consuming parts of writing tests. Fixture Monkey simplifies this task by providing an easy and flexible way to generate test objects of any complexity.
This section covers:
Creating a FixtureMonkey instance - the main entry point for generating test objects Basic object generation methods for simple and common use cases Handling complex types like interfaces and generic types Customizing how objects are created and initialized Whether you need a simple POJO or a complex object graph with specific constraints, Fixture Monkey\u0026rsquo;s intuitive API makes test data generation straightforward and maintainable.
`}),e.add({id:12,href:"/v1-1-0/docs/generating-objects/fixture-monkey/",title:"FixtureMonkey",description:`What is FixtureMonkey? # FixtureMonkey is the main entry point for creating test fixtures in the Fixture Monkey library. Think of it as a factory that knows how to create instances of any class with random but valid values. This makes it perfect for generating test data without writing verbose setup code.
How it works - A quick overview # The typical workflow with Fixture Monkey looks like this:
Create a FixtureMonkey instance Use one of its generation methods to create test objects Optionally customize the objects to match specific test requirements For example, here\u0026rsquo;s a complete test using Fixture Monkey:`,content:`What is FixtureMonkey? # FixtureMonkey is the main entry point for creating test fixtures in the Fixture Monkey library. Think of it as a factory that knows how to create instances of any class with random but valid values. This makes it perfect for generating test data without writing verbose setup code.
How it works - A quick overview # The typical workflow with Fixture Monkey looks like this:
Create a FixtureMonkey instance Use one of its generation methods to create test objects Optionally customize the objects to match specific test requirements For example, here\u0026rsquo;s a complete test using Fixture Monkey:
Java Kotlin @Test void testProductDiscount() { // 1. Create a FixtureMonkey instance FixtureMonkey fixtureMonkey = FixtureMonkey.create(); // 2. Generate a test object with specific properties Product product = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026#34;price\u0026#34;, 100.0) .sample(); // 3. Use the object in your test double discountedPrice = productService.applyDiscount(product, 10); // 4. Assert the expected outcome assertEquals(90.0, discountedPrice); } @Test fun testProductDiscount() { // 1. Create a FixtureMonkey instance val fixtureMonkey = FixtureMonkey.plugin(KotlinPlugin()).build() // 2. Generate a test object with specific properties val product: Product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .set(\u0026#34;price\u0026#34;, 100.0) .sample() // 3. Use the object in your test val discountedPrice = productService.applyDiscount(product, 10) // 4. Assert the expected outcome assertEquals(90.0, discountedPrice) } Now let\u0026rsquo;s learn the specific steps to use FixtureMonkey in your tests.
Creating a FixtureMonkey Instance # To generate test fixtures, the first step is to create a FixtureMonkey instance, which facilitates the creation of test fixtures.
You can use the create() method to generate a FixtureMonkey instance with default options. For Kotlin environments, add the Kotlin plugin.
Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.create(); val fixtureMonkey = FixtureMonkey .plugin(KotlinPlugin()) .build() If you want to add some options for creating or customizing the test fixtures, you can add them using the FixtureMonkey builder.
Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() + options... .build(); val fixtureMonkey = FixtureMonkey.builder() + options... .build() For information on what options are available, see the Fixture Monkey Options section.
Generating instances # The FixtureMonkey class provides several methods to help create test objects of the required type.
When to use which method? # Here\u0026rsquo;s a quick guide to help you choose the right method:
giveMeOne() - When you need a single instance with default random values giveMe() - When you need multiple instances with default random values giveMeBuilder() - When you need to customize properties before creating instances giveMeArbitrary() - Advanced usage when working with jqwik\u0026rsquo;s Arbitrary API giveMeOne() # If you need an instance of a certain type, you can use giveMeOne(). Pass either a class or a type reference.
Java Kotlin Product product = fixtureMonkey.giveMeOne(Product.class); List\u0026lt;String\u0026gt; strList = fixtureMonkey.giveMeOne(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {}); val product: Product = fixtureMonkey.giveMeOne() val strList: List\u0026lt;String\u0026gt; = fixtureMonkey.giveMeOne() giveMe() # If you need multiple instances of a certain type, you can use the giveMe() method. You can choose to generate either a stream of instances or a list by specifying the desired size.
Java Kotlin Stream\u0026lt;Product\u0026gt; productStream = fixtureMonkey.giveMe(Product.class); Stream\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; strListStream = fixtureMonkey.giveMe(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {}); List\u0026lt;Product\u0026gt; productList = fixtureMonkey.giveMe(Product.class, 3); List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; strListList = fixtureMonkey.giveMe(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {}, 3); val productSequence: Sequence\u0026lt;Product\u0026gt; = fixtureMonkey.giveMe() val strListSequence: Sequence\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; = fixtureMonkey.giveMe() val productList: List\u0026lt;Product\u0026gt; = fixtureMonkey.giveMe(3) val strListList: List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; = fixtureMonkey.giveMe(3) giveMeBuilder() # If you need to further customize the instance to be created, you can use giveMeBuilder(). This will return an ArbitraryBuilder of the given type. An ArbitraryBuilder is a class in Fixture Monkey that acts as a builder for an Arbitrary object of the given class.
Java Kotlin ArbitraryBuilder\u0026lt;Product\u0026gt; productBuilder = fixtureMonkey.giveMeBuilder(Product.class); ArbitraryBuilder\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; strListBuilder = fixtureMonkey.giveMeBuilder(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {}); val productBuilder: ArbitraryBuilder\u0026lt;Product\u0026gt; = fixtureMonkey.giveMeBuilder() val strListBuilder: ArbitraryBuilder\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; = fixtureMonkey.giveMeBuilder() For cases where you already have a generated instance and want to customize it further, you can also use giveMeBuilder().
Java Kotlin Product product = new Product(1L, \u0026#34;Book\u0026#34;, ...); ArbitraryBuilder\u0026lt;Product\u0026gt; productBuilder = fixtureMonkey.giveMeBuilder(product); val product = Product(1L, \u0026#34;Book\u0026#34;, ...) val productBuilder = fixtureMonkey.giveMeBuilder(product) The generated ArbitraryBuilder can be used for further customization of your fixture. For more information on customization options, see the section on customization objects.
To obtain an instance from the ArbitraryBuilder, you can use the sample(), sampleList(), sampleStream() methods of the ArbitraryBuilder.
Java Kotlin ArbitraryBuilder\u0026lt;Product\u0026gt; productBuilder = fixtureMonkey.giveMeBuilder(Product.class); Product product = productBuilder.sample(); List\u0026lt;Product\u0026gt; productList = productBuilder.sampleList(3); Stream\u0026lt;Product\u0026gt; productStream = productBuilder.sampleStream(); val productBuilder: ArbitraryBuilder\u0026lt;Product\u0026gt; = fixtureMonkey.giveMeBuilder() val product = productBuilder.sample() val productList = productBuilder.sampleList(3) val productStream = productBuilder.sampleStream() In cases where you need an Arbitrary itself rather than an instance, you can simply call the build() method.
Java Kotlin ArbitraryBuilder\u0026lt;Product\u0026gt; productBuilder = fixtureMonkey.giveMeBuilder(Product.class); Arbitrary\u0026lt;Product\u0026gt; productArbitrary = productBuilder.build(); val productBuilder: ArbitraryBuilder\u0026lt;Product\u0026gt; = fixtureMonkey.giveMeBuilder() val productArbitrary = productBuilder.build() giveMeArbitrary() # To get an Arbitrary of the specified type, you can use the giveMeArbitrary() method.
Java Kotlin Arbitrary\u0026lt;Product\u0026gt; productArbitrary = fixtureMonkey.giveMeArbitrary(Product.class); Arbitrary\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; strListArbitrary = fixtureMonkey.giveMeArbitrary(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {}); val productArbitrary: Arbitrary\u0026lt;Product\u0026gt; = fixtureMonkey.giveMeArbitrary() val strListArbitrary: Arbitrary\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; = fixtureMonkey.giveMeArbitrary() `}),e.add({id:13,href:"/v1-1-0/docs/generating-objects/generating-complex-types/",title:"Generating Complex Types",description:`Why Complex Types Matter in Testing # When writing real-world tests, you\u0026rsquo;ll often need to work with complex objects that include:
Generic types with multiple type parameters Self-referencing structures (like trees or graphs) Complex interface hierarchies Sealed or abstract classes Manually creating instances of these types for testing can be extremely tedious and error-prone. This is where Fixture Monkey shines - it can automatically generate valid instances of even the most complex types with minimal code.`,content:`Why Complex Types Matter in Testing # When writing real-world tests, you\u0026rsquo;ll often need to work with complex objects that include:
Generic types with multiple type parameters Self-referencing structures (like trees or graphs) Complex interface hierarchies Sealed or abstract classes Manually creating instances of these types for testing can be extremely tedious and error-prone. This is where Fixture Monkey shines - it can automatically generate valid instances of even the most complex types with minimal code.
How Fixture Monkey Handles Complex Types # Fixture Monkey analyzes the structure of your classes and interfaces at runtime, understanding their relationships and constraints. It then generates valid instances with all the necessary fields populated, even for nested and recursive structures.
For interfaces, Fixture Monkey applies special handling. When an interface has multiple implementations, Fixture Monkey randomly selects one of the available implementations to generate. This is especially useful when testing interfaces with various implementations. Of course, you can also explicitly specify which implementations to use. This behavior can be controlled in detail through the InterfacePlugin.
// Example of specifying multiple implementations for a UserService interface FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin( new InterfacePlugin() .interfaceImplements(UserService.class, List.of(BasicUserService.class, PremiumUserService.class)) ) .build(); // One of the specified implementations will be randomly selected UserService userService = fixtureMonkey.giveMeOne(UserService.class); Let\u0026rsquo;s look at examples of complex types and how to generate them with Fixture Monkey.
Java # Generic Objects # Generic types with type parameters can be challenging to instantiate correctly in tests:
@Value public static class GenericObject\u0026lt;T\u0026gt; { T foo; } @Value public static class GenericArrayObject\u0026lt;T\u0026gt; { GenericObject\u0026lt;T\u0026gt;[] foo; } @Value public static class TwoGenericObject\u0026lt;T, U\u0026gt; { T foo; U bar; } @Value public static class ThreeGenericObject\u0026lt;T, U, V\u0026gt; { T foo; U bar; V baz; } To generate instances of these generic types with Fixture Monkey:
// Simple generic with String GenericObject\u0026lt;String\u0026gt; stringGeneric = fixtureMonkey.giveMeOne( new TypeReference\u0026lt;GenericObject\u0026lt;String\u0026gt;\u0026gt;() {} ); // Generic with array GenericArrayObject\u0026lt;Integer\u0026gt; arrayGeneric = fixtureMonkey.giveMeOne( new TypeReference\u0026lt;GenericArrayObject\u0026lt;Integer\u0026gt;\u0026gt;() {} ); // Multiple type parameters TwoGenericObject\u0026lt;String, Integer\u0026gt; twoParamGeneric = fixtureMonkey.giveMeOne( new TypeReference\u0026lt;TwoGenericObject\u0026lt;String, Integer\u0026gt;\u0026gt;() {} ); Generic Interfaces # public interface GenericInterface\u0026lt;T\u0026gt; { } @Value public static class GenericInterfaceImpl\u0026lt;T\u0026gt; implements GenericInterface\u0026lt;T\u0026gt; { T foo; } public interface TwoGenericInterface\u0026lt;T, U\u0026gt; { } @Value public static class TwoGenericImpl\u0026lt;T, U\u0026gt; implements TwoGenericInterface\u0026lt;T, U\u0026gt; { T foo; U bar; } To generate interface implementations:
// Generate an implementation of GenericInterface\u0026lt;String\u0026gt; GenericInterface\u0026lt;String\u0026gt; genericInterface = fixtureMonkey.giveMeOne( new TypeReference\u0026lt;GenericInterface\u0026lt;String\u0026gt;\u0026gt;() {} ); For example, when you have multiple classes implementing the same interface:
public interface PaymentProcessor { void processPayment(double amount); } public class CreditCardProcessor implements PaymentProcessor { @Override public void processPayment(double amount) { // Credit card payment processing logic } } public class BankTransferProcessor implements PaymentProcessor { @Override public void processPayment(double amount) { // Bank transfer payment processing logic } } // One of the implementations will be randomly selected PaymentProcessor processor = fixtureMonkey.giveMeOne(PaymentProcessor.class); SelfReference # Self-referencing types are particularly challenging to create manually but easy with Fixture Monkey:
@Value public class SelfReference { String foo; SelfReference bar; } @Value public class SelfReferenceList { String foo; List\u0026lt;SelfReferenceList\u0026gt; bar; } Generate self-referencing objects with depth control:
// Default generation (limited nesting depth to avoid infinite recursion) SelfReference selfRef = fixtureMonkey.giveMeOne(SelfReference.class); // With custom configuration to control container size FixtureMonkey customFixture = FixtureMonkey.builder() .defaultArbitraryContainerInfo(new ContainerInfo(2, 2)) // Controls lists size .build(); SelfReferenceList refList = customFixture.giveMeOne(SelfReferenceList.class); Interface # public interface Interface { String foo(); Integer bar(); } public interface InheritedInterface extends Interface { String foo(); } public interface InheritedInterfaceWithSameNameMethod extends Interface { String foo(); } public interface ContainerInterface { List\u0026lt;String\u0026gt; baz(); Map\u0026lt;String, Integer\u0026gt; qux(); } public interface InheritedTwoInterface extends Interface, ContainerInterface { } Kotlin # Generic Objects # class Generic\u0026lt;T\u0026gt;(val foo: T) class GenericImpl(val foo: Generic\u0026lt;String\u0026gt;) Generating Kotlin generic objects:
// Generate a Generic\u0026lt;Int\u0026gt; val genericInt: Generic\u0026lt;Int\u0026gt; = fixtureMonkey.giveMeOne() // Generate a GenericImpl with nested Generic\u0026lt;String\u0026gt; val genericImpl: GenericImpl = fixtureMonkey.giveMeOne() SelfReference # class SelfReference(val foo: String, val bar: SelfReference?) Sealed class, Value class # sealed class SealedClass object ObjectSealedClass : SealedClass() class SealedClassImpl(val foo: String) : SealedClass() @JvmInline value class ValueClass(val foo: String) Generating sealed classes and value classes in Kotlin:
// Fixture Monkey will choose a concrete implementation of the sealed class val sealedClass: SealedClass = fixtureMonkey.giveMeOne() // Generate a value class val valueClass: ValueClass = fixtureMonkey.giveMeOne() Kotlin sealed classes are handled similarly to interfaces. Fixture Monkey randomly selects one of the subclasses of the sealed class to generate.
Tips for Working with Complex Types # Use TypeReference for generic types to preserve type information For complex interfaces, you may need to configure implementation classes using InterfacePlugin If you want to use only specific implementations for interfaces or abstract classes, use InterfacePlugin.interfaceImplements() For very complex structures, consider breaking them down and building them step by step `}),e.add({id:14,href:"/v1-1-0/docs/generating-objects/instantiate-methods/",title:"Instantiate Methods",description:`Overview: Why Specify Object Creation Methods # By default, Fixture Monkey automatically determines how to create objects through Introspectors. However, sometimes you may need to specify a particular creation method for reasons such as:
Specific constructor usage: When a class has multiple constructors and you want to choose a specific one Factory method utilization: When you want to create objects using factory methods instead of constructors Different initialization per test: When you need different initialization methods for the same class in different tests Special initialization logic: When you need special initialization that can\u0026rsquo;t be handled automatically by introspectors In these situations, the instantiate() method allows you to precisely control how objects are created.`,content:`Overview: Why Specify Object Creation Methods # By default, Fixture Monkey automatically determines how to create objects through Introspectors. However, sometimes you may need to specify a particular creation method for reasons such as:
Specific constructor usage: When a class has multiple constructors and you want to choose a specific one Factory method utilization: When you want to create objects using factory methods instead of constructors Different initialization per test: When you need different initialization methods for the same class in different tests Special initialization logic: When you need special initialization that can\u0026rsquo;t be handled automatically by introspectors In these situations, the instantiate() method allows you to precisely control how objects are created.
ðŸ’¡ This document explains how to specify object creation methods on a per-test basis. If you want to apply the same method for all tests, refer to the Introspector page. Getting Started: Basic Usage # The most basic way to create objects with Fixture Monkey is:
// Basic approach - let the introspector automatically determine how to create objects Product product = fixtureMonkey.giveMeOne(Product.class); However, if you want to use a specific constructor or factory method, you can use the instantiate() method:
// Specify a constructor Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate(constructor()) .sample(); // Specify a factory method Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate(factoryMethod(\u0026quot;create\u0026quot;)) .sample(); â­ Beginner tip: In most cases, the basic approach (giveMeOne) is sufficient. Only use the instantiate() method when you have special initialization requirements. Basic Concepts # What is ArbitraryBuilder? # ArbitraryBuilder is a builder class for configuring object creation settings. It\u0026rsquo;s returned when you call the giveMeBuilder() method in Fixture Monkey.
// Get an ArbitraryBuilder ArbitraryBuilder\u0026lt;Product\u0026gt; builder = fixtureMonkey.giveMeBuilder(Product.class); What is the instantiate() method? # The instantiate() method allows you to specify how the ArbitraryBuilder should create objects. You can choose between constructors and factory methods:
ðŸ“Œ Method format:
Java Kotlin // Specifying a constructor in Java .instantiate(constructor()) // Specifying a factory method in Java .instantiate(factoryMethod(\u0026#34;methodName\u0026#34;)) // Specifying a constructor in Kotlin (Kotlin Plugin required) .instantiateBy { constructor() } // Specifying a factory method in Kotlin .instantiateBy { factory(\u0026#34;methodName\u0026#34;) } 1. Using Simple Constructors # Let\u0026rsquo;s start with the most basic usage. Here\u0026rsquo;s a simple class example:
Java Kotlin public class SimpleProduct { private final String name; private final int price; // Constructor public SimpleProduct(String name, int price) { this.name = name; this.price = price; } // Getter methods public String getName() { return name; } public int getPrice() { return price; } } class SimpleProduct( val name: String, val price: Int ) Using the constructor to create an object:
Java Kotlin @Test void usingSimpleConstructor() { SimpleProduct product = fixtureMonkey.giveMeBuilder(SimpleProduct.class) .instantiate(constructor()) .sample(); // Verify the created object assertThat(product).isNotNull(); assertThat(product.getName()).isNotNull(); assertThat(product.getPrice()).isNotNegative(); } @Test fun usingSimpleConstructor() { val product = fixtureMonkey.giveMeBuilder\u0026lt;SimpleProduct\u0026gt;() .instantiateBy { constructor() } .sample() // Verify the created object assertThat(product).isNotNull() assertThat(product.name).isNotNull() assertThat(product.price).isNotNegative() } In this example, constructor() specifies that the constructor of SimpleProduct should be used. Fixture Monkey automatically generates appropriate values and passes them to the constructor.
2. Choosing Between Multiple Constructors # Now let\u0026rsquo;s look at a class with multiple constructors:
Java Kotlin public class Product { private final long id; private final String name; private final long price; private final List\u0026lt;String\u0026gt; options; // Default constructor (all fields with default values) public Product() { this.id = 0; this.name = \u0026#34;defaultProduct\u0026#34;; this.price = 0; this.options = null; } // Simple product constructor without options public Product(String name, long price) { this.id = new Random().nextLong(); this.name = name; this.price = price; this.options = Collections.emptyList(); } // Product constructor with options public Product(String name, long price, List\u0026lt;String\u0026gt; options) { this.id = new Random().nextLong(); this.name = name; this.price = price; this.options = options; } // Getter methods public long getId() { return id; } public String getName() { return name; } public long getPrice() { return price; } public List\u0026lt;String\u0026gt; getOptions() { return options; } } class Product { val id: Long val name: String val price: Long val options: List\u0026lt;String\u0026gt; // Default constructor (all fields with default values) constructor() { this.id = 0 this.name = \u0026#34;defaultProduct\u0026#34; this.price = 0 this.options = emptyList() } // Simple product constructor without options constructor(name: String, price: Long) { this.id = Random().nextLong() this.name = name this.price = price this.options = emptyList() } // Product constructor with options constructor(name: String, price: Long, options: List\u0026lt;String\u0026gt;) { this.id = Random().nextLong() this.name = name this.price = price this.options = options } } 2.1 Using the Default Constructor # To use the default constructor:
Java Kotlin @Test void usingDefaultConstructor() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate(constructor()) // No parameters means default constructor .sample(); assertThat(product.getId()).isEqualTo(0); assertThat(product.getName()).isEqualTo(\u0026#34;defaultProduct\u0026#34;); } @Test fun usingDefaultConstructor() { val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .instantiateBy { constructor() // No parameters means default constructor } .sample() assertThat(product.id).isEqualTo(0) assertThat(product.name).isEqualTo(\u0026#34;defaultProduct\u0026#34;) } When you specify constructor() without parameters, Fixture Monkey uses the no-args constructor (default constructor).
2.2 Selecting a Specific Constructor # When a class has multiple constructors, you can specify parameter types to select the desired constructor:
Java Kotlin @Test void selectingConstructorWithoutOptions() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate( constructor() .parameter(String.class) // First parameter type .parameter(long.class) // Second parameter type ) .sample(); assertThat(product.getOptions()).isEmpty(); } @Test void selectingConstructorWithOptions() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate( constructor() .parameter(String.class) .parameter(long.class) .parameter(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;(){}) // Generic type ) .sample(); assertThat(product.getOptions()).isNotNull(); } @Test fun selectingConstructorWithoutOptions() { val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .instantiateBy { constructor\u0026lt;Product\u0026gt; { parameter\u0026lt;String\u0026gt;() // First parameter type parameter\u0026lt;Long\u0026gt;() // Second parameter type } } .sample() assertThat(product.options).isEmpty() } @Test fun selectingConstructorWithOptions() { val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .instantiateBy { constructor\u0026lt;Product\u0026gt; { parameter\u0026lt;String\u0026gt;() parameter\u0026lt;Long\u0026gt;() parameter\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() // Generic type } } .sample() assertThat(product.options).isNotNull() } Term Explanation: The parameter() method specifies the parameter types to select the desired constructor.
2.3 Specifying Constructor Parameter Values # To provide specific values for constructor parameters, you can use parameter name hints:
Java Kotlin @Test void specifyingParameterValues() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate( constructor() .parameter(String.class, \u0026#34;productName\u0026#34;) // Parameter name hint .parameter(long.class) ) .set(\u0026#34;productName\u0026#34;, \u0026#34;specialProduct\u0026#34;) // Set value using the hint name .sample(); assertThat(product.getName()).isEqualTo(\u0026#34;specialProduct\u0026#34;); } @Test fun specifyingParameterValues() { val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .instantiateBy { constructor\u0026lt;Product\u0026gt; { parameter\u0026lt;String\u0026gt;(\u0026#34;productName\u0026#34;) // Parameter name hint parameter\u0026lt;Long\u0026gt;() } } .set(\u0026#34;productName\u0026#34;, \u0026#34;specialProduct\u0026#34;) // Set value using the hint name .sample() assertThat(product.name).isEqualTo(\u0026#34;specialProduct\u0026#34;) } Term Explanation: A parameter name hint assigns an alias to a constructor parameter, allowing you to set values for it later using this name.
3. Using Factory Methods # Besides constructors, you can create objects using factory methods. Let\u0026rsquo;s look at a class with factory methods:
Java Kotlin public class Product { // Fields and constructors defined earlier... // Factory method public static Product create(String name, long price) { return new Product(name, price); } // Recommended product factory method public static Product createRecommended(long price) { return new Product(\u0026#34;recommendedProduct\u0026#34;, price); } } class Product { // Fields and constructors defined earlier... companion object { // Factory method fun create(name: String, price: Long): Product { return Product(name, price) } // Recommended product factory method fun createRecommended(price: Long): Product { return Product(\u0026#34;recommendedProduct\u0026#34;, price) } } } 3.1 Basic Factory Method Usage # To create an object using a factory method:
Java Kotlin @Test void usingFactoryMethod() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate( factoryMethod(\u0026#34;create\u0026#34;) // Specify factory method name ) .sample(); assertThat(product).isNotNull(); assertThat(product.getOptions()).isEmpty(); } @Test fun usingFactoryMethod() { val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .instantiateBy { factory\u0026lt;Product\u0026gt;(\u0026#34;create\u0026#34;) // Specify factory method name } .sample() assertThat(product).isNotNull() assertThat(product.options).isEmpty() } Term Explanation: A factory method is a static method responsible for object creation, used instead of directly calling constructors.
3.2 Selecting a Specific Factory Method # When there are multiple factory methods, you can specify parameter types to select the desired method:
Java Kotlin @Test void selectingSpecificFactoryMethod() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate( factoryMethod(\u0026#34;createRecommended\u0026#34;) .parameter(long.class) // Parameter type ) .sample(); assertThat(product.getName()).isEqualTo(\u0026#34;recommendedProduct\u0026#34;); } @Test fun selectingSpecificFactoryMethod() { val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .instantiateBy { factory\u0026lt;Product\u0026gt;(\u0026#34;createRecommended\u0026#34;) { parameter\u0026lt;Long\u0026gt;() // Parameter type } } .sample() assertThat(product.name).isEqualTo(\u0026#34;recommendedProduct\u0026#34;) } 3.3 Specifying Factory Method Parameter Values # To provide specific values for factory method parameters:
Java Kotlin @Test void specifyingFactoryMethodParameterValues() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate( factoryMethod(\u0026#34;create\u0026#34;) .parameter(String.class, \u0026#34;productName\u0026#34;) // Parameter name hint .parameter(long.class, \u0026#34;productPrice\u0026#34;) ) .set(\u0026#34;productName\u0026#34;, \u0026#34;customProduct\u0026#34;) .set(\u0026#34;productPrice\u0026#34;, 9900L) .sample(); assertThat(product.getName()).isEqualTo(\u0026#34;customProduct\u0026#34;); assertThat(product.getPrice()).isEqualTo(9900L); } @Test fun specifyingFactoryMethodParameterValues() { val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .instantiateBy { factory\u0026lt;Product\u0026gt;(\u0026#34;create\u0026#34;) { parameter\u0026lt;String\u0026gt;(\u0026#34;productName\u0026#34;) // Parameter name hint parameter\u0026lt;Long\u0026gt;(\u0026#34;productPrice\u0026#34;) } } .set(\u0026#34;productName\u0026#34;, \u0026#34;customProduct\u0026#34;) .set(\u0026#34;productPrice\u0026#34;, 9900L) .sample() assertThat(product.name).isEqualTo(\u0026#34;customProduct\u0026#34;) assertThat(product.price).isEqualTo(9900L) } 4. Advanced Features and Important Notes # Here are some advanced features and important notes to be aware of when creating objects.
4.1 Choosing Between Field and JavaBeansProperty # You can control how property values are set during object creation. There are two main approaches:
ðŸ“˜ These options determine how properties not initialized by the constructor or factory method will be set after the object is created. field(): Generate properties based on class fields
Pros: Direct field access, works without setters Cons: Bypasses encapsulation, ignores validation logic javaBeansProperty(): Generate properties based on getter/setter methods
Pros: Respects encapsulation, uses validation logic in setters Cons: Requires setter methods to set properties ðŸ“‹ Quick selection guide:
If setter methods have validation logic and you want to test it: javaBeansProperty() If there are no setter methods or you want to bypass validation: field() 4.1.1 Field-Based Property Generation # To generate properties based on fields:
Java Kotlin @Test void fieldBasedPropertyGeneration() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate( constructor().field() // Field-based property generation ) .sample(); assertThat(product).isNotNull(); } @Test fun fieldBasedPropertyGeneration() { val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .instantiateBy { constructor { javaField() // Field-based property generation } } .sample() assertThat(product).isNotNull() } Term Explanation: Fields are variables defined in a class that store the object\u0026rsquo;s state. Field-based property generation uses these fields directly to set values.
4.1.2 JavaBeansProperty-Based Property Generation # To generate properties based on JavaBeansProperty:
Java Kotlin @Test void javaBeanPropertyBasedGeneration() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .instantiate( constructor().javaBeansProperty() // JavaBeansProperty-based generation ) .sample(); assertThat(product).isNotNull(); } @Test fun javaBeanPropertyBasedGeneration() { val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .instantiateBy { constructor { javaBeansProperty() // JavaBeansProperty-based generation } } .sample() assertThat(product).isNotNull() } Term Explanation: JavaBeansProperty refers to properties represented by getter/setter method pairs. For example, the getName()/setName() method pair represents the \u0026rsquo;name\u0026rsquo; property.
4.2 Property Setting After Constructor Invocation # âš ï¸ This section explains important cautions when Fixture Monkey sets property values after object creation. When you specify a constructor using the instantiate() method, Fixture Monkey sets random values for properties not handled by the constructor after object creation. This feature is useful when you want to generate test data for fields that are not initialized in the constructor.
How it works at a glance: # Specify constructor: instantiate(constructor()...) Create object using constructor Set random values for properties not initialized by constructor Return complete object Let\u0026rsquo;s see an example:
Java Kotlin public class PartiallyInitializedObject { private final String name; // Initialized in constructor private int count; // Not initialized in constructor private List\u0026lt;String\u0026gt; items; // Not initialized in constructor public PartiallyInitializedObject(String name) { this.name = name; } // Getter/Setter public String getName() { return name; } public int getCount() { return count; } public void setCount(int count) { this.count = count; } public List\u0026lt;String\u0026gt; getItems() { return items; } public void setItems(List\u0026lt;String\u0026gt; items) { this.items = items; } } @Test void propertySettingAfterConstructor() { PartiallyInitializedObject obj = fixtureMonkey.giveMeBuilder(PartiallyInitializedObject.class) .instantiate(constructor().parameter(String.class)) .sample(); assertThat(obj.getName()).isNotNull(); // Initialized in constructor assertThat(obj.getCount()).isNotZero(); // Initialized after constructor assertThat(obj.getItems()).isNotNull(); // Initialized after constructor } class PartiallyInitializedObject( val name: String // Initialized in constructor ) { var count: Int = 0 // Not initialized in constructor var items: List\u0026lt;String\u0026gt;? = null // Not initialized in constructor } @Test fun propertySettingAfterConstructor() { val obj = fixtureMonkey.giveMeBuilder\u0026lt;PartiallyInitializedObject\u0026gt;() .instantiateBy { constructor\u0026lt;PartiallyInitializedObject\u0026gt; { parameter\u0026lt;String\u0026gt;() } } .sample() assertThat(obj.name).isNotNull() // Initialized in constructor assertThat(obj.count).isNotZero() // Initialized after constructor assertThat(obj.items).isNotNull() // Initialized after constructor } 4.2.1 Caution # There\u0026rsquo;s one important caution when using this feature:
âš ï¸ Fixture Monkey may also **modify property values that were already set in the constructor**. This could lead to unexpected test results. Problem scenario:
Set name = \u0026quot;specificName\u0026quot; in constructor Fixture Monkey automatically assigns random value to name after object creation name changes from \u0026ldquo;specificName\u0026rdquo; to some other value Solution: You can solve this problem by explicitly setting important values:
Java Kotlin @Test void preservingConstructorSetValues() { String specificName = \u0026#34;specificName\u0026#34;; PartiallyInitializedObject obj = fixtureMonkey.giveMeBuilder(PartiallyInitializedObject.class) .instantiate( constructor() .parameter(String.class, \u0026#34;name\u0026#34;) ) .set(\u0026#34;name\u0026#34;, specificName) // Explicitly set constructor parameter value .sample(); assertThat(obj.getName()).isEqualTo(specificName); // Explicitly set value is preserved } @Test fun preservingConstructorSetValues() { val specificName = \u0026#34;specificName\u0026#34; val obj = fixtureMonkey.giveMeBuilder\u0026lt;PartiallyInitializedObject\u0026gt;() .instantiateBy { constructor\u0026lt;PartiallyInitializedObject\u0026gt; { parameter\u0026lt;String\u0026gt;(\u0026#34;name\u0026#34;) } } .set(\u0026#34;name\u0026#34;, specificName) // Explicitly set constructor parameter value .sample() assertThat(obj.name).isEqualTo(specificName) // Explicitly set value is preserved } ðŸ’¡ Beginner tip: Always explicitly set important values using the \`.set()\` method to ensure predictable test results! Frequently Asked Questions (FAQ) # Q: What\u0026rsquo;s the difference between instantiate and introspectors? # A: Introspectors are global settings applied to all object creation, while instantiate is a local setting applied only to specific tests or objects.
Simply put:
Introspector: \u0026ldquo;Create all objects this way for all tests\u0026rdquo; instantiate: \u0026ldquo;Create objects this way only for this specific test\u0026rdquo; In most cases, introspectors are sufficient, but use instantiate when you need special creation logic.
Q: How do I decide which constructor to choose among multiple options? # A: Choose the constructor that best fits your test purpose. Generally:
Simple tests: Use constructors with fewer arguments Testing specific fields: Choose constructors that initialize the fields you\u0026rsquo;re focusing on Testing validation logic: Use constructors with validation or special initialization logic Q: What are the benefits of parameter name hints? # A: Parameter name hints allow you to:
Assign meaningful names to constructor or factory method parameters Easily set specific parameter values using the set() method Improve code readability // Without parameter name hints .instantiate(constructor().parameter(String.class)) .set(\u0026quot;__ANONYMOUS_0\u0026quot;, \u0026quot;value\u0026quot;) // Hard to understand which parameter this is // With parameter name hints .instantiate(constructor().parameter(String.class, \u0026quot;name\u0026quot;)) .set(\u0026quot;name\u0026quot;, \u0026quot;John\u0026quot;) // Clearly indicates which parameter Q: Which should I use: field() or javaBeansProperty()? # A:
field(): Suitable for classes where fields need to be accessed directly or setter methods aren\u0026rsquo;t available javaBeansProperty(): Suitable for classes where setter methods include validation or special processing If unsure, use the default (don\u0026rsquo;t specify). Fixture Monkey will choose an appropriate method. Q: How do I specify generic type parameters? # A: Generic types are specified using TypeReference:
// Java .parameter(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;(){}) // Kotlin parameter\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() Q: How do I prevent values set in the constructor from being changed? # A: Use the .set() method to explicitly set important values:
fixtureMonkey.giveMeBuilder(MyClass.class) .instantiate(constructor().parameter(String.class, \u0026quot;name\u0026quot;)) .set(\u0026quot;name\u0026quot;, \u0026quot;importantValue\u0026quot;) // This value won't be changed .sample(); Summary # ðŸ“Œ Key Points Summary The instantiate() method provides fine-grained control over object creation methods You can choose between constructors and factory methods as the two main object creation approaches Parameter name hints allow you to set specific values for constructor or factory method parameters field() and javaBeansProperty() control how property values are generated In most cases, introspector settings are sufficient, and instantiate is only needed for special cases By properly utilizing these features, you can create even complex objects accurately for your testing purposes.
Next Steps # To learn more about test data generation:
Introspector: How to set object creation methods globally Fixture Monkey: Basic usage of Fixture Monkey Generating Complex Types: How to generate complex object structures `}),e.add({id:15,href:"/v1-1-0/docs/generating-objects/generating-interface/",title:"Generating Interface Types",description:`Why Generate Interface Types? # When writing tests, you often need to work with interfaces rather than concrete implementations:
You may be testing code that accepts interfaces as parameters Your system under test may return interface types You want to test behavior without coupling to specific implementations Fixture Monkey makes it easy to generate test objects for interfaces - whether they\u0026rsquo;re simple interfaces, generic interfaces, or sealed interfaces.
Quick Start Example # Here\u0026rsquo;s a simple example to get started with interface generation:`,content:`Why Generate Interface Types? # When writing tests, you often need to work with interfaces rather than concrete implementations:
You may be testing code that accepts interfaces as parameters Your system under test may return interface types You want to test behavior without coupling to specific implementations Fixture Monkey makes it easy to generate test objects for interfaces - whether they\u0026rsquo;re simple interfaces, generic interfaces, or sealed interfaces.
Quick Start Example # Here\u0026rsquo;s a simple example to get started with interface generation:
// Define an interface you want to test with public interface StringSupplier { String getValue(); } // Create a Fixture Monkey instance FixtureMonkey fixture = FixtureMonkey.create(); // Generate an instance of the interface StringSupplier supplier = fixture.giveMeOne(StringSupplier.class); // Use it in your test String value = supplier.getValue(); assertThat(value).isNotNull(); // Will pass This example generates an anonymous implementation of the StringSupplier interface that you can use in your tests. Let\u0026rsquo;s explore more options for interface generation.
Interface Generation Approaches # Fixture Monkey provides three main approaches for generating interface instances:
Approach Description Best For Anonymous implementation Fixture Monkey creates an anonymous class Quick tests, simple interfaces Specific implementation You specify which class to use More control, realistic behavior Built-in implementations Fixture Monkey provides defaults for common interfaces Standard Java interfaces Examples for Each Approach # // Anonymous implementation StringSupplier supplier = fixture.giveMeOne(StringSupplier.class); // Specific implementation InterfacePlugin plugin = new InterfacePlugin() .interfaceImplements(StringSupplier.class, List.of(DefaultStringSupplier.class)); // Built-in implementation List\u0026lt;String\u0026gt; list = fixture.giveMeOne(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {}); Common Interface Types with Built-in Support # Fixture Monkey provides default implementations for common Java interfaces:
List â†’ ArrayList Set â†’ HashSet Map â†’ HashMap Queue â†’ LinkedList And more\u0026hellip; You don\u0026rsquo;t need to configure anything special to use these.
Detailed Examples # Simple Interface # Let\u0026rsquo;s start with a simple interface example:
// The interface we want to generate public interface StringSupplier { String getValue(); } // A concrete implementation we might want to use public class DefaultStringSupplier implements StringSupplier { private final String value; @ConstructorProperties(\u0026quot;value\u0026quot;) // It is not needed if you are using Lombok. public DefaultStringSupplier(String value) { this.value = value; } @Override public String getValue() { return \u0026quot;default\u0026quot; + value; } } Approach 1: Anonymous Implementation (No Options) # The simplest approach is to let Fixture Monkey generate an anonymous implementation:
@Test void testWithAnonymousImplementation() { // Setup FixtureMonkey fixture = FixtureMonkey.create(); // Generate an anonymous implementation StringSupplier result = fixture.giveMeOne(StringSupplier.class); // Test assertThat(result.getValue()).isNotNull(); assertThat(result).isNotInstanceOf(DefaultStringSupplier.class); } With this approach, Fixture Monkey creates an anonymous object that implements the StringSupplier interface. The getValue() method returns a randomly generated String.
ðŸ’¡ Fixture Monkey only generates property values for methods that:
Follow the naming convention of getters (like getValue(), getName(), etc.) Have no parameters Other methods will always return null or default primitive values.
You can customize the generated properties using the same API as for regular classes:
@Test void testWithCustomizedProperties() { // Setup FixtureMonkey fixture = FixtureMonkey.create(); // Generate with a specific property value StringSupplier result = fixture.giveMeBuilder(StringSupplier.class) .set(\u0026quot;value\u0026quot;, \u0026quot;customValue\u0026quot;) .sample(); // Test assertThat(result.getValue()).isEqualTo(\u0026quot;customValue\u0026quot;); } Approach 2: Using a Specific Implementation # When you need more realistic behavior, you can tell Fixture Monkey to use your concrete implementation:
@Test void testWithSpecificImplementation() { // Setup Fixture Monkey with a specific implementation FixtureMonkey fixture = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) // needed for DefaultStringSupplier's constructor .plugin( new InterfacePlugin() .interfaceImplements(StringSupplier.class, List.of(DefaultStringSupplier.class)) ) .build(); // Generate the interface StringSupplier result = fixture.giveMeOne(StringSupplier.class); // Test assertThat(result).isInstanceOf(DefaultStringSupplier.class); assertThat(result.getValue()).startsWith(\u0026quot;default\u0026quot;); } This approach generates a real DefaultStringSupplier instance with the behavior defined in your implementation.
Generic Interface # For generic interfaces, the approach varies depending on whether you specify type parameters:
1. Without Type Parameters # When you create a generic interface without specifying type parameters, Fixture Monkey defaults to using String type:
// Generic interface public interface ObjectValueSupplier\u0026lt;T\u0026gt; { T getValue(); } @Test void testGenericInterfaceWithoutTypeParameters() { FixtureMonkey fixture = FixtureMonkey.create(); // Create without specifying type parameter ObjectValueSupplier\u0026lt;?\u0026gt; result = fixture.giveMeOne(ObjectValueSupplier.class); // String type is used by default assertThat(result.getValue()).isInstanceOf(String.class); } 2. With Explicit Type Parameters # You can explicitly specify the type parameter using TypeReference:
@Test void testGenericInterfaceWithTypeParameters() { FixtureMonkey fixture = FixtureMonkey.create(); // Specify Integer as the type parameter ObjectValueSupplier\u0026lt;Integer\u0026gt; result = fixture.giveMeOne(new TypeReference\u0026lt;ObjectValueSupplier\u0026lt;Integer\u0026gt;\u0026gt;() {}); // Integer type is used assertThat(result.getValue()).isInstanceOf(Integer.class); } 3. Using a Specific Implementation # When using a specific implementation, it follows the type parameters of that implementation:
// Concrete implementation for String public class StringValueSupplier implements ObjectValueSupplier\u0026lt;String\u0026gt; { private final String value; @ConstructorProperties(\u0026quot;value\u0026quot;) public StringValueSupplier(String value) { this.value = value; } @Override public String getValue() { return value; } } @Test void testGenericInterfaceWithSpecificImplementation() { // Setup with specific implementation FixtureMonkey fixture = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .plugin( new InterfacePlugin() .interfaceImplements(ObjectValueSupplier.class, List.of(StringValueSupplier.class)) ) .build(); // Generate the interface ObjectValueSupplier\u0026lt;?\u0026gt; result = fixture.giveMeOne(ObjectValueSupplier.class); // Test assertThat(result).isInstanceOf(StringValueSupplier.class); assertThat(result.getValue()).isInstanceOf(String.class); } ðŸ’¡ When generating a generic interface without type parameters, Fixture Monkey uses String as the default type. If you need a different type, use TypeReference or specify a concrete implementation. Sealed Interface (Java 17+) # Java 17 introduced sealed interfaces, which explicitly define their permitted implementations. Fixture Monkey automatically handles these without additional configuration:
// Sealed interface with permitted implementations sealed interface SealedStringSupplier { String getValue(); } // Permitted implementation public static final class SealedDefaultStringSupplier implements SealedStringSupplier { private final String value; @ConstructorProperties(\u0026quot;value\u0026quot;) public SealedDefaultStringSupplier(String value) { this.value = value; } @Override public String getValue() { return \u0026quot;sealed\u0026quot; + value; } } @Test void testSealedInterface() { // Setup FixtureMonkey fixture = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build(); // Generate sealed interface SealedStringSupplier result = fixture.giveMeOne(SealedStringSupplier.class); // Test assertThat(result).isInstanceOf(SealedDefaultStringSupplier.class); assertThat(result.getValue()).startsWith(\u0026quot;sealed\u0026quot;); } Combining with Other Interfaces # You can also specify which implementation to use for certain interfaces. For example, using LinkedList instead of the default ArrayList for List:
@Test void testCustomListImplementation() { // Setup FixtureMonkey fixture = FixtureMonkey.builder() .plugin( new InterfacePlugin() .interfaceImplements(List.class, List.of(LinkedList.class)) ) .build(); // Generate List\u0026lt;String\u0026gt; list = fixture.giveMeOne(new TypeReference\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {}); // Test assertThat(list).isInstanceOf(LinkedList.class); } Interface Inheritance # Fixture Monkey can also handle interface inheritance. You can specify implementations at any level of the hierarchy:
interface ObjectValueSupplier { Object getValue(); } interface StringValueSupplier extends ObjectValueSupplier { String getValue(); } @Test void testInterfaceHierarchy() { // Setup FixtureMonkey fixture = FixtureMonkey.builder() .plugin( new InterfacePlugin() .interfaceImplements(Collection.class, List.of(List.class)) ) .build(); // Generate a Collection, which will use a List implementation Collection\u0026lt;String\u0026gt; collection = fixture.giveMeOne(new TypeReference\u0026lt;Collection\u0026lt;String\u0026gt;\u0026gt;() {}); // Test assertThat(collection).isInstanceOf(List.class); } Advanced Features # For more complex scenarios, Fixture Monkey provides advanced options for interface implementation resolution.
Dynamic Implementation Resolution # If you have many implementations or need to select implementations based on type conditions:
FixtureMonkey fixture = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .plugin( new InterfacePlugin() .interfaceImplements( new AssignableTypeMatcher(ObjectValueSupplier.class), property -\u0026gt; { Class\u0026lt;?\u0026gt; actualType = Types.getActualType(property.getType()); if (StringValueSupplier.class.isAssignableFrom(actualType)) { return List.of(PropertyUtils.toProperty(DefaultStringValueSupplier.class)); } if (IntegerValueSupplier.class.isAssignableFrom(actualType)) { return List.of(PropertyUtils.toProperty(DefaultIntegerValueSupplier.class)); } return List.of(); } ) ) .build(); âš ï¸ This section describes advanced features that most beginners won\u0026rsquo;t need initially. Feel free to revisit this when you need more complex interface generation strategies. Custom Resolution Implementation # For the most advanced scenarios, you can implement the CandidateConcretePropertyResolver interface:
class YourCustomCandidateConcretePropertyResolver implements CandidateConcretePropertyResolver { @Override public List\u0026lt;Property\u0026gt; resolveCandidateConcreteProperties(Property property) { // Your custom logic to resolve implementations return List.of(...); } } You can use the built-in ConcreteTypeCandidateConcretePropertyResolver to help with type conversion:
FixtureMonkey fixture = FixtureMonkey.builder() .plugin(new InterfacePlugin() .interfaceImplements( new ExactTypeMatcher(Collection.class), new ConcreteTypeCandidateConcretePropertyResolver\u0026lt;\u0026gt;(List.of(List.class, Set.class)) ) ) .build(); ðŸ’¡ When setting type conditions for option application, be careful with matchers like AssignableTypeMatcher. Using it incorrectly can cause infinite recursion if implementations also match the condition. Summary # Here\u0026rsquo;s a quick summary of how to generate interface types with Fixture Monkey:
Simple cases: Just use fixture.giveMeOne(YourInterface.class) to get an anonymous implementation
Specific implementation: Use the InterfacePlugin with interfaceImplements:
new InterfacePlugin().interfaceImplements(YourInterface.class, List.of(YourImplementation.class)) Built-in implementations: Common interfaces like List, Set, etc. are handled automatically
Sealed interfaces: No special configuration needed - Fixture Monkey uses the permitted implementations
Complex cases: Use AssignableTypeMatcher or implement CandidateConcretePropertyResolver for advanced scenarios
Remember that for most testing scenarios, the simpler approaches will be sufficient. The advanced features are there when you need more control over the generated implementations.
`}),e.add({id:16,href:"/v1-1-0/docs/generating-objects/introspector/",title:"Introspector",description:`What is an Introspector? # An Introspector in Fixture Monkey is simply a tool that determines how test objects are created. Think of it as a \u0026ldquo;factory\u0026rdquo; that figures out the best way to create objects for your tests.
For example, it decides:
Whether to use a constructor or a builder to create objects How to set values for fields How to handle different types of classes in your codebase Quick Start: Recommended Setup for Most Projects # If you\u0026rsquo;re new to Fixture Monkey and want to get started quickly, here\u0026rsquo;s the setup that works for most projects:`,content:`What is an Introspector? # An Introspector in Fixture Monkey is simply a tool that determines how test objects are created. Think of it as a \u0026ldquo;factory\u0026rdquo; that figures out the best way to create objects for your tests.
For example, it decides:
Whether to use a constructor or a builder to create objects How to set values for fields How to handle different types of classes in your codebase Quick Start: Recommended Setup for Most Projects # If you\u0026rsquo;re new to Fixture Monkey and want to get started quickly, here\u0026rsquo;s the setup that works for most projects:
// Recommended setup that handles most class types FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(new FailoverIntrospector( Arrays.asList( ConstructorPropertiesArbitraryIntrospector.INSTANCE, BuilderArbitraryIntrospector.INSTANCE, FieldReflectionArbitraryIntrospector.INSTANCE, BeanArbitraryIntrospector.INSTANCE ), false // Disable logging for cleaner test output )) .build(); // Use it in your tests @Test void testExample() { // Generate a test object MyClass myObject = fixtureMonkey.giveMeOne(MyClass.class); // Use the generated object in your test assertThat(myObject).isNotNull(); // more assertions... } This setup combines multiple strategies to handle different class types, so it works well for most real-world projects without additional configuration.
Simplest Approach (If You Just Want Basic Setup) # If you prefer the simplest possible setup, you can use the default configuration:
// Simplest approach with default settings FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .build(); // Generate a test object MyClass myObject = fixtureMonkey.giveMeOne(MyClass.class); However, this basic approach only works well with simple JavaBean classes that have a no-arguments constructor and setter methods.
Choosing the Right Introspector for Your Classes # Different class types require different approaches to object creation. Here\u0026rsquo;s a simple guide to help you choose:
Class Type Recommended Introspector Example Classes with setters (JavaBeans) BeanArbitraryIntrospector Classes with getters/setters Immutable classes with constructors ConstructorPropertiesArbitraryIntrospector Records, classes with annotated constructors Classes with mixed field access FieldReflectionArbitraryIntrospector Classes with public fields, no-args constructor Classes using builder pattern BuilderArbitraryIntrospector Classes with .builder() method Mixed codebase with different patterns FailoverArbitraryIntrospector Projects with various class types Examples for Common Class Types # Example 1: Standard JavaBean Class (with getters/setters) # // Class definition public class Customer { private String name; private int age; // No-args constructor public Customer() {} // Setters public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } // Getters public String getName() { return name; } public int getAge() { return age; } } // Test code @Test void testCustomer() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(BeanArbitraryIntrospector.INSTANCE) // Default, so optional .build(); Customer customer = fixtureMonkey.giveMeOne(Customer.class); assertThat(customer.getName()).isNotNull(); assertThat(customer.getAge()).isGreaterThanOrEqualTo(0); } Example 2: Immutable Class with Constructor # // Class definition (with @ConstructorProperties) public class Product { private final String name; private final double price; @ConstructorProperties({\u0026quot;name\u0026quot;, \u0026quot;price\u0026quot;}) public Product(String name, double price) { this.name = name; this.price = price; } public String getName() { return name; } public double getPrice() { return price; } } // Test code @Test void testProduct() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build(); Product product = fixtureMonkey.giveMeOne(Product.class); assertThat(product.getName()).isNotNull(); assertThat(product.getPrice()).isGreaterThanOrEqualTo(0.0); } // Works with Java records too public record OrderItem(String productId, int quantity, double price) {} Example 3: Class with Builder Pattern # // Class definition with builder public class User { private final String username; private final String email; private User(Builder builder) { this.username = builder.username; this.email = builder.email; } public static Builder builder() { return new Builder(); } public static class Builder { private String username; private String email; public Builder username(String username) { this.username = username; return this; } public Builder email(String email) { this.email = email; return this; } public User build() { return new User(this); } } public String getUsername() { return username; } public String getEmail() { return email; } } // Test code @Test void testUser() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(BuilderArbitraryIntrospector.INSTANCE) .build(); User user = fixtureMonkey.giveMeOne(User.class); assertThat(user.getUsername()).isNotNull(); assertThat(user.getEmail()).isNotNull(); } Why Introspectors Matter # Different projects use different patterns for object creation:
Some use simple classes with getters/setters Others use immutable objects with constructors Some follow the builder pattern Frameworks like Lombok generate code in specific ways By choosing the right introspector, you can make Fixture Monkey work with your existing code without modifications, saving you time and effort.
Frequently Asked Questions (FAQ) # Q: I\u0026rsquo;m not sure which introspector to use. What should I do? # A: Start with the recommended setup (using FailoverIntrospector with multiple introspectors). It works for most projects and automatically tries different strategies.
FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(new FailoverIntrospector( Arrays.asList( ConstructorPropertiesArbitraryIntrospector.INSTANCE, BuilderArbitraryIntrospector.INSTANCE, FieldReflectionArbitraryIntrospector.INSTANCE, BeanArbitraryIntrospector.INSTANCE ), false // Disable logging for cleaner test output )) .build(); Q: My objects aren\u0026rsquo;t being generated. What should I check? # A: Ensure your class has one of the following:
A no-args constructor with setters (for BeanArbitraryIntrospector) A constructor with @ConstructorProperties (for ConstructorPropertiesArbitraryIntrospector) A builder method (for BuilderArbitraryIntrospector) Q: I\u0026rsquo;m using Lombok and my objects aren\u0026rsquo;t generating properly. What should I do? # A: Add lombok.anyConstructor.addConstructorProperties=true to your lombok.config file and use ConstructorPropertiesArbitraryIntrospector.
Q: What if I need custom creation logic for a specific class? # A: For specific cases, you can use the instantiate method to specify how an instance should be created:
MySpecialClass object = fixtureMonkey.giveMeBuilder(MySpecialClass.class) .instantiate(() -\u0026gt; new MySpecialClass(specialParam1, specialParam2)) .sample(); For more advanced custom logic, see the Custom Introspector guide, but most users won\u0026rsquo;t need this.
Available Introspectors (More Details) # BeanArbitraryIntrospector (Default) # Best for: Standard JavaBean classes with setters
Requirements:
Class must have a no-args constructor Class must have setter methods for properties FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(BeanArbitraryIntrospector.INSTANCE) // This is the default .build(); ConstructorPropertiesArbitraryIntrospector # Best for: Immutable objects with constructors
Requirements:
Class must have a constructor with @ConstructorProperties or be a record type For Lombok, add lombok.anyConstructor.addConstructorProperties=true to lombok.config FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .build(); FieldReflectionArbitraryIntrospector # Best for: Classes with field access
Requirements:
Class must have a no-args constructor Fields can be accessed via reflection FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(FieldReflectionArbitraryIntrospector.INSTANCE) .build(); BuilderArbitraryIntrospector # Best for: Classes using the builder pattern
Requirements:
Class must have a builder with set methods and a build method FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(BuilderArbitraryIntrospector.INSTANCE) .build(); FailoverArbitraryIntrospector (Recommended for Mixed Codebases) # Best for: Projects with a mix of class types
Benefits:
Tries multiple introspectors in sequence Works with various class patterns Most versatile option FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(new FailoverIntrospector( Arrays.asList( ConstructorPropertiesArbitraryIntrospector.INSTANCE, BuilderArbitraryIntrospector.INSTANCE, FieldReflectionArbitraryIntrospector.INSTANCE, BeanArbitraryIntrospector.INSTANCE ), false // Disable logging for cleaner test output )) .build(); If you want to disable the fail log, set the constructor argument enableLoggingFail to false as shown above.
âš ï¸ Performance note: \`FailoverArbitraryIntrospector\` may increase generation costs as it attempts to create objects using each registered introspector in sequence. When performance is a concern, use a specific introspector if you know your class patterns. PriorityConstructorArbitraryIntrospector # Best for: Special cases where other introspectors don\u0026rsquo;t work
Benefits:
Uses available constructors even without @ConstructorProperties Helpful for library classes you can\u0026rsquo;t modify FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(PriorityConstructorArbitraryIntrospector.INSTANCE) .build(); Additional Introspectors from Plugins # Plugins provide additional introspectors for specific needs:
JacksonObjectArbitraryIntrospector for Jackson JSON objects PrimaryConstructorArbitraryIntrospector for Kotlin classes How Introspectors Work (Technical Details) # graph TD A[Object Creation Request] --\u0026gt; B{Introspector Selection} B -- BeanArbitraryIntrospector --\u0026gt; C[Use Default Constructor \u0026#43; Setters] B -- ConstructorProperties --\u0026gt; D[Use Annotated Constructor] B -- FieldReflection --\u0026gt; E[Set Fields with Reflection] B -- Builder --\u0026gt; F[Use Builder Pattern] B -- Failover --\u0026gt; G[Try Multiple Introspectors Sequentially] C --\u0026gt; H[Object Instance] D --\u0026gt; H E --\u0026gt; H F --\u0026gt; H G --\u0026gt; H Need More Advanced Customization? # If you have special requirements for object creation that aren\u0026rsquo;t covered by the built-in introspectors, you might need to create a custom introspector.
This is an advanced topic and most users won\u0026rsquo;t need it. If you\u0026rsquo;re interested, see the Custom Introspector guide.
`}),e.add({id:17,href:"/v1-1-0/docs/generating-objects/custom-introspector/",title:"Creating Custom Introspector",description:`Note: This guide is for advanced users who already understand Fixture Monkey basics. Most users won\u0026rsquo;t need to create custom introspectors as the built-in ones handle common scenarios. If you\u0026rsquo;re just getting started, check the Introspector guide first.
When Would You Need a Custom Introspector? # You might need to create a custom introspector in these specific situations:
Your classes have unique creation requirements that built-in introspectors can\u0026rsquo;t handle You\u0026rsquo;re working with third-party libraries that follow unconventional patterns Your objects need special initialization logic that can\u0026rsquo;t be addressed with the instantiate method If none of these apply to you, the built-in introspectors will likely be sufficient.`,content:` Note: This guide is for advanced users who already understand Fixture Monkey basics. Most users won\u0026rsquo;t need to create custom introspectors as the built-in ones handle common scenarios. If you\u0026rsquo;re just getting started, check the Introspector guide first.
When Would You Need a Custom Introspector? # You might need to create a custom introspector in these specific situations:
Your classes have unique creation requirements that built-in introspectors can\u0026rsquo;t handle You\u0026rsquo;re working with third-party libraries that follow unconventional patterns Your objects need special initialization logic that can\u0026rsquo;t be addressed with the instantiate method If none of these apply to you, the built-in introspectors will likely be sufficient.
Basic Approaches # There are two main ways to create custom introspectors:
1. Assembling Objects from Properties # This approach is useful when you need to manually construct objects using their properties:
// Example custom introspector that handles a specific class type public class CustomArbitraryIntrospector implements ArbitraryIntrospector { @Override public ArbitraryIntrospectorResult introspect(ArbitraryGeneratorContext context) { // Step 1: Check if this introspector should handle this type Class\u0026lt;?\u0026gt; type = context.getResolvedType().getType(); if (!MyCustomClass.class.isAssignableFrom(type)) { // If not our target type, let other introspectors handle it return ArbitraryIntrospectorResult.NOT_INTROSPECTED; } // Step 2: Get the properties Fixture Monkey generated for this object Map\u0026lt;ArbitraryProperty, CombinableArbitrary\u0026lt;?\u0026gt;\u0026gt; arbitrariesByProperty = context.getCombinableArbitrariesByArbitraryProperty(); // Step 3: Build the object using these properties CombinableArbitrary\u0026lt;MyCustomClass\u0026gt; combinableArbitrary = CombinableArbitrary.objectBuilder() .properties(arbitrariesByProperty) .build(propertyValues -\u0026gt; { // Create a new instance of our class MyCustomClass obj = new MyCustomClass(); // Set each property value propertyValues.forEach((property, value) -\u0026gt; { String propertyName = property.getName(); if (\u0026quot;name\u0026quot;.equals(propertyName)) { obj.setName((String) value); } else if (\u0026quot;value\u0026quot;.equals(propertyName)) { obj.setValue((Integer) value); } }); return obj; }); // Step 4: Return the result return new ArbitraryIntrospectorResult(combinableArbitrary); } } 1.1 Defining Required Properties # Sometimes you need to customize how child properties are discovered and generated:
// Override this method to control property generation for specific properties @Override @Nullable public PropertyGenerator getRequiredPropertyGenerator(Property property) { // Check if this property needs special handling if (\u0026quot;nestedObject\u0026quot;.equals(property.getName())) { // Create a generator that only includes specific fields return new FieldPropertyGenerator( // Only include id and name fields field -\u0026gt; \u0026quot;id\u0026quot;.equals(field.getName()) || \u0026quot;name\u0026quot;.equals(field.getName()), // Match all fields that pass the filter field -\u0026gt; true ); } // For other properties, use the default generator return null; } 2. Returning Fixed Instances # Sometimes you just need to return a constant or specially calculated value:
// Example introspector that returns a fixed value for a specific type public class ConstantArbitraryIntrospector implements ArbitraryIntrospector { private final Object constantValue; public ConstantArbitraryIntrospector(Object constantValue) { this.constantValue = constantValue; } @Override public ArbitraryIntrospectorResult introspect(ArbitraryGeneratorContext context) { Class\u0026lt;?\u0026gt; type = context.getResolvedType().getType(); // Make sure our constant is the right type if (!type.isInstance(constantValue)) { return ArbitraryIntrospectorResult.NOT_INTROSPECTED; } // Return our constant value return new ArbitraryIntrospectorResult( CombinableArbitrary.from(constantValue) ); } } Using Your Custom Introspector # After creating your introspector, you can use it in two ways:
As the Primary Introspector # // Create your custom introspector ArbitraryIntrospector customIntrospector = new CustomArbitraryIntrospector(); // Use it as the main introspector FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(customIntrospector) .build(); // Generate objects MyCustomClass obj = fixtureMonkey.giveMeOne(MyCustomClass.class); Combined with Other Introspectors # Usually, you\u0026rsquo;ll want to combine your custom introspector with the built-in ones:
// Create a Fixture Monkey that tries your introspector first, // then falls back to the standard ones if yours doesn't apply FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(new FailoverIntrospector( Arrays.asList( customIntrospector, // Try your custom one first ConstructorPropertiesArbitraryIntrospector.INSTANCE, BuilderArbitraryIntrospector.INSTANCE, FieldReflectionArbitraryIntrospector.INSTANCE, BeanArbitraryIntrospector.INSTANCE ) )) .build(); Best Practices # When creating custom introspectors:
Always check the type before processing, returning NOT_INTROSPECTED for types your introspector doesn\u0026rsquo;t handle Handle exceptions gracefully to prevent test failures Keep it focused - each introspector should handle a specific pattern or class type Consider performance since introspectors run for every object creation Test thoroughly with various edge cases Advanced: Property Generators # Fixture Monkey provides several built-in PropertyGenerator implementations that can help with custom property discovery:
FieldPropertyGenerator # Useful for creating properties based on class fields:
// Generate properties based on fields with specific conditions new FieldPropertyGenerator( // Only non-final fields with a specific annotation field -\u0026gt; !Modifier.isFinal(field.getModifiers()) \u0026amp;\u0026amp; field.isAnnotationPresent(MyRequired.class), // Include all fields that pass the filter field -\u0026gt; true ) CompositePropertyGenerator # Combines multiple property generators:
// Use both field and JavaBeans property generation together new CompositePropertyGenerator( Arrays.asList( new FieldPropertyGenerator(field -\u0026gt; true, matcher -\u0026gt; true), new JavaBeansPropertyGenerator( descriptor -\u0026gt; descriptor.getReadMethod() != null, matcher -\u0026gt; true ) ) ) DefaultPropertyGenerator # A pre-configured combination of common generators:
// Uses standard field and JavaBeans property generation new DefaultPropertyGenerator() Conclusion # Creating custom introspectors is an advanced topic, but it gives you complete control over object creation in Fixture Monkey. Most users won\u0026rsquo;t need this level of customization, but it\u0026rsquo;s available when you have special requirements that the built-in introspectors can\u0026rsquo;t handle.
If you have any questions about custom introspectors, refer to the source code of the built-in introspectors for examples of different implementation approaches.
`}),e.add({id:18,href:"/v1-1-0/docs/customizing-objects/",title:"Customizing Objects",description:"",content:""}),e.add({id:19,href:"/v1-1-0/docs/plugins/interface-plugin/",title:"Interface Plugin",description:"",content:""}),e.add({id:20,href:"/v1-1-0/docs/customizing-objects/apis/",title:"Customization APIs",description:`Fixture Monkey offers a range of APIs within the ArbitraryBuilder class that enable customization of objects created by it.
Customizing Fixtures # set() # The set() method is used to assign values to one or more properties referenced by the expression.
Different types, including Supplier, Arbitrary, ArbitraryBuilder, NOT_NULL, NULL, or Just can be used as the value. Additionally, a certain instance of an object can also be used as the value.`,content:`Fixture Monkey offers a range of APIs within the ArbitraryBuilder class that enable customization of objects created by it.
Customizing Fixtures # set() # The set() method is used to assign values to one or more properties referenced by the expression.
Different types, including Supplier, Arbitrary, ArbitraryBuilder, NOT_NULL, NULL, or Just can be used as the value. Additionally, a certain instance of an object can also be used as the value.
Java Kotlin fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026#34;id\u0026#34;, 1000); fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setExp(Product::id, 1000) Just # Using an instance wrapped by Just when using set() makes you set the value directly instead of decomposing. Normally, when you set() a property in ArbitraryBuilder it does not use an instance of the given value, it does a deep copy instead. So, if you need to set with an instance, you can use Values.just(instance) This feature can be useful in cases where you need to set a property to a mock instance when using a mocking framework.
Note that you cannot set a child property after setting with Just.
Product product = fixture.giveMeBuilder(Product.class) .set(\u0026quot;options\u0026quot;, Values.just(List.of(\u0026quot;red\u0026quot;, \u0026quot;medium\u0026quot;, \u0026quot;adult\u0026quot;)) .set(\u0026quot;options[0]\u0026quot;, \u0026quot;blue\u0026quot;) .sample(); For example, the product instance created above, will not have the value \u0026ldquo;blue\u0026rdquo; for the first element of options. It will remain the list given with Just.
size(), minSize(), maxSize() # The size() method lets you specify the size of container properties. You have the flexibility to either set a precise size or specify a range using the minimum and maximum values.
Alternatively, you can use minSize() or maxSize() to set only the minimum or maximum container size. (By default, the size range is from 0 to 3 elements.)
Java Kotlin fixtureMonkey.giveMeBuilder(Product.class) .size(\u0026#34;options\u0026#34;, 5); // size:5 fixtureMonkey.giveMeBuilder(Product.class) .size(\u0026#34;options\u0026#34;, 3, 5); // minSize:3, maxSize:5 fixtureMonkey.giveMeBuilder(Product.class) .minSize(\u0026#34;options\u0026#34;, 3); // minSize:3 fixtureMonkey.giveMeBuilder(Product.class) .maxSize(\u0026#34;options\u0026#34;, 5); // maxSize:5 fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .sizeExp(Product::options, 5) // size:5 fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .sizeExp(Product::options, 3, 5) // minSize:3, maxSize:5 fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .minSizeExp(Product::options, 3) // minSize:3 fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .maxSizeExp(Product::options, 5) // maxSize:5 setNull(), setNotNull() # At times, you might want to ensure that a property is either always set to null or always has a value. In such situations, you can use setNull() or setNotNull().
Java Kotlin fixtureMonkey.giveMeBuilder(Product.class) .setNull(\u0026#34;id\u0026#34;); fixtureMonkey.giveMeBuilder(Product.class) .setNotNull(\u0026#34;id\u0026#34;); fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setNullExp(Product::id) fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setNotNullExp(Product::id) setInner() # With setInner() you can apply customizations defined within an InnerSpec instance to your builder. An InnerSpec is a type-independent specification for the customizations to be applied.
Instances of InnerSpec can be reused to consistently and easily configure nested properties. This feature is particularly beneficial when customizing map properties.
For additional guidance, refer to InnerSpec
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, it -\u0026gt; it.entry(1000, \u0026#34;ABC Store\u0026#34;)); fixtureMonkey.giveMeBuilder(Product.class) .setInner(innerSpec) val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.entry(1000, \u0026#34;ABC Store\u0026#34;) } fixtureMonkey.giveMeBuilder(Product.class) .setInner(innerSpec) setLazy() # The setLazy() function assigns the property a value obtained from the provided Supplier. The Supplier will run every time the ArbitraryBuilder is sampled.
This can be particularly useful when you need to generate unique sequential IDs or set the most recent value.
Java Kotlin AtomicReference\u0026lt;Long\u0026gt; variable = new AtomicReference\u0026lt;\u0026gt;(0L); ArbitraryBuilder\u0026lt;Long\u0026gt; builder = fixtureMonkey.giveMeBuilder(Long.class) .setLazy(\u0026#34;$\u0026#34;, () -\u0026gt; variable.getAndSet(variable.get() + 1)); Long actual1 = builder.sample(); // actual1 == 0 Long actual2 = builder.sample(); // actual2 == 1 var variable = 0L val builder = fixtureMonkey.giveMeBuilder(Long::class.java) .setLazy(\u0026#34;$\u0026#34;) { variable++ } val actual1 = builder.sample() // actual1 == 0 val actual2 = builder.sample() // actual2 == 1 setPostCondition() # setPostCondition() can be used when your fixture needs to adhere to a specific condition. This condition can be defined by passing a predicate.
ðŸš¨ Using setPostCondition can incur higher costs for narrow conditions. In such cases, it's recommended to use set instead. Java Kotlin fixtureMonkey.giveMeBuilder(Product.class) .setPostCondition(\u0026#34;id\u0026#34;, Long.class, it -\u0026gt; it \u0026gt; 0) fixtureMonkey.giveMeBuilder(Product::class.java) .setPostConditionExp(Product::id, Long::class.java) { it: Long -\u0026gt; it \u0026gt; 0 } fixed() # fixed() can be used when you want your arbitrary builder to consistently return instances with the same values every time it is sampled.
Java Kotlin fixtureMonkey.giveMeBuilder(Product.class) .fixed() fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .fixed() limit # For the set(), setLazy(), and setPostCondition() methods, you can include an additional parameter that determines the number of times the customization will be applied. This can be advantageous when the expression refers to multiple properties.
Java Kotlin fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026#34;options[*]\u0026#34;, \u0026#34;red\u0026#34;, 2); // up to 2 elements in options will be set to \u0026#34;red\u0026#34; fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .set(\u0026#34;options[*]\u0026#34;, \u0026#34;red\u0026#34;, 2) // up to 2 elements in options will be set to \u0026#34;red\u0026#34; Expanding Customization using Sampled Results # thenApply() # The thenApply() method becomes handy when you need to customize a field based on the sampled result of the builder. For instance, let\u0026rsquo;s assume you want the \u0026ldquo;productName\u0026rdquo; field to match the generated \u0026ldquo;id\u0026rdquo; of the Product. You can use thenApply() as follows:
Java Kotlin fixtureMonkey.giveMeBuilder(Product.class) .thenApply((it, builder) -\u0026gt; builder.set(\u0026#34;productName\u0026#34;, it.getId().toString())) fixtureMonkey.giveMeBuilder(Product::class.java) .thenApply{it, builder -\u0026gt; builder.setExp(Product::productName, it.id.toString())} acceptIf() # You might also find the need to perform additional customization based on a specific condition. In such cases, you can utilize the acceptIf() method, which applies the customization only when the predicate is satisfied.
Java Kotlin fixtureMonkey.giveMeBuilder(Product.class) .acceptIf( it -\u0026gt; it.getProductType() == ProductType.CLOTHING, builder -\u0026gt; builder.set(\u0026#34;price\u0026#34;, 1000) ) fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .acceptIf( { it.productType == ProductType.CLOTHING }, { builder -\u0026gt; builder.setExp(Product::price, 1000) } ) Transforming the Type of ArbitraryBuilder # map() # The map() function is used to convert the ArbitraryBuilder type into another type.
Java Kotlin fixtureMonkey.giveMeBuilder(Product.class) .map(Product::getId); // transforms to ArbitraryBuilder\u0026lt;Long\u0026gt; fixtureMonkey.giveMeBuilder(Product::class.java) .map(Product::id) // transforms to ArbitraryBuilder\u0026lt;Long\u0026gt; zipWith() # zipWith() becomes useful when you want to merge multiple ArbitraryBuilders to create an ArbitraryBuilder of a different type. You have to define how you intend to combine the builders.
Java Kotlin ArbitraryBuilder\u0026lt;String\u0026gt; stringBuilder = fixtureMonkey.giveMeBuilder(String.class); ArbitraryBuilder\u0026lt;String\u0026gt; zipped = fixtureMonkey.giveMeBuilder(Integer.class) .zipWith(stringBuilder, (integer, string) -\u0026gt; integer + \u0026#34;\u0026#34; + string); val stringBuilder = fixtureMonkey.giveMeBuilder\u0026lt;String\u0026gt;() val zipped = fixtureMonkey.giveMeBuilder\u0026lt;Int\u0026gt;() .zipWith(stringBuilder) { int, string -\u0026gt; int.toString() + \u0026#34;\u0026#34; + string } `}),e.add({id:21,href:"/v1-1-0/docs/plugins/interface-plugin/features/",title:"Features",description:`The Interface Plugin is a powerful tool that enables Fixture Monkey to dynamically handle implementations of interfaces and abstract classes during object generation. It is particularly useful when you need to specify concrete implementations for interfaces or abstract classes in your test fixtures.
Abstract # Register concrete implementations for interfaces Register concrete implementations for abstract classes Anonymous arbitrary introspector usage option (default: enabled) Support for dynamic implementation resolution based on property characteristics using CandidateConcretePropertyResolver Basic Usage # FixtureMonkey sut = FixtureMonkey.`,content:`The Interface Plugin is a powerful tool that enables Fixture Monkey to dynamically handle implementations of interfaces and abstract classes during object generation. It is particularly useful when you need to specify concrete implementations for interfaces or abstract classes in your test fixtures.
Abstract # Register concrete implementations for interfaces Register concrete implementations for abstract classes Anonymous arbitrary introspector usage option (default: enabled) Support for dynamic implementation resolution based on property characteristics using CandidateConcretePropertyResolver Basic Usage # FixtureMonkey sut = FixtureMonkey.builder() .plugin(new InterfacePlugin() .interfaceImplements(MyInterface.class, Arrays.asList(MyInterfaceImpl1.class, MyInterfaceImpl2.class)) .abstractClassExtends(MyAbstractClass.class, Arrays.asList(MyConcreteClass1.class, MyConcreteClass2.class)) ) .build(); Disabling Anonymous Arbitrary Introspector # FixtureMonkey sut = FixtureMonkey.builder() .plugin(new InterfacePlugin() .interfaceImplements(MyInterface.class, Arrays.asList(MyInterfaceImpl.class)) .useAnonymousArbitraryIntrospector(false) ) .build(); API Reference # interfaceImplements # Registers implementations for a given interface.
public \u0026lt;T\u0026gt; InterfacePlugin interfaceImplements( Class\u0026lt;T\u0026gt; interfaceType, List\u0026lt;Class\u0026lt;? extends T\u0026gt;\u0026gt; implementations ) Parameters:
interfaceType: The interface class to be implemented implementations: List of classes implementing the interface abstractClassExtends # Registers implementations for a given abstract class.
public \u0026lt;T\u0026gt; InterfacePlugin abstractClassExtends( Class\u0026lt;T\u0026gt; abstractClassType, List\u0026lt;Class\u0026lt;? extends T\u0026gt;\u0026gt; implementations ) Parameters:
abstractClassType: The abstract class type to be implemented implementations: List of classes implementing the abstract class useAnonymousArbitraryIntrospector # Configures the use of an anonymous arbitrary introspector. By default, this option is enabled (default value: true). When enabled, it uses an instance of AnonymousArbitraryIntrospector as the fallback introspector.
public InterfacePlugin useAnonymousArbitraryIntrospector(boolean useAnonymousArbitraryIntrospector) Parameters:
useAnonymousArbitraryIntrospector: Whether to use the anonymous arbitrary introspector (default: true) Example:
// Default behavior (anonymous introspector enabled) FixtureMonkey sut = FixtureMonkey.builder() .plugin(new InterfacePlugin() .interfaceImplements(MyInterface.class, Arrays.asList(MyInterfaceImpl.class)) .useAnonymousArbitraryIntrospector(true) ) .build(); // Anonymous introspector disabled FixtureMonkey sut2 = FixtureMonkey.builder() .plugin(new InterfacePlugin() .interfaceImplements(MyInterface.class, Arrays.asList(MyInterfaceImpl.class)) .useAnonymousArbitraryIntrospector(false) ) .build(); Examples # Basic Interface Implementation # interface Animal { String sound(); } class Dog implements Animal { @Override public String sound() { return \u0026quot;Woof\u0026quot;; } } class Cat implements Animal { @Override public String sound() { return \u0026quot;Meow\u0026quot;; } } FixtureMonkey sut = FixtureMonkey.builder() .plugin(new InterfacePlugin() .interfaceImplements(Animal.class, Arrays.asList(Dog.class, Cat.class)) ) .build(); // Returns either a Dog or Cat instance Animal animal = sut.giveMeOne(Animal.class); Abstract Class Implementation # abstract class Vehicle { abstract int getWheels(); } class Car extends Vehicle { @Override int getWheels() { return 4; } } class Bike extends Vehicle { @Override int getWheels() { return 2; } } FixtureMonkey sut = FixtureMonkey.builder() .plugin(new InterfacePlugin() .abstractClassExtends(Vehicle.class, Arrays.asList(Car.class, Bike.class)) ) .build(); // Returns either a Car or Bike instance Vehicle vehicle = sut.giveMeOne(Vehicle.class); Anonymous Object Generation # When useAnonymousArbitraryIntrospector is enabled, you can generate anonymous implementations for interfaces that don\u0026rsquo;t have registered implementations. The plugin uses JDK Dynamic Proxy to create these implementations, allowing you to customize the generated values. Here\u0026rsquo;s an example:
interface UserService { String getUserName(); int getUserAge(); List\u0026lt;String\u0026gt; getUserRoles(); // Default method - behavior varies by JDK version default String getFullInfo() { return getUserName() + \u0026quot; (\u0026quot; + getUserAge() + \u0026quot;)\u0026quot;; } } FixtureMonkey sut = FixtureMonkey.builder() .plugin(new InterfacePlugin() .useAnonymousArbitraryIntrospector(true) ) .build(); // Generates an anonymous implementation with random values using JDK Dynamic Proxy UserService anonymousUserService = sut.giveMeOne(UserService.class); // Customizes the generated values UserService customAnonymousUserService = sut.giveMeBuilder(UserService.class) .set(\u0026quot;userName\u0026quot;, \u0026quot;John Doe\u0026quot;) .set(\u0026quot;userAge\u0026quot;, 30) .set(\u0026quot;userRoles\u0026quot;, Arrays.asList(\u0026quot;ADMIN\u0026quot;, \u0026quot;USER\u0026quot;)) .sample(); The generated anonymous implementation:
Is created using JDK Dynamic Proxy Returns random values for all interface methods by default Can be customized using giveMeBuilder Maintains consistent values across multiple method calls Supports all primitive types, objects, and collections Note: Default method behavior varies by JDK version:
In JDK 17, default methods maintain their original implementation In JDK versions prior to 17, default methods are proxied and return random values This means the original implementation is ignored, and default methods return random values like other methods For example, the getFullInfo() method will return a random string instead of using its original implementation Advanced Usage # Using Custom Matchers # FixtureMonkey sut = FixtureMonkey.builder() .plugin(new InterfacePlugin() .interfaceImplements( new ExactTypeMatcher(MyInterface.class), Arrays.asList(MyInterfaceImpl1.class, MyInterfaceImpl2.class) ) ) .build(); Using CandidateConcretePropertyResolver # CandidateConcretePropertyResolver provides a flexible way to dynamically determine concrete implementations for interfaces or abstract classes. It can make decisions at runtime based on various factors:
Property name Property type Property annotations Property metadata Other property characteristics The resolver\u0026rsquo;s resolve method is called for each property that requires a concrete implementation, enabling you to:
Return a single implementation for specific cases Return multiple implementations for random selection Return different implementations based on property characteristics Apply complex business logic to determine the appropriate implementation Here\u0026rsquo;s an example:
interface Animal { String sound(); String getName(); } class Dog implements Animal { @Override public String sound() { return \u0026quot;Woof\u0026quot;; } @Override public String getName() { return \u0026quot;Dog\u0026quot;; } } class Cat implements Animal { @Override public String sound() { return \u0026quot;Meow\u0026quot;; } @Override public String getName() { return \u0026quot;Cat\u0026quot;; } } // Custom resolver that returns implementations only when the property name is \u0026quot;animal\u0026quot; class AnimalResolver implements CandidateConcretePropertyResolver { @Override public List\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; resolve(Property property) { if (\u0026quot;animal\u0026quot;.equals(property.getName())) { return Arrays.asList(Dog.class, Cat.class); } return Collections.emptyList(); } } FixtureMonkey sut = FixtureMonkey.builder() .plugin(new InterfacePlugin() .interfaceImplements( new ExactTypeMatcher(Animal.class), new AnimalResolver() ) ) .build(); // Randomly selects either Dog or Cat when the property name is \u0026quot;animal\u0026quot; Animal animal = sut.giveMeOne(Animal.class); `}),e.add({id:22,href:"/v1-1-0/docs/customizing-objects/arbitrary/",title:"Customizing as random range values",description:`Jqwik is a Property-Based Testing library for the JVM environment. Fixture Monkey relies on Jqwik\u0026rsquo;s Arbitrary to generate random values for primitive types such as characters, strings, and integers.
In Jqwik, Arbitrary is the core interface used to represent objects that can be generated and shrunk. At times, we might desire our fixture properties to have random values while adhering to certain constraints.
In such scenarios, you can achieve this by customizing properties using Fixture Monkey\u0026rsquo;s set() method and assigning an Arbitrary as the value.`,content:`Jqwik is a Property-Based Testing library for the JVM environment. Fixture Monkey relies on Jqwik\u0026rsquo;s Arbitrary to generate random values for primitive types such as characters, strings, and integers.
In Jqwik, Arbitrary is the core interface used to represent objects that can be generated and shrunk. At times, we might desire our fixture properties to have random values while adhering to certain constraints.
In such scenarios, you can achieve this by customizing properties using Fixture Monkey\u0026rsquo;s set() method and assigning an Arbitrary as the value. You can generate an Arbitrary that matches certain conditions, simply by calling static methods in Jqwik\u0026rsquo;s Arbitraries class.
The following code example demonstrates ways to customize random values using set() with Arbitrary: Java Kotlin Product actual = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026#34;id\u0026#34;, Arbitraries.longs().greaterOrEqual(1000)) .set(\u0026#34;productName\u0026#34;, Arbitraries.strings().withCharRange(\u0026#39;a\u0026#39;, \u0026#39;z\u0026#39;).ofMaxLength(10)) .set(\u0026#34;productType\u0026#34;, Arbitraries.of(ProductType.CLOTHING, ProductType.ELECTRONICS)) .sample(); then(actual.getId()).isGreaterThanOrEqualTo(1000); then(actual.getProductName()).matches(\u0026#34;^[a-z]+$\u0026#34;); then(actual.getProductName().length()).isLessThanOrEqualTo(10); then(actual.getProductType()).matches(it -\u0026gt; it == ProductType.CLOTHING || it == ProductType.ELECTRONICS); val actual = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setExp(Product::id, Arbitraries.longs().greaterOrEqual(1000)) .setExp(Product::productName, Arbitraries.strings().withCharRange(\u0026#39;a\u0026#39;, \u0026#39;z\u0026#39;).ofMaxLength(10)) .setExp(Product::productType, Arbitraries.of(ProductType.CLOTHING, ProductType.ELECTRONICS)) .sample() then(actual.id).isGreaterThanOrEqualTo(1000) then(actual.productName).matches(\u0026#34;^[a-z]+$\u0026#34;) then(actual.productName.length).isLessThanOrEqualTo(10) then(actual.productType).matches { it -\u0026gt; it === ProductType.CLOTHING || it === ProductType.ELECTRONICS } For further details about Jqwik and Arbitrary, check out Jqwik User Guide
`}),e.add({id:23,href:"/v1-1-0/docs/customizing-objects/interface/",title:"Customizing Interface",description:`The ArbitraryBuilder API is also valid within the interface. You can customize the interface properties regardless of the interface type as said in Generating Interface Type The interface type refers to interface, generic interface ,selaed interface.
public interface StringSupplier { String getValue(); } FixtureMonkey fixture = FixtureMonkey.create(); String result = fixture.giveMeBuilder(StringSupplier.class) .set(\u0026quot;value\u0026quot;, \u0026quot;fix\u0026quot;) .sample() .getValue(); The properties of the interface in ArbitraryBuilder differ in the implementation. Unfortunately, there is currently no ArbitraryBuilder API that resolves the implementation of the interface.`,content:`The ArbitraryBuilder API is also valid within the interface. You can customize the interface properties regardless of the interface type as said in Generating Interface Type The interface type refers to interface, generic interface ,selaed interface.
public interface StringSupplier { String getValue(); } FixtureMonkey fixture = FixtureMonkey.create(); String result = fixture.giveMeBuilder(StringSupplier.class) .set(\u0026quot;value\u0026quot;, \u0026quot;fix\u0026quot;) .sample() .getValue(); The properties of the interface in ArbitraryBuilder differ in the implementation. Unfortunately, there is currently no ArbitraryBuilder API that resolves the implementation of the interface. Unless the interface has only one implementation, you can customize the properties of the interface, not the implementation.
You cannot generate the randomly populated intended implementation, but you can generate the fixed implementation by using the set API. There are two cases, with the interfaceImplements option and without the interfaceImplements option.
With the option # The interface type is resolved to the implementation when you use the set API with the option.
public interface ObjectValueSupplier { Object getValue(); } public class StringValueSupplier implements ObjectValueSupplier { private final String value; @ConstructorProperties(\u0026quot;value\u0026quot;) // It is not needed if you are using Lombok. public StringValueSupplier(String value) { this.value = value; } @Override public String getValue() { return value; } } public class IntegerValueSupplier implements ObjectValueSupplier { private final int value; private final int implementationValue; @ConstructorProperties({\u0026quot;value\u0026quot;, \u0026quot;implementationValue\u0026quot;}) // It is not needed if you are using Lombok. public IntegerValueSupplier(int value, int implementationValue) { this.value = value; this.implementationValue = implementationValue; } @Override public Integer getValue() { return value; } public int getImplementationValue() { return implementationValue; } } FixtureMonkey fixture = FixtureMonkey.builder() .objectIntrospector( ConstructorPropertiesArbitraryIntrospector.INSTANCE) // used for instantiate implementations of ObjectValueSupplier .plugin( new InterfacePlugin() .interfaceImplements( ObjectValueSupplier.class, List.of(StringValueSupplier.class, IntegerValueSupplier.class) ) ) .build(); IntegerValueSupplier integerValueSupplier = (IntegerValueSupplier)fixture.giveMeBuilder(ObjectValueSupplier.class) .set(\u0026quot;$\u0026quot;, new IntegerValueSupplier(-1203)) .sample(); You can also change the properties of the implementation.
IntegerValueSupplier integerValueSupplier = (IntegerValueSupplier)fixture.giveMeBuilder(ObjectValueSupplier.class) .set(\u0026quot;$\u0026quot;, new IntegerValueSupplier(-1203, 1203)) .set(\u0026quot;implementationValue\u0026quot;, 1) // it works. .sample(); Without the option # You have to use the set API in a specific way with Values.just.
public interface ObjectValueSupplier { Object getValue(); } public class StringValueSupplier implements ObjectValueSupplier { private final String value; @ConstructorProperties(\u0026quot;value\u0026quot;) // It is not needed if you are using Lombok. public StringValueSupplier(String value) { this.value = value; } @Override public String getValue() { return value; } } public class IntegerValueSupplier implements ObjectValueSupplier { private final int value; @ConstructorProperties(\u0026quot;value\u0026quot;) // It is not needed if you are using Lombok. public IntegerValueSupplier(int value) { this.value = value; } @Override public Integer getValue() { return value; } } FixtureMonkey fixture = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) // used for instantiate implementations of ObjectValueSupplier .build(); IntegerValueSupplier integerValueSupplier = (IntegerValueSupplier)fixture.giveMeBuilder(ObjectValueSupplier.class) .set(\u0026quot;$\u0026quot;, Values.just(new IntegerValueSupplier(-1203))) .sample(); The implementation is not used by interfaceImplements, Fixture Monkey does not know the properties of the implementation. You cannot set the properties of the implementation.
IntegerValueSupplier integerValueSupplier = (IntegerValueSupplier)fixture.giveMeBuilder(ObjectValueSupplier.class) .set(\u0026quot;$\u0026quot;, Values.just(new IntegerValueSupplier(-1203))) .set(\u0026quot;value\u0026quot;, 1) // not works .sample(); `}),e.add({id:24,href:"/v1-1-0/docs/customizing-objects/path-expressions/",title:"Path expressions",description:`When using Fixture Monkey, you have the flexibility to select one or more properties of an object using Fixture Monkey expressions.
Let\u0026rsquo;s consider an example object structure:
@Value public class JavaClass { String field; String[] array; List\u0026lt;String\u0026gt; list; Nested object; List\u0026lt;Nested\u0026gt; objectList; @Value public static class Nested { String nestedField; } } Selecting Properties Using String Expressions # Selecting the root object: # \u0026quot;$\u0026quot; Selecting a specific field: # \u0026quot;field\u0026quot; Selecting a nested field: # \u0026quot;object.`,content:`When using Fixture Monkey, you have the flexibility to select one or more properties of an object using Fixture Monkey expressions.
Let\u0026rsquo;s consider an example object structure:
@Value public class JavaClass { String field; String[] array; List\u0026lt;String\u0026gt; list; Nested object; List\u0026lt;Nested\u0026gt; objectList; @Value public static class Nested { String nestedField; } } Selecting Properties Using String Expressions # Selecting the root object: # \u0026quot;$\u0026quot; Selecting a specific field: # \u0026quot;field\u0026quot; Selecting a nested field: # \u0026quot;object.nestedField\u0026quot; Selecting the n-th element of a collection: # \u0026quot;list[n]\u0026quot; Selecting all elements of a collection: # \u0026quot;list[*]\u0026quot; Selecting the n-th element of an array: # \u0026quot;array[n]\u0026quot; Selecting all elements of an array: # \u0026quot;array[*]\u0026quot; Combining expressions to select a nested field: # \u0026quot;objectList[0].nestedField\u0026quot; Selecting Properties Using JavaGetter Selector # There is a type-safe way to select properties using a javaGetter() property selector. This selector is designed to choose and represent a property through a getter method reference in Java.
Selecting the root object: # Currently Not Supported Selecting a specific field: # javaGetter(JavaClass::getField) Selecting a nested field: # javaGetter(JavaClass::getObject).into(Nested::getNestedField) Selecting the n-th element of a collection: # javaGetter(JavaClass::getList).index(String.class, n) Selecting all elements of a collection: # javaGetter(JavaClass::getList).allIndex(String.class) Selecting the n-th element of an array: # javaGetter(JavaClass::getArray).index(String.class, n) Selecting all elements of an array: # javaGetter(JavaClass::getArray).allIndex(String.class) Combining expressions to select a nested field: # javaGetter(JavaClass::getObjectList) .index(Nested.class, 0) .into(Nested::getNestedField) Selecting Collections # Note that for collections, a property will only be selected if it exists within the collection size. For instance, if the list has a size of 2 but the expression references \u0026quot;list[3]\u0026quot;, which is outside the bounds of the list, it will not be selected.
While Fixture Monkey supports selecting elements from lists and sets, there are currently no dedicated expressions for directly setting the elements of a map. However, if you need to customize a map, consider using the InnerSpec method.
Expression Strict Mode # This option can be turned on to ensure applied expressions strictly match the structure. If any part of an expression is out of bounds or invalid, Fixture Monkey will raise an exception.
Kotlin EXP # By adding the Kotlin plugin, you can select properties using Kotlin\u0026rsquo;s property reference syntax. In Fixture Monkey, this feature is referred to as Kotlin EXP or the Fixture Monkey Kotlin DSL. For further details on its usage, refer to the Kotlin DSL Exp page.
`}),e.add({id:25,href:"/v1-1-0/docs/customizing-objects/innerspec/",title:"InnerSpec",description:`An InnerSpec is a type-independent specification for the customizations you wish to apply. Using the setInner() method within ArbitraryBuilder, you can apply customizations defined within an InnerSpec instance into your builder.
InnerSpec holds customization details and can be reused on ArbitraryBuilders. Unlike using expressions used in ArbitraryBuilder, InnerSpec enables a more nested and structured approach.
An added advantage of InnerSpec is its ability to customize map properties, unlike normal expressions.`,content:`An InnerSpec is a type-independent specification for the customizations you wish to apply. Using the setInner() method within ArbitraryBuilder, you can apply customizations defined within an InnerSpec instance into your builder.
InnerSpec holds customization details and can be reused on ArbitraryBuilders. Unlike using expressions used in ArbitraryBuilder, InnerSpec enables a more nested and structured approach.
An added advantage of InnerSpec is its ability to customize map properties, unlike normal expressions.
ðŸ’¡ Kotlin EXP is not supported for InnerSpec, as it is designed to be type-independent. Instead, you need to specify the property by its name. Applying InnerSpec to the ArbitraryBuilder # To apply your pre-defined InnerSpec to the builder, use the setInner() method as shown below:
Java Kotlin InnerSpec innerSpec = new InnerSpec().property(\u0026#34;id\u0026#34;, 1000); fixtureMonkey.giveMeBuilder(Product.class) .setInner(innerSpec); val innerSpec = InnerSpec().property(\u0026#34;id\u0026#34;, 1000) fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setInner(innerSpec) Customizing properties # property() # Similar to the set() method in ArbitraryBuilder, you can customize a property by specifying its name and providing the desired value.
ðŸš¨ Fixture Monkey expressions such as refering elements (\`[]\`) or nested fields(\`.\`) are not allowed as the property name. Only the property name itself is allowed. Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;id\u0026#34;, 1000); val innerSpec = InnerSpec() .property(\u0026#34;id\u0026#34;, 1000) size(), minSize(), maxSize() # size(), minSize(), and maxSize() can be used to specify the size of the property.
As previously mentioned, InnerSpec defines customizations in a nested manner. You can first select the container property using property() and then proceed to define an innerSpec consumer to set the size.
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;options\u0026#34;, options -\u0026gt; options.size(5)); // size:5 InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;options\u0026#34;, options -\u0026gt; options.size(3, 5)); // minSize:3, maxSize:5 InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;options\u0026#34;, options -\u0026gt; options.minSize(3)); // minSize:3 InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;options\u0026#34;, options -\u0026gt; options.maxSize(5)); // maxSize:5 val innerSpec = InnerSpec() .property(\u0026#34;options\u0026#34;) { it.size(5) } // size:5 val innerSpec = InnerSpec() .property(\u0026#34;options\u0026#34;) { it.size(3, 5) } // minSize:3, maxSize:5 val innerSpec = InnerSpec() .property(\u0026#34;options\u0026#34;) { it.minSize(3) } // minSize:3 val innerSpec = InnerSpec() .property(\u0026#34;options\u0026#34;) { it.maxSize(5) } // maxSize:5 postCondition() # postCondition() can be used when you require your property to match a specific condition.
ðŸš¨ Using setPostCondition can incur higher costs for narrow conditions. In such cases, it's recommended to use set instead. Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;id\u0026#34;, id -\u0026gt; id.postCondition(Long.class, it -\u0026gt; it \u0026gt; 0)); val innerSpec = InnerSpec() .property(\u0026#34;id\u0026#34;) { it.postCondition(Long::class.java) { it \u0026gt; 0 }} inner() # You can also customize a property using another pre-defined InnerSpec with the help of inner().
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;id\u0026#34;, 1000L); fixtureMonkey.giveMeBuilder(Product.class) .setInner( new InnerSpec() .property(\u0026#34;nestedObject\u0026#34;, nestedObject -\u0026gt; nestedObject.inner(innerSpec)) ); val innerSpec = InnerSpec() .property(\u0026#34;id\u0026#34;, 1000L) fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setInner( InnerSpec() .property(\u0026#34;nestedObject\u0026#34;) { it.inner(innerSpec) } ) Customizing list properties # listElement() # Individual elements within lists can be selected using listElement(). This is equivalent to referencing elements with \u0026ldquo;[n]\u0026rdquo; using expressions.
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;options\u0026#34;, options -\u0026gt; options.listElement(0, \u0026#34;red\u0026#34;)); val innerSpec = InnerSpec() .property(\u0026#34;options\u0026#34;) { it.listElement(0, \u0026#34;red\u0026#34;) } allListElement() # If you wish to set all elements of the list simultaneously, you can use allListElement(). This is equivalent to referencing elements with \u0026ldquo;[*]\u0026rdquo; using expressions.
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;options\u0026#34;, options -\u0026gt; options.allListElement(\u0026#34;red\u0026#34;)); val innerSpec = InnerSpec() .property(\u0026#34;options\u0026#34;) { it.allListElement(\u0026#34;red\u0026#34;) } Customizing map properties # InnerSpec provides special methods for customizing map property entries.
ðŸš¨ Similar to lists, setting a map entry without specifying the size first might lead to no change. Prior to setting a value, ensure that the map property has the intended size. key(), value(), entry() # You can customize map property entries using key(), value(), and entry() methods. Using key() assigns a specified value to the key of a map entry, while the entry\u0026rsquo;s value remains randomized. Similarly, value() assigns a specified value to the map entry\u0026rsquo;s value, while the key becomes randomized. If you want to specify both the key and value at once, you can use entry().
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.key(1000)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.value(\u0026#34;ABC Store\u0026#34;)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.entry(1000, \u0026#34;ABC Store\u0026#34;)); val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.key(1000) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.value(\u0026#34;ABC Store\u0026#34;) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.entry(1000, \u0026#34;ABC Store\u0026#34;) } keys(), values(), entries() # When setting multiple entries within a map, you can use keys(), values(), and entries() to pass multiple values.
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.keys(1000, 1001, 1002)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.values(\u0026#34;ABC Store\u0026#34;, \u0026#34;123 Convenience\u0026#34;, \u0026#34;XYZ Mart\u0026#34;)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.entries(1000, \u0026#34;ABC Store\u0026#34;, 1001, \u0026#34;123 Convenience\u0026#34;, 1002, \u0026#34;XYZ Mart\u0026#34;)); val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.keys(1000, 1001, 1002) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.values(\u0026#34;ABC Store\u0026#34;, \u0026#34;123 Convenience\u0026#34;, \u0026#34;XYZ Mart\u0026#34;) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.entries(1000, \u0026#34;ABC Store\u0026#34;, 1001, \u0026#34;123 Convenience\u0026#34;, 1002, \u0026#34;XYZ Mart\u0026#34;) } allKey(), allValue(), allEntry() # Similar to allListElement(), it is possible to set every entry within the map to the specified value with allKey(), allValue(), and allEntry().
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.allKey(1000)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.allValue(\u0026#34;ABC Store\u0026#34;)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.allEntry(1000, \u0026#34;ABC Store\u0026#34;)); val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.allKey(1000) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.allValue(\u0026#34;ABC Store\u0026#34;) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.allEntry(1000, \u0026#34;ABC Store\u0026#34;) } keyLazy(), valueLazy(), entryLazy() # Similar to the setLazy() method in ArbitraryBuilder, you can pass a Supplier to assign the value. The Supplier will run every time the ArbitraryBuilder with the InnerSpec applied is sampled.
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.keyLazy(this::generateMerchantKey)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.valueLazy(this::generateMerchantValue)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.entryLazy(this::generateMerchantKey, this::generateMerchantValue)); val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.keyLazy(this::generateMerchantKey) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.valueLazy(this::generateMerchantValue) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.entryLazy(this::generateMerchantKey, this::generateMerchantValue) } allKeyLazy(), allValueLazy(), allEntryLazy() # Just as with the allKey() method, you can use allKeyLazy() to apply keyLazy() to every entry within the map. Both allValueLazy() and allEntryLazy() function similarly.
Java Kotlin InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.allKeyLazy(this::generateMerchantKey)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.allValueLazy(this::generateMerchantValue)); InnerSpec innerSpec = new InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;, merchantInfo -\u0026gt; merchantInfo.allEntryLazy(this::generateMerchantKey, this::generateMerchantValue)); val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.allKeyLazy(this::generateMerchantKey) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.allValueLazy(this::generateMerchantValue) } val innerSpec = InnerSpec() .property(\u0026#34;merchantInfo\u0026#34;) { it.allEntryLazy(this::generateMerchantKey, this::generateMerchantValue) } Customizing nested Maps # By combining methods within InnerSpec, you can effectively customize maps with map-type keys, map-type values, or both.
Consider the scenario of a nested map structure like the following:
public class Example { Map\u0026lt;Map\u0026lt;String, String\u0026gt;, String\u0026gt; mapByString; Map\u0026lt;String, Map\u0026lt;String, String\u0026gt;\u0026gt; stringByMap; } Setting map-type key # To set a map with a map-type key, you can access the map key using key(), and then further customize it.
general expression Kotlin Exp InnerSpec().property(\u0026#34;mapByString\u0026#34;, m -\u0026gt; m.key(k -\u0026gt; k.entry(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;))); InnerSpec().property(\u0026#34;mapByString\u0026#34;) { m -\u0026gt; m.key { k -\u0026gt; k.entry(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) } } If you need to set the entry itself, access the entry with entry() and further customize the key using InnerSpec, then set the specific value.
general expression Kotlin Exp InnerSpec().property(\u0026#34;mapByString\u0026#34;, m -\u0026gt; m.entry(k -\u0026gt; k.entry(\u0026#34;innerKey\u0026#34;, \u0026#34;innerValue\u0026#34;)), \u0026#34;value\u0026#34;) InnerSpec().property(\u0026#34;mapByString\u0026#34;) { m -\u0026gt; m.entry({ k -\u0026gt; k.entry(\u0026#34;innerKey\u0026#34;, \u0026#34;innerValue\u0026#34;) }, \u0026#34;value\u0026#34;) } Setting map-type value # For a map with a map-type value, access the map value using value(), and then further customize it.
general expression Kotlin Exp InnerSpec().property(\u0026#34;stringByMap\u0026#34;, m -\u0026gt; m.value(v -\u0026gt; v.entry(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;))) InnerSpec().property(\u0026#34;stringByMap\u0026#34;) { m -\u0026gt; m.value { v -\u0026gt; v.entry(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) } } If you need to set the entry itself, access the entry with entry() and further customize the value using InnerSpec, then set the specific key.
general expression Kotlin Exp InnerSpec().property(\u0026#34;stringByMap\u0026#34;, m -\u0026gt; m.entry(\u0026#34;key\u0026#34;, v -\u0026gt; v.entry(\u0026#34;innerKey\u0026#34;, \u0026#34;innerValue\u0026#34;))) InnerSpec().property(\u0026#34;stringByMap\u0026#34;) { m -\u0026gt; m.entry(\u0026#34;key\u0026#34;) {v -\u0026gt; v.entry(\u0026#34;innerKey\u0026#34;, \u0026#34;innerValue\u0026#34;)} } `}),e.add({id:26,href:"/v1-1-0/docs/fixture-monkey-options/",title:"Fixture Monkey Options",description:"",content:""}),e.add({id:27,href:"/v1-1-0/docs/plugins/simple-value-plugin/",title:"Simple Value Plugin",description:"",content:""}),e.add({id:28,href:"/v1-1-0/docs/fixture-monkey-options/concepts/",title:"Concepts",description:`Before you learn about the options Fixture Monkey provides, there are a few things you need to know.
Property # In the documentation, the term property is consistently used instead of field when referring to the characteristics of a class\u0026rsquo;s object. While it has the same name as \u0026lsquo;property\u0026rsquo; in Kotlin, the concept is different in Fixture Monkey.
Fixture Monkey\u0026rsquo;s initial structure was primarily based on fields, which imposed limitations on configuration and control through methods and other mechanisms.`,content:`Before you learn about the options Fixture Monkey provides, there are a few things you need to know.
Property # In the documentation, the term property is consistently used instead of field when referring to the characteristics of a class\u0026rsquo;s object. While it has the same name as \u0026lsquo;property\u0026rsquo; in Kotlin, the concept is different in Fixture Monkey.
Fixture Monkey\u0026rsquo;s initial structure was primarily based on fields, which imposed limitations on configuration and control through methods and other mechanisms. For example, when relying solely on fields, it\u0026rsquo;s not possible to access annotations on setter methods. To address this limitation, the Property interface was introduced, which extends support beyond just fields.
A property in Fixture Monkey, functions as a fundamental component within a class and can represent a Field, Method, or Kotlin Property. It contains information about its Type, Annotations on it, and its name.
Moreover, in Fixture Monkey, the characteristics of both Objects and Containers are also expressed through the concept of property.
ObjectProperty # An ObjectProperty is a property that represents immutable object information. It includes:
property: The property of the object itself. propertyNameResolver: Determines how the property name is resolved. elementIndex: If the object is an element of a Container, it indicates the index. public final class ObjectProperty { private final Property property; private final PropertyNameResolver propertyNameResolver; @Nullable private final Integer elementIndex; } ContainerProperty # The property of a container type is represented by ContainerProperty, which describes immutable container information. It includes:
elementProperties: A list of element properties. containerInfo: TheArbitraryContainerInfo that determines the container\u0026rsquo;s size. public final class ContainerProperty { private final List\u0026lt;Property\u0026gt; elementProperties; private final ArbitraryContainerInfo containerInfo; } Options # In Fixture Monkey, several options share common characteristics. For example, let\u0026rsquo;s take a look at the options related to modifying the ObjectPropertyGenerator
defaultObjectPropertyGenerator, pushObjectPropertyGenerator, pushAssignableTypeObjectPropertyGenerator, pushExactTypeObjectPropertyGenerator
Options with the prefix default are applied as defaults to all properties generated by Fixture Monkey. These defaults set a basic behavior that affects all property types uniformly.
However, if you need to apply specific options for a particular type, you can make use of the options that start with push. There are three variations of these push options.
push~ : Accepts a MatcherOperator as a parameter. pushAssignableType~: This option applies the specified setting to every property type for which the given type (associated with the option) is assignable. This means that the option is applied not only to the exact given type but also to any type that can be assigned to the property type, including superclasses or superinterfaces. pushExactType~: This option limits the setting to properties with the exact same type. It does not impact properties with subtype or supertype relationships. It\u0026rsquo;s important to note that options set using the push variants take precedence over the default options. This means that when a push option is defined for a specific type, it will override any corresponding default option for that type.
`}),e.add({id:29,href:"/v1-1-0/docs/plugins/simple-value-plugin/features/",title:"Features",description:`Fixture Monkey generates an arbitrary value to avoid edge case that could cause the problem. It may be useful in some situations, but it is useless in most situations. Especially it is embarrassing for beginners, who expect the readable and valid data.
Fixture Monkey provides a new Plugin SimpleValueJqwikPlugin for beginners, who expect the readable and valid value. It generates a readable and short String and narrow range of Number and Date value.`,content:`Fixture Monkey generates an arbitrary value to avoid edge case that could cause the problem. It may be useful in some situations, but it is useless in most situations. Especially it is embarrassing for beginners, who expect the readable and valid data.
Fixture Monkey provides a new Plugin SimpleValueJqwikPlugin for beginners, who expect the readable and valid value. It generates a readable and short String and narrow range of Number and Date value.
It is compatible with other plugins such as JavaxValidationPlugin, JakartaValidationPlugin. It applies XXValidationPlugin if the property has the validation annotation, applies SimpleValueJqwikPlugin without it.
If you use the custom Plugin to constrain the generated value, the latter plugin would work.
For beginners who want to restrict the generated value, looking at the code of SimpleValueJqwikPlugin is a good start.
Default value # String # The plugin generates a short size of limited String whose length is 0 to 5.
alphabet number some special symbols allowed in HTTP query parameter ., -, _, ~ It can be customised by the options below.
minStringLength maxStringLength characterPredicate Number # The plugin generates a numeric number and decimal number in the range -10000 to 10000.
It can be customised, whether negative or positive, using the options below.
minNumberValue maxNumberValue Date # The plugin generates a Date in the range of last year to next year from today.
It can be customised on a per date basis, using the options below.
minusDaysFromToday plusDaysFromToday Container # The term of Container refers to the implementations of Collection such as List, Set, Iterator Iterable, and Map, Entry. The plugin generates a Container whose size is in the range of 0 to 3.
It can be customised by the options below.
minContainerSize maxContainerSize Plugin # val fixtureMonkey = FixtureMonkey.builder() .plugin(SimpleValueJqwikPlugin()) .build() `}),e.add({id:30,href:"/v1-1-0/docs/fixture-monkey-options/generation-options/",title:"Generation Options",description:`To create a complex object that matches your desired configurations, Fixture Monkey provides a variety of options for creating objects.
These options are accessible through the FixtureMonkeyBuilder.
Implement your own Object Generator # ObjectIntrospector # objectIntrospector
An ObjectIntrospector determines how Fixture Monkey creates objects. The objectIntrospector option allows you to specify the default behavior when generating an object.
As discussed in the introspector section, you can use predefined introspectors provided by Fixture Monkey or create your own custom introspector.`,content:`To create a complex object that matches your desired configurations, Fixture Monkey provides a variety of options for creating objects.
These options are accessible through the FixtureMonkeyBuilder.
Implement your own Object Generator # ObjectIntrospector # objectIntrospector
An ObjectIntrospector determines how Fixture Monkey creates objects. The objectIntrospector option allows you to specify the default behavior when generating an object.
As discussed in the introspector section, you can use predefined introspectors provided by Fixture Monkey or create your own custom introspector.
ðŸ“– Notable implementations: 'BeanArbitraryIntrospector', 'BuilderArbitraryIntrospector' ArbitraryIntrospector # pushArbitraryIntrospector, pushAssignableTypeArbitraryIntrospector, pushExactTypeArbitraryIntrospector The ArbitraryIntrospector is responsible for defining how Fixture Monkey chooses the appropriate arbitrary generation strategy and generates an arbitrary. The object is then generated based on the generated arbitrary. You have the flexibility to create a custom introspector by implementing your own ArbitraryIntrospector.
If you need to change the ArbitraryIntrospector for a specific type, you can use the above options.
ðŸ“– Notable implementations: 'BooleanIntrospector', 'EnumIntrospector' ContainerIntrospector # pushContainerIntrospector
Especially for container types, you can change the ArbitraryIntrospector using the pushContainerIntrospector option.
ðŸ“– Notable implementations: 'ListIntrospector', 'MapIntrospector' ArbitraryGenerator # defaultArbitraryGenerator
Although the ArbitraryIntrospector determines the appropriate arbitrary generation strategy, the actual creation of the final arbitrary(CombinableArbitrary) is done by the ArbitraryGenerator. It handles the request by delegating to the ArbitraryIntrospector. By using the defaultArbitraryGenerator option, you have the capability to customize the behavior of the ArbitraryGenerator.
For instance, you can create an arbitrary generator that produces unique values, as shown in the example below:
Java Kotlin public static class UniqueArbitraryGenerator implements ArbitraryGenerator { private static final Set\u0026lt;Object\u0026gt; UNIQUE = new HashSet\u0026lt;\u0026gt;(); private final ArbitraryGenerator delegate; public UniqueArbitraryGenerator(ArbitraryGenerator delegate) { this.delegate = delegate; } @Override public CombinableArbitrary generate(ArbitraryGeneratorContext context) { return delegate.generate(context) .filter( obj -\u0026gt; { if (!UNIQUE.contains(obj)) { UNIQUE.add(obj); return true; } return false; } ); } } FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .defaultArbitraryGenerator(UniqueArbitraryGenerator::new) .build(); class UniqueArbitraryGenerator(private val delegate: ArbitraryGenerator) : ArbitraryGenerator { companion object { private val UNIQUE = HashSet\u0026lt;Any\u0026gt;() } override fun generate(context: ArbitraryGeneratorContext): CombinableArbitrary { return delegate.generate(context) .filter { obj -\u0026gt; if (!UNIQUE.contains(obj)) { UNIQUE.add(obj) true } else { false } } } } val fixtureMonkey = FixtureMonkey.builder() .defaultArbitraryGenerator { UniqueArbitraryGenerator(it) } .build() ðŸ“– Notable implementations: 'IntrospectedArbitraryGenerator', 'CompositeArbitraryGenerator' Implement your own Property # PropertyGenerator # defaultPropertyGenerator, pushPropertyGenerator, pushAssignableTypePropertyGenerator, pushExactTypePropertyGenerator
PropertyGenerator creates child properties of the given ObjectProperty. The child property can be a field, JavaBeans property, method or constructor parameter within the parent ObjectProperty. There are scenarios where you might want to customize how these child properties are generated.
The PropertyGenerator options allow you to specify how child properties of each type are generated. This option is mainly used when you want to exclude generating some properties when the parent property has abnormal child properties.
ðŸ“– Notable implementations: 'FieldPropertyGenerator', 'JavaBeansPropertyGenerator' ObjectPropertyGenerator # defaultObjectPropertyGenerator, pushObjectPropertyGenerator, pushAssignableTypeObjectPropertyGenerator, pushExactTypeObjectPropertyGenerator
ObjectPropertyGenerator generates the ObjectProperty based on a given context. With options related to ObjectPropertyGenerator you can customize how the ObjectProperty is generated.
ðŸ“– Notable implementations: 'DefaultObjectPropertyGenerator' ContainerPropertyGenerator # pushContainerPropertyGenerator, pushAssignableTypeContainerPropertyGenerator, pushExactTypeContainerPropertyGenerator
The ContainerPropertyGenerator determines how to generate ContainerProperty within a given context. With options related to ContainerPropertyGenerator you can customize how the ContainerProperty is generated.
ðŸ“– Notable implementations: 'ArrayContainerPropertyGenerator', 'MapContainerPropertyGenerator' Exclude Classes or Packages from Generation # pushExceptGenerateType, addExceptGenerateClass, addExceptGenerateClasses, addExceptGeneratePackage, addExceptGeneratePackages
If you want to exclude the generation of certain types or packages, you can use these options.
Java Kotlin @Test void testExcludeClass() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .addExceptGenerateClass(String.class) .build(); String actual = sut.giveMeOne(Product.class) .getProductName(); then(actual).isNull(); } @Test void testExcludePackage() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .addExceptGeneratePackage(\u0026#34;java.lang\u0026#34;) .build(); String actual = sut.giveMeOne(String.class); then(actual).isNull(); } @Test fun testExcludeClass() { val fixtureMonkey = FixtureMonkey.builder() .addExceptGenerateClass(String::class.java) .build() val actual = fixtureMonkey.giveMeOne\u0026lt;Product\u0026gt;() .productName then(actual).isNull() } @Test fun testExcludePackage() { val fixtureMonkey = FixtureMonkey.builder() .addExceptGeneratePackage(\u0026#34;java.lang\u0026#34;) .build() val actual = fixtureMonkey.giveMeOne\u0026lt;String\u0026gt;() then(actual).isNull() } Modify Containers # Container Size # defaultArbitraryContainerInfoGenerator, pushArbitraryContainerInfoGenerator
ArbitraryContainerInfo holds information about the minimum and maximum sizes of a Container type. You can change the behavior by modifying the ArbitraryContainerInfoGenerator using related options.
The following example demonstrates how to customize ArbitraryContainerInfo to set the size of all container types to 3.
Java Kotlin @Test void test() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .defaultArbitraryContainerInfoGenerator(context -\u0026gt; new ArbitraryContainerInfo(3, 3)) .build(); List\u0026lt;String\u0026gt; actual = fixtureMonkey.giveMeOne(); then(actual).hasSize(3); } @Test fun test() { val fixtureMonkey = FixtureMonkey.builder() .defaultArbitraryContainerInfoGenerator { context -\u0026gt; ArbitraryContainerInfo(3, 3) } .build() val actual: List\u0026lt;String\u0026gt; = fixtureMonkey.giveMeOne() then(actual).hasSize(3) } Adding Container type # addContainerType
You can add a new custom Container type using the addContainerType option.
Let\u0026rsquo;s say you made a new custom Pair class in Java.
You can use this container type by implementing a custom ContainerPropertyGenerator, Introspector and DecomposedContainerValueFactory.
FixtureMonkey fixtureMonkey=FixtureMonkey.builder() .addContainerType( Pair.class, new PairContainerPropertyGenerator(), new PairIntrospector(), new PairDecomposedContainerValueFactory() ) .build(); custom Introspector:
public class PairIntrospector implements ArbitraryIntrospector, Matcher { private static final Matcher MATCHER = new AssignableTypeMatcher(Pair.class); @Override public boolean match(Property property) { return MATCHER.match(property); } @Override public ArbitraryIntrospectorResult introspect(ArbitraryGeneratorContext context) { ArbitraryProperty property = context.getArbitraryProperty(); ArbitraryContainerInfo containerInfo = property.getContainerProperty().getContainerInfo(); if (containerInfo == null) { return ArbitraryIntrospectorResult.EMPTY; } List\u0026lt;Arbitrary\u0026lt;?\u0026gt;\u0026gt; childrenArbitraries = context.getChildrenArbitraryContexts().getArbitraries(); BuilderCombinator\u0026lt;List\u0026lt;Object\u0026gt;\u0026gt; builderCombinator = Builders.withBuilder(ArrayList::new); for (Arbitrary\u0026lt;?\u0026gt; childArbitrary : childrenArbitraries) { builderCombinator = builderCombinator.use(childArbitrary).in((list, element) -\u0026gt; { list.add(element); return list; }); } return new ArbitraryIntrospectorResult( builderCombinator.build(it -\u0026gt; new Pair\u0026lt;\u0026gt;(it.get(0), it.get(1))) ); } } custom ContainerPropertyGenerator:
public class PairContainerPropertyGenerator implements ContainerPropertyGenerator { @Override public ContainerProperty generate(ContainerPropertyGeneratorContext context) { com.navercorp.fixturemonkey.api.property.Property property = context.getProperty(); List\u0026lt;AnnotatedType\u0026gt; elementTypes = Types.getGenericsTypes(property.getAnnotatedType()); if (elementTypes.size() != 2) { throw new IllegalArgumentException( \u0026quot;Pair elementsTypes must be have 1 generics type for element. \u0026quot; + \u0026quot;propertyType: \u0026quot; + property.getType() + \u0026quot;, elementTypes: \u0026quot; + elementTypes ); } AnnotatedType firstElementType = elementTypes.get(0); AnnotatedType secondElementType = elementTypes.get(1); List\u0026lt;com.navercorp.fixturemonkey.api.property.Property\u0026gt; elementProperties = new ArrayList\u0026lt;\u0026gt;(); elementProperties.add( new ElementProperty( property, firstElementType, 0, 0 ) ); elementProperties.add( new ElementProperty( property, secondElementType, 1, 1 ) ); return new ContainerProperty( elementProperties, new ArbitraryContainerInfo(1, 1, false) ); } } custom DecomposedContainerValueFactory:
public class PairDecomposedContainerValueFactory implements DecomposedContainerValueFactory { @Override public DecomposedContainerValue from(Object object) { Pair\u0026lt;?, ?\u0026gt; pair = (Pair\u0026lt;?, ?\u0026gt;)obj; List\u0026lt;Object\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(pair.getFirst()); list.add(pair.getSecond()); return new DecomposableContainerValue(list, 2); } } Customize Arbitrary Validation # arbitraryValidator
The arbitraryValidator option allows you to replace the default arbitraryValidator with your own custom arbitrary validator.
When an instance is sampled, the arbitraryValidator validates the arbitrary, and if it is invalid, it throws an exception. This process is repeated 1,000 times, and if the instance is still invalid, a TooManyFilterMissesException would be thrown.
ðŸ“– Notable implementations: 'JakartaArbitraryValidator', 'JavaxArbitraryValidator' Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .arbitraryValidator(obj -\u0026gt; { throw new ValidationFailedException(\u0026#34;thrown by custom ArbitraryValidator\u0026#34;, new HashSet\u0026lt;\u0026gt;()); }) .build(); thenThrownBy(() -\u0026gt; fixtureMonkey.giveMeOne(String.class)) .isExactlyInstanceOf(FilterMissException.class); val fixtureMonkey = FixtureMonkey.builder() .arbitraryValidator { obj -\u0026gt; throw ValidationFailedException(\u0026#34;thrown by custom ArbitraryValidator\u0026#34;, HashSet()) } .build() assertThatThrownBy { fixtureMonkey.giveMeOne\u0026lt;String\u0026gt;() } .isExactlyInstanceOf(FilterMissException::class.java) Modify Arbitrary Generation Retry Limits # generateMaxTries, generateUniqueMaxTries
The generateMaxTries option allows you to control the maximum number of attempts to generate a valid object from an arbitrary. If an object cannot be generated successfully after exceeding this limit (default is 1,000 attempts), a TooManyFilterMissesException will be thrown.
Additionally, Fixture Monkey ensures the generation of unique values for map keys and set elements. The generateUniqueMaxTries option allows you to specify the maximum number of attempts (also defaults to 1,000) that will be made to generate this unique value.
Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .generateMaxTries(100) .generateUniqueMaxTries(100) .build(); val fixtureMonkey = FixtureMonkey.builder() .generateMaxTries(100) .generateUniqueMaxTries(100) .build() Implement Interfaces # ðŸ”” The following options are provided by InterfacePlugin interfaceImplements
interfaceImplements is an option used to specify the available implementations for an interface.
When you don\u0026rsquo;t specify this option, an ArbitraryBuilder for an interface will always result in a null value when sampled. However, when you do specify this option, Fixture Monkey will randomly generate one of the specified implementations whenever an ArbitraryBuilder for the interface is sampled.
Java Kotlin interface FixedValue { Object get(); } class IntegerFixedValue implements FixedValue { @Override public Object get() { return 1; } } class StringFixedValue implements FixedValue { @Override public Object get() { return \u0026#34;fixed\u0026#34;; } } class GenericFixedValue\u0026lt;T\u0026gt; { T value; } @Test void sampleGenericInterface() { // given List\u0026lt;Class\u0026lt;? extends FixedValue\u0026gt;\u0026gt; implementations = new ArrayList\u0026lt;\u0026gt;(); implementations.add(IntegerFixedValue.class); implementations.add(StringFixedValue.class); FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new InterfacePlugin().interfaceImplements(FixedValue.class, implementations)) .build(); // when Object actual = fixtureMonkey.giveMeBuilder(new TypeReference\u0026lt;GenericGetFixedValue\u0026lt;FixedValue\u0026gt;\u0026gt;() {}) .setNotNull(\u0026#34;value\u0026#34;) .sample() .getValue() .get(); // then then(actual).isIn(1, \u0026#34;fixed\u0026#34;); } interface FixedValue { fun get(): Any } class IntegerFixedValue : FixedValue { override fun get(): Any { return 1 } } class StringFixedValue : FixedValue { override fun get(): Any { return \u0026#34;fixed\u0026#34; } } class GenericFixedValue\u0026lt;T\u0026gt; { val value: T } @Test fun sampleGenericInterface() { // given val implementations: MutableList\u0026lt;Class\u0026lt;out FixedValue\u0026gt;\u0026gt; = List.of(IntegerFixedValue::class.java, StringFixedValue::class.java) val fixtureMonkey = FixtureMonkey.builder() .plugin(InterfacePlugin().interfaceImplements(FixedValue::class.java, implementations)) .build() // when val actual = fixtureMonkey.giveMeBuilder\u0026lt;GenericGetFixedValue\u0026lt;FixedValue\u0026gt;\u0026gt;() .sample() .getValue() .get() // then then(actual).isIn(1, \u0026#34;fixed\u0026#34;) } `}),e.add({id:31,href:"/v1-1-0/docs/fixture-monkey-options/customization-options/",title:"Customization Options",description:`Fixture Monkey also provides options through the FixtureMonkeyBuilder to customize objects to have the desired values or to use custom property names.
Change how property names are resolved # defaultPropertyNameResolver, pushPropertyNameResolver, pushAssignableTypePropertyNameResolver, pushExactTypePropertyNameResolver
Options related to the PropertyNameResolver allow you to customize how you refer to your properties.
The defaultPropertyNameResolver option is used to change the way property names are figured out for all types. If you want to make specific changes for certain types, you can use pushPropertyNameResolver, pushAssignableTypePropertyNameResolver, or pushExactTypePropertyNameResolver.`,content:`Fixture Monkey also provides options through the FixtureMonkeyBuilder to customize objects to have the desired values or to use custom property names.
Change how property names are resolved # defaultPropertyNameResolver, pushPropertyNameResolver, pushAssignableTypePropertyNameResolver, pushExactTypePropertyNameResolver
Options related to the PropertyNameResolver allow you to customize how you refer to your properties.
The defaultPropertyNameResolver option is used to change the way property names are figured out for all types. If you want to make specific changes for certain types, you can use pushPropertyNameResolver, pushAssignableTypePropertyNameResolver, or pushExactTypePropertyNameResolver.
By default, a property will be referenced by its original name. Let\u0026rsquo;s take a look at the following example to see how we can customize the property name:
Java Kotlin @Data // getter, setter public class Product { String productName; } @Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .pushPropertyNameResolver(MatcherOperator.exactTypeMatchOperator(String.class, (property) -\u0026gt; \u0026#34;string\u0026#34;)) .build(); String expected = \u0026#34;test\u0026#34;; // when String actual = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026#34;string\u0026#34;, expected) .sample() .getProductName(); // then then(actual).isEqualTo(expected); } data class Product ( val productName: String ) @Test fun test() { // given val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .pushPropertyNameResolver( MatcherOperator.exactTypeMatchOperator(String::class.java, PropertyNameResolver { \u0026#34;string\u0026#34; }) ) .build() val expected = \u0026#34;test\u0026#34; // when val actual: String = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .set(\u0026#34;string\u0026#34;, expected) .sample() .productName // then then(actual).isEqualTo(expected) } Normally, the property name will resolve to the original property name \u0026ldquo;productName\u0026rdquo;. However, with pushPropertyNameResolver the String type properties are now referred to by the name \u0026ldquo;string\u0026rdquo;.
Register a default ArbitraryBuilder for a given type # register, registerGroup, registerExactType, registerAssignableType
Sometimes your class may need to consistently match certain constraints. It can be inconvenient and result in lengthy code if you always have to modify the ArbitraryBuilder using customization APIs. In such cases, you can set a default ArbitraryBuilder for a class that will satisfy all the basic constraints.
The register option helps to register an ArbitraryBuilder for a specific type.
For example, the following code demonstrates how to register an ArbitraryBuilder for a Product class. By doing so, all Product instances created by FixtureMonkey will have an id value greater than or equal to \u0026ldquo;0\u0026rdquo;.
Java Kotlin FixtureMonkey.builder() .register( Product.class, fixture -\u0026gt; fixture.giveMeBuilder(Product.class) .set(\u0026#34;id\u0026#34;, Arbitraries.longs().greaterOrEqual(0)) ) .build(); FixtureMonkey.builder() .register(Product::class.java) { it.giveMeBuilder\u0026lt;Product\u0026gt;() .set(\u0026#34;id\u0026#34;, Arbitraries.longs().greaterOrEqual(0)) } .build() If you want to register several ArbitraryBuilders at once, you can use the registerGroup option. This can be done using either reflection or the ArbitraryBuilderGroup interface.
Using reflection: Java Kotlin public class GenerateGroup { public ArbitraryBuilder\u0026lt;GenerateString\u0026gt; generateString(FixtureMonkey fixtureMonkey) { return fixtureMonkey.giveMeBuilder(GenerateString.class) .set(\u0026#34;value\u0026#34;, Arbitraries.strings().numeric()); } public ArbitraryBuilder\u0026lt;GenerateInt\u0026gt; generateInt(FixtureMonkey fixtureMonkey) { return fixtureMonkey.giveMeBuilder(GenerateInt.class) .set(\u0026#34;value\u0026#34;, Arbitraries.integers().between(1, 100)); } } FixtureMonkey.builder() .registerGroup(GenerateGroup.class) .build(); class GenerateGroup { fun generateString(fixtureMonkey: FixtureMonkey): ArbitraryBuilder\u0026lt;GenerateString\u0026gt; { return fixtureMonkey.giveMeBuilder\u0026lt;GenerateString\u0026gt;() .set(\u0026#34;value\u0026#34;, Arbitraries.strings().numeric()) } fun generateInt(fixtureMonkey: FixtureMonkey): ArbitraryBuilder\u0026lt;GenerateInt\u0026gt; { return fixtureMonkey.giveMeBuilder\u0026lt;GenerateInt\u0026gt;() .set(\u0026#34;value\u0026#34;, Arbitraries.integers().between(1, 100)) } } FixtureMonkey.builder() .registerGroup(GenerateGroup::class.java) .build() Using ArbitraryBuilderGroup interface:
Java Kotlin public class GenerateBuilderGroup implements ArbitraryBuilderGroup { @Override public ArbitraryBuilderCandidateList generateCandidateList() { return ArbitraryBuilderCandidateList.create() .add( ArbitraryBuilderCandidateFactory.of(GenerateString.class) .builder( arbitraryBuilder -\u0026gt; arbitraryBuilder .set(\u0026#34;value\u0026#34;, Arbitraries.strings().numeric()) ) ) .add( ArbitraryBuilderCandidateFactory.of(GenerateInt.class) .builder( builder -\u0026gt; builder .set(\u0026#34;value\u0026#34;, Arbitraries.integers().between(1, 100)) ) ); } } FixtureMonkey.builder() .registerGroup(new GenerateBuilderGroup()) .build(); class GenerateBuilderGroup : ArbitraryBuilderGroup { override fun generateCandidateList(): ArbitraryBuilderCandidateList { return ArbitraryBuilderCandidateList.create() .add( ArbitraryBuilderCandidateFactory.of(GenerateString::class.java) .builder { it.set(\u0026#34;value\u0026#34;, Arbitraries.strings().numeric()) } ) .add( ArbitraryBuilderCandidateFactory.of(GenerateInt::class.java) .builder { it.set(\u0026#34;value\u0026#34;, Arbitraries.integers().between(1, 100)) } ) } } FixtureMonkey.builder() .registerGroup(GenerateBuilderGroup()) .build() Use expression strict mode # useExpressionStrictMode
When using expressions (especially String Expressions), it\u0026rsquo;s hard to know if the expression you\u0026rsquo;ve written has a matching property, and the property is correctly adjusted. Using the useExpressionStrictMode option will throw an IllegalArgumentException if the expression you wrote doesn\u0026rsquo;t have a matching property.
Java Kotlin @Test void test() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder().useExpressionStrictMode().build(); thenThrownBy( () -\u0026gt; fixtureMonkey.giveMeBuilder(String.class) .set(\u0026#34;nonExistentField\u0026#34;, 0) .sample() ).isExactlyInstanceOf(IllegalArgumentException.class) .hasMessageContaining(\u0026#34;No matching results for given NodeResolvers.\u0026#34;); } @Test fun test() { val fixtureMonkey = FixtureMonkey.builder().useExpressionStrictMode().build() assertThatThrownBy { fixtureMonkey.giveMeBuilder\u0026lt;String\u0026gt;() .set(\u0026#34;nonExistentField\u0026#34;, 0) .sample() }.isExactlyInstanceOf(IllegalArgumentException::class.java) .hasMessageContaining(\u0026#34;No matching results for given NodeResolvers.\u0026#34;) } Constrain Java types # javaTypeArbitraryGenerator, javaTimeTypeArbitraryGenerator
You can modify the default values for Java primitive types (such as strings, integers, doubles, etc.) by implementing a custom JavaTypeArbitraryGenerator interface. This option can be applied through the JqwikPlugin.
For example, by default, string types generated with Fixture Monkey have unreadable data because it considers edge cases such as when control blocks are contained in strings.
If you prefer to generate strings consisting only of alphabetic characters, you can override the JavaTypeArbitraryGenerator as demonstrated below:
Java Kotlin FixtureMonkey.builder() .plugin( new JqwikPlugin() .javaTypeArbitraryGenerator(new JavaTypeArbitraryGenerator() { @Override public StringArbitrary strings() { return Arbitraries.strings().alpha(); } }) ) .build(); FixtureMonkey.builder() .plugin( JqwikPlugin() .javaTypeArbitraryGenerator(object : JavaTypeArbitraryGenerator { override fun strings(): StringArbitrary = Arbitraries.strings().alpha() }) ) .build() For Java time types, you can use javaTimeTypeArbitraryGenerator.
Constrain Java types with annotations # javaArbitraryResolver, javaTimeArbitraryResolver
Similar to using the javax-validation plugin and adding constraints to your Java typed properties, you can apply constraints to Java types using annotations. To do this, you can implement a JavaArbitraryResolver interface. This option can be applied through the JqwikPlugin.
For example, if you have a custom annotation named MaxLengthOf10, which means that the length of a property should be limited to a maximum of 10 characters, you can create a JavaArbitraryResolver as shown below:
Java Kotlin FixtureMonkey.builder() .plugin( new JqwikPlugin() .javaArbitraryResolver(new JavaArbitraryResolver() { @Override public Arbitrary\u0026lt;String\u0026gt; strings(StringArbitrary stringArbitrary, ArbitraryGeneratorContext context) { if (context.findAnnotation(MaxLengthof10.class).isPresent()) { return stringArbitrary.ofMaxLength(10); } return stringArbitrary; } }) ) .build(); FixtureMonkey.builder() .plugin( JqwikPlugin() .javaArbitraryResolver(object : JavaArbitraryResolver { override fun strings(stringArbitrary: StringArbitrary, context: ArbitraryGeneratorContext): Arbitrary\u0026lt;String\u0026gt; { if (context.findAnnotation(MaxLengthof10::class.java).isPresent) { return stringArbitrary.ofMaxLength(10) } return stringArbitrary } }) ) .build() Change Nullability # defaultNotNull # defaultNotNull, nullableContainer, nullableElement
When you want to ensure that the properties of your instance are not null, you can utilize the options mentioned below.
defaultNotNull determines whether a null property is generated. If true, property cannot be null nullableContainer determines whether a container property can be null. If true, container can be null nullableElement determines whether an element within a container property can be null. If true, element can be null. By default, these three options are set to false. You can modify them to true as needed.
ðŸš¨ These options only apply to properties that do not have a nullable marker, such as @Nullable in Java or ? in Kotlin. Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder().defaultNotNull(true).build(); FixtureMonkey fixtureMonkey = FixtureMonkey.builder().nullableContainer(true).build(); FixtureMonkey fixtureMonkey = FixtureMonkey.builder().nullableElement(true).build(); val fixtureMonkey = FixtureMonkey.builder().defaultNotNull(true).build() val fixtureMonkey = FixtureMonkey.builder().nullableContainer(true).build() val fixtureMonkey = FixtureMonkey.builder().nullableElement(true).build() NullInjectGenerator # defaultNullInjectGenerator, pushNullInjectGenerator, pushExactTypeNullInjectGenerator, pushAssignableTypeNullInjectGenerator
In cases where a property should be null regardless of any nullable markers, you can make use of the options associated with the NullInjectGenerator.
The defaultnullInjectGenerator option allows you to set the probability of properties being null.
By default, the probability of a property being null is set to 20%.
If you want it to always be null, you can set it to 1.0d. There are predefined values available in the DefaultNullInjectGeneratorâ€”NOT_NULL_INJECT(0.0d) and ALWAYS_NULL_INJECT(1.0d)â€”which you can import and use.
Alternatively, for more customized behavior, you can implement your own NullInjectGenerator.
Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .defaultNullInjectGenerator((context) -\u0026gt; NOT_NULL_INJECT) // you can use NOT_NULL_INJECT or write your probability as 0.4 .build() val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .defaultNullInjectGenerator { NOT_NULL_INJECT } // you can use NOT_NULL_INJECT or write your probability as 0.4 .build() If you want to specifically change the probability of a certain type being null, you can use pushNullInjectGenerator.
Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .pushNullInjectGenerator(MatcherOperator.exactTypeMatchOperator(SimpleObject.class, (context) -\u0026gt; NOT_NULL_INJECT)) .build(); val fixtureMonkey = FixtureMonkey.builder() .pushNullInjectGenerator( exactTypeMatchOperator( Product::class.java, NullInjectGenerator { context -\u0026gt; NOT_NULL_INJECT } ) ) .build() Registering an ArbitraryBuilder of a specific class with register that has the .setNotNull(\u0026quot;*\u0026quot;) setting will have the same effect.
`}),e.add({id:32,href:"/v1-1-0/docs/fixture-monkey-options/other-options/",title:"Other Options",description:`This section explains some additional options that the FixtureMonkeyBuilder provide.
Add plugins # Fixture Monkey offers several additional features, including support for third-party libraries through plugins. You can use the plugin option to use these additional features.
For example, you can add the Jackson plugin as shown below. This will allow you to use Jackson features such as JacksonObjectArbitraryIntrospector and Jackson annotation support.
Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .`,content:`This section explains some additional options that the FixtureMonkeyBuilder provide.
Add plugins # Fixture Monkey offers several additional features, including support for third-party libraries through plugins. You can use the plugin option to use these additional features.
For example, you can add the Jackson plugin as shown below. This will allow you to use Jackson features such as JacksonObjectArbitraryIntrospector and Jackson annotation support.
Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .build(); val fixtureMonkey = FixtureMonkey.builder() .plugin(JacksonPlugin()) .build() `}),e.add({id:33,href:"/v1-1-0/docs/plugins/kotlin-plugin/",title:"Kotlin Plugin",description:"",content:""}),e.add({id:34,href:"/v1-1-0/docs/plugins/",title:"Plugins",description:"",content:""}),e.add({id:35,href:"/v1-1-0/docs/plugins/kotlin-plugin/features/",title:"Features",description:`To help you take full advantage of the concise, safe, and pragmatic nature of Kotlin, Fixture Monkey provides a Kotlin plugin.
Using PrimaryConstructorArbitraryIntrospector as the default introspector to generate Kotlin classes with its primary constructor. Fixture Monkey Extension Functions Kotlin DSL Exp, Kotlin instantiateBy DSL Dependencies # fixture-monkey-kotlin # Gradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-kotlin:1.1.11\u0026quot;) Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-kotlin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.11\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; fixture-monkey-starter-kotlin # To help you get started using Fixture Monkey in a Kotlin environment, there is also a starter dependency fixture-monkey-starter-kotlin that comes with pre-configured dependencies such as fixture-monkey-starter or fixture-monkey-jakarta-validation.`,content:`To help you take full advantage of the concise, safe, and pragmatic nature of Kotlin, Fixture Monkey provides a Kotlin plugin.
Using PrimaryConstructorArbitraryIntrospector as the default introspector to generate Kotlin classes with its primary constructor. Fixture Monkey Extension Functions Kotlin DSL Exp, Kotlin instantiateBy DSL Dependencies # fixture-monkey-kotlin # Gradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-kotlin:1.1.11\u0026quot;) Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-kotlin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.11\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; fixture-monkey-starter-kotlin # To help you get started using Fixture Monkey in a Kotlin environment, there is also a starter dependency fixture-monkey-starter-kotlin that comes with pre-configured dependencies such as fixture-monkey-starter or fixture-monkey-jakarta-validation.
Gradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-starter-kotlin:1.1.11\u0026quot;) Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-starter-kotlin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.11\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; Plugin # val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .build() `}),e.add({id:36,href:"/v1-1-0/docs/plugins/kotlin-plugin/introspectors-for-kotlin/",title:"Introspectors for Kotlin",description:`Fixture Monkey provides some additional introspectors that support the generation of Kotlin classes.
PrimaryConstructorArbitraryIntrospector # The PrimaryConstructorArbitraryIntrospector becomes the default introspector when the Kotlin plugin is added. It creates a Kotlin class with its primary constructor.
In the case of using PrimaryConstructorArbitraryIntrospector, it only contains the properties of the Kotlin constructor parameter.
If you use your own ArbitraryIntrospector instead of PrimaryConstructorArbitraryIntrospector, it will contain the properties of the Kotlin constructor parameter, Field, Getter.`,content:`Fixture Monkey provides some additional introspectors that support the generation of Kotlin classes.
PrimaryConstructorArbitraryIntrospector # The PrimaryConstructorArbitraryIntrospector becomes the default introspector when the Kotlin plugin is added. It creates a Kotlin class with its primary constructor.
In the case of using PrimaryConstructorArbitraryIntrospector, it only contains the properties of the Kotlin constructor parameter.
If you use your own ArbitraryIntrospector instead of PrimaryConstructorArbitraryIntrospector, it will contain the properties of the Kotlin constructor parameter, Field, Getter. So it contains the properties of the parent Field and Getter. You can customize the all properties by ArbitraryBuilder APIs.
For example, if you apply the JacksonPlugin after applying the KotlinPlugin, you can generate an instance of the Kotlin type by Jackson. In this case, you can customize the parent fields.
Example Kotlin Class :
data class Product ( val id: Long?, val productName: String, val price: Long, val options: List\u0026lt;String\u0026gt;, val createdAt: Instant ) Using PrimaryConstructorArbitraryIntrospector :
@Test fun test() { val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .build() val product: Product = fixtureMonkey.giveMeOne() } KotlinAndJavaCompositeArbitraryIntrospector # The KotlinAndJavaCompositeArbitraryIntrospector is an introspector designed to assist in the creation of Kotlin classes that reference Java classes.
Example Kotlin Class :
class KotlinClassWithJavaClass(val javaObject: JavaObject) Example Java Class :
public class JavaObject { private String value; private Map\u0026lt;String, String\u0026gt; map; public JavaObject() { } public String getValue() { return value; } public void setValue(String value) { this.value = value; } public Map\u0026lt;String, String\u0026gt; getMap() { return map; } public void setMap(Map\u0026lt;String, String\u0026gt; map) { this.map = map; } } Using PrimaryConstructorArbitraryIntrospector :
fun kotlinClassWithJavaClass() { // given val sut: FixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .objectIntrospector(KotlinAndJavaCompositeArbitraryIntrospector()) .build() // when val actual = sut.giveMeOne\u0026lt;KotlinClassWithJavaClass\u0026gt;() then(actual).isNotNull then(actual.javaObject).isNotNull } For Kotlin and Java classes respectively, it uses the PrimaryConstructorArbitraryIntrospector and the BeanArbitraryIntrospector by default.
If changes are desired, these can be injected as arguments.
// given val sut: FixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .objectIntrospector( KotlinAndJavaCompositeArbitraryIntrospector( kotlinArbitraryIntrospector = PrimaryConstructorArbitraryIntrospector.INSTANCE, javaArbitraryIntrospector = ConstructorPropertiesArbitraryIntrospector.INSTANCE ) ) .build() `}),e.add({id:37,href:"/v1-1-0/docs/plugins/kotlin-plugin/kotlin-exp/",title:"Kotlin DSL Exp",description:`Fixture Monkey utilizes Kotlin\u0026rsquo;s DSL feature to ensure type-safety with expressions. Let\u0026rsquo;s explore how we can employ Kotlin Exp instead of the standard Java String Expression.
Referencing a property # Suppose we have an object structure similar to the one described earlier, written in both Java and Kotlin:
@Value public class JavaClass { String field; List\u0026lt;String\u0026gt; list; Nested nestedObject; List\u0026lt;Nested\u0026gt; nestedObjectList; @Value public static class Nested { String nestedField; } } data class KotlinClass( val field: String, val list: List\u0026lt;String\u0026gt;, val nestedObject: Nested, val nestedObjectList: List\u0026lt;Nested\u0026gt; ) { data class Nested( val nestedField: String ) } To use Kotlin Exp to reference a property, you need to use the Exp or ExpGetter suffix to the normal Fixture Customization APIs.`,content:`Fixture Monkey utilizes Kotlin\u0026rsquo;s DSL feature to ensure type-safety with expressions. Let\u0026rsquo;s explore how we can employ Kotlin Exp instead of the standard Java String Expression.
Referencing a property # Suppose we have an object structure similar to the one described earlier, written in both Java and Kotlin:
@Value public class JavaClass { String field; List\u0026lt;String\u0026gt; list; Nested nestedObject; List\u0026lt;Nested\u0026gt; nestedObjectList; @Value public static class Nested { String nestedField; } } data class KotlinClass( val field: String, val list: List\u0026lt;String\u0026gt;, val nestedObject: Nested, val nestedObjectList: List\u0026lt;Nested\u0026gt; ) { data class Nested( val nestedField: String ) } To use Kotlin Exp to reference a property, you need to use the Exp or ExpGetter suffix to the normal Fixture Customization APIs.
Let\u0026rsquo;s look at the example of customizing properties with Kotlin Exp using setExp() and setExpGetter().
@Test fun test() { // given val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .plugin(JacksonPlugin()) .build() // when val javaClass = fixtureMonkey.giveMeBuilder\u0026lt;JavaClass\u0026gt;() .setExpGetter(JavaClass::getField, \u0026quot;field\u0026quot;) .sample() val kotlinClass = fixtureMonkey.giveMeBuilder\u0026lt;KotlinClass\u0026gt;() .setExp(KotlinClass::field, \u0026quot;field\u0026quot;) .sample() // then then(javaClass.field).isEqualTo(\u0026quot;field\u0026quot;) then(kotlinClass.field).isEqualTo(\u0026quot;field\u0026quot;) } In the code above, we can see that we are using Kotlin\u0026rsquo;s method reference to select a property.
setExp() takes an argument of type KProperty, while setExpGetter() takes an argument of type KFunction.
If the class is defined in Java, the expression (e.g. JavaClass::getField) is of type KFunction because it is a reference to a Java getter. Therefore you can only use the setExpGetter() method.
If it is a Kotlin class, the expression (e.g. KotlinClass::field) is KProperty, so you should use setExp().
Referencing a nested property # To access a nested field, the infix functions into and intoGetter are used. into takes a parameter of type KProperty, while intoGetter takes a parameter of type KFunction.
@Test fun test() { // given val fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .plugin(JacksonPlugin()) .build() // when val javaClass = fixtureMonkey.giveMeBuilder\u0026lt;JavaClass\u0026gt;() .setExp(JavaClass::getNestedObject intoGetter JavaClass.Nested::getNestedField, \u0026quot;nestedField\u0026quot;) .sample() val kotlinClass = fixtureMonkey.giveMeBuilder\u0026lt;KotlinClass\u0026gt;() .setExp(KotlinClass::nestedObject into KotlinClass.Nested::nestedField, \u0026quot;nestedField\u0026quot;) .sample() then(javaClass.nestedObject.nestedField).isEqualTo(\u0026quot;nestedField\u0026quot;) then(kotlinClass.nestedObject.nestedField).isEqualTo(\u0026quot;nestedField\u0026quot;) } An expression that contains an into or intoGetter operator becomes an ExpressionGenerator type in fixture monkey. Both setExp() and setExpGetter()) are defined to take ExpressionGenerator types as arguments, so you can use both.
Selecting Properties Using Kotlin DSL Expressions # Selecting the root object: # Currently Not Supported Selecting a specific field: # JavaClass::getField // java class KotlinClass::field // kotlin class Selecting a nested field: # JavaClass::getNestedObject intoGetter JavaClass.Nested::getNestedField // java class KotlinClass::nestedObject into KotlinClass.Nested::nestedField // kotlin class Selecting the n-th element of a collection: # JavaClass::getNestedObjectList[\u0026quot;0\u0026quot;] // java class KotlinClass::nestedObjectList[\u0026quot;0\u0026quot;] // kotlin class Selecting all elements of a collection: # JavaClass::getNestedObjectList[\u0026quot;*\u0026quot;] // java class KotlinClass::nestedObjectList[\u0026quot;*\u0026quot;] // kotlin class Combining expressions to select a nested field: # JavaClass::getNestedObject intoGetter JavaClass.Nested::getNestedField // java class KotlinClass::nestedObject into KotlinClass.Nested::nestedField // kotlin class `}),e.add({id:38,href:"/v1-1-0/docs/plugins/jackson-plugin/",title:"Jackson Plugin",description:"",content:""}),e.add({id:39,href:"/v1-1-0/docs/plugins/jackson-plugin/features/",title:"Features",description:`Fixture monkey supports Jackson with the Fixture Monkey Jackson plugin.
Supports the use of JacksonObjectArbitraryIntrospector as the default introspector to create objects using the Jackson object mapper. Supports Jackson Annotations such as, @JsonIgnore, @JsonProperty Dependencies # Gradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-jackson:1.1.11\u0026quot;) Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-jackson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.11\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; Plugin # Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .build(); val fixtureMonkey = FixtureMonkey.builder() .plugin(JacksonPlugin()) .build() Pass the object mapper to the JacksonPlugin constructor if you are using Jackson with a custom object mapper.`,content:`Fixture monkey supports Jackson with the Fixture Monkey Jackson plugin.
Supports the use of JacksonObjectArbitraryIntrospector as the default introspector to create objects using the Jackson object mapper. Supports Jackson Annotations such as, @JsonIgnore, @JsonProperty Dependencies # Gradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-jackson:1.1.11\u0026quot;) Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-jackson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.11\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; Plugin # Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .build(); val fixtureMonkey = FixtureMonkey.builder() .plugin(JacksonPlugin()) .build() Pass the object mapper to the JacksonPlugin constructor if you are using Jackson with a custom object mapper.
Java Kotlin ObjectMapper objectMapper = JsonMapper.builder() .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES) .build() FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin(objectMapper)) .build(); val objectMapper = JsonMapper.builder() .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES) .build() val fixtureMonkey = FixtureMonkey.builder() .plugin(JacksonPlugin(objectMapper)) .build() `}),e.add({id:40,href:"/v1-1-0/docs/plugins/jackson-plugin/jackson-object-arbitrary-introspector/",title:"JacksonObjectArbitraryIntrospector",description:`JacksonObjectArbitraryIntrospector # The JacksonObjectArbitraryIntrospector becomes the default introspector when the Jackson plugin is added. It puts the created properties of the given class into a map and deserializes them using Jackson\u0026rsquo;s object mapper.
Example Java Class :
@Value public class Product { long id; String productName; long price; List\u0026lt;String\u0026gt; options; Instant createdAt; } Using JacksonObjectArbitraryIntrospector : Java Kotlin @Test void test() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .build(); Product product = fixtureMonkey.`,content:`JacksonObjectArbitraryIntrospector # The JacksonObjectArbitraryIntrospector becomes the default introspector when the Jackson plugin is added. It puts the created properties of the given class into a map and deserializes them using Jackson\u0026rsquo;s object mapper.
Example Java Class :
@Value public class Product { long id; String productName; long price; List\u0026lt;String\u0026gt; options; Instant createdAt; } Using JacksonObjectArbitraryIntrospector : Java Kotlin @Test void test() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .build(); Product product = fixtureMonkey.giveMeOne(Product.class); } testImplementation(\u0026#34;com.navercorp.fixturemonkey:fixture-monkey-starter-kotlin:1.1.11\u0026#34;) testImplementation(\u0026#34;com.fasterxml.jackson.module:jackson-module-kotlin\u0026#34;) @Test fun test() { FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(KotlinPlugin()) .plugin(JacksonPlugin()) .build(); val product: Product = fixtureMonkey.giveMeOne() } ðŸ’¡ To generate Kotlin classes with JacksonObjectArbitraryIntrospector, both Kotlin plugin and Jackson plugin need to be added. In addition, fasterxml jackson-module-kotlin should be added to the dependency for serialization/deserialization of Kotlin classes. It has the advantage of being a general purpose introspector because it relies on the widely used Jackson for object creation. If your production code has both Kotlin and Java classes, it is recommended to use JacksonObjectArbitraryIntrospector.
However, it does have the disadvantage of potentially not performing as efficiently as other introspectors, as deserialization with Jackson can be more time-consuming.
`}),e.add({id:41,href:"/v1-1-0/docs/plugins/jackson-plugin/jackson-annotations/",title:"Jackson Annotations",description:`With the Jackson plugin, some Jackson annotations are also supported.
@JsonProperty, @JsonIgnore # We can use the property name specified by @JsonProperty when using the String Expression to customize this property.
The property with @JsonIgnore will have a null value when Fixture Monkey generates the object.
The following example shows how @JsonProperty, @JsonIgnore works with Fixture Monkey.
Example Java Class :
@Value // lombok getter, setter public class Product { long id; @JsonProperty(\u0026quot;name\u0026quot;) String productName; long price; @JsonIgnore List\u0026lt;String\u0026gt; options; Instant createdAt; } Java Kotlin @Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.`,content:`With the Jackson plugin, some Jackson annotations are also supported.
@JsonProperty, @JsonIgnore # We can use the property name specified by @JsonProperty when using the String Expression to customize this property.
The property with @JsonIgnore will have a null value when Fixture Monkey generates the object.
The following example shows how @JsonProperty, @JsonIgnore works with Fixture Monkey.
Example Java Class :
@Value // lombok getter, setter public class Product { long id; @JsonProperty(\u0026quot;name\u0026quot;) String productName; long price; @JsonIgnore List\u0026lt;String\u0026gt; options; Instant createdAt; } Java Kotlin @Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JacksonPlugin()) .build(); // when Product actual = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026#34;name\u0026#34;, \u0026#34;book\u0026#34;) .sample(); // then then(actual.getProductName()).isEqualTo(\u0026#34;book\u0026#34;); // @JsonProperty then(actual.getOptions()).isNull(); // @JsonIgnore } @Test fun test() { // given val fixtureMonkey = FixtureMonkey.builder() .plugin(JacksonPlugin()) .build() // when val actual = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .set(\u0026#34;name\u0026#34;, \u0026#34;book\u0026#34;) .sample() // then then(actual.productName).isEqualTo(\u0026#34;book\u0026#34;) // @JsonProperty then(actual.options).isNull() // @JsonIgnore } @JsonTypeInfo, @JsonSubTypes # Fixture Monkey also supports Jackson\u0026rsquo;s polymorphic type handling annotations @JsonTypeInfo and @JsonSubTypes.
We can generate an inheritance-implementation relationship object with the help of FixtureMonkey.
`}),e.add({id:42,href:"/v1-1-0/docs/plugins/jakarta-validation-plugin/",title:"Jakarta Validation Plugin",description:"",content:""}),e.add({id:43,href:"/v1-1-0/docs/plugins/jakarta-validation-plugin/features/",title:"Features",description:`Fixture monkey supports generating valid data based on Jakarta Bean Validation 3.0 annotations with the Fixture Monkey Jakarta Validation Plugin.
ðŸ’¡ Javax Bean Validation is also supported with the Fixture Monkey Javax Validation Plugin Dependencies # Gradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-jakarta-validation:1.1.11\u0026quot;) Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-jakarta-validation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.11\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; The jakarta validation API and the Hibernate validator are already provided as part of the dependency.
Plugin # Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.`,content:`Fixture monkey supports generating valid data based on Jakarta Bean Validation 3.0 annotations with the Fixture Monkey Jakarta Validation Plugin.
ðŸ’¡ Javax Bean Validation is also supported with the Fixture Monkey Javax Validation Plugin Dependencies # Gradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-jakarta-validation:1.1.11\u0026quot;) Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-jakarta-validation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.11\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; The jakarta validation API and the Hibernate validator are already provided as part of the dependency.
Plugin # Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .plugin(new JakartaValidationPlugin()) .build(); val fixtureMonkey = FixtureMonkey.builder() .plugin(JakartaValidationPlugin()) .build() `}),e.add({id:44,href:"/v1-1-0/docs/plugins/jakarta-validation-plugin/bean-validation/",title:"Bean Validation",description:`Generating valid data # Using the Jakarta Validation plugin, we can generate valid data based on Jakarta Bean validation annotations on properties.
For example, there can be a Product class annotated as follows:
@Value public class Product { @Min(1) long id; @NotBlank String productName; @Max(100000) long price; @Size(min = 3) List\u0026lt;@NotBlank String\u0026gt; options; @Past Instant createdAt; } An instance of the Product class that is compliant with the annotations can be created in the following manner:`,content:`Generating valid data # Using the Jakarta Validation plugin, we can generate valid data based on Jakarta Bean validation annotations on properties.
For example, there can be a Product class annotated as follows:
@Value public class Product { @Min(1) long id; @NotBlank String productName; @Max(100000) long price; @Size(min = 3) List\u0026lt;@NotBlank String\u0026gt; options; @Past Instant createdAt; } An instance of the Product class that is compliant with the annotations can be created in the following manner:
@Test void test() { // given FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE) .plugin(new JakartaValidationPlugin()) .build(); // when Product actual = fixtureMonkey.giveMeOne(Product.class); // then then(actual).isNotNull(); then(actual.getId()).isGreaterThan(0); then(actual.getProductName()).isNotBlank(); then(actual.getPrice()).isLessThanOrEqualTo(100000); then(actual.getOptions().size()).isGreaterThanOrEqualTo(3); then(actual.getOptions()).allSatisfy(it -\u0026gt; then(it).isNotEmpty()); then(actual.getCreatedAt()).isNotNull().isLessThanOrEqualTo(Instant.now()); } Supported Annotations # Every annotation from the jakarta.validation.constraints package is supported. Different types support different annotation constraints.
Numeric Type # Supported Types: BigDecimal, BigInteger, byte, double, float, int, long, short
@Digits (fraction is currently not supported) @Max @Min @Negative @NegativeOrZero @DecimalMax @DecimalMin @Positive @PositiveOrZero Boolean Type # @AssertFalse @AssertTrue String Type # @Null @NotNull @NotBlank @NotEmpty @Size @Digits @Pattern @Email Time Type # Supported Types: Calendar, Date, Instant, LocalDate, LocalDateTime, LocalTime, ZonedDateTime, Year, YearMonth, MonthDay, OffsetDateTime, OffsetTime
@Past @PastOrPresent @Future @FutureOrPresent Container Type # @Size @NotEmpty `}),e.add({id:45,href:"/v1-1-0/docs/intellij-plugin/",title:"Intellij Plugin",description:"",content:""}),e.add({id:46,href:"/v1-1-0/docs/plugins/kotest-plugin/",title:"Kotest Plugin",description:"",content:""}),e.add({id:47,href:"/v1-1-0/docs/plugins/kotest-plugin/features/",title:"Features",description:`The Kotest plugin provided by Fixture Monkey allows you to enhance your testing experience within the Kotest framework.
Replaces the default generator for generating random values for primitive types from Jqwik to Kotest\u0026rsquo;s property generator (Arb). Use of bean validation annotations also works. Support for Kotest\u0026rsquo;s property-based testing functions, including forAll and checkAll. ðŸ’¡ Adding the Kotest Plugin doesn't mean you have to use Kotest as your testing framework. You can still use Junit.`,content:`The Kotest plugin provided by Fixture Monkey allows you to enhance your testing experience within the Kotest framework.
Replaces the default generator for generating random values for primitive types from Jqwik to Kotest\u0026rsquo;s property generator (Arb). Use of bean validation annotations also works. Support for Kotest\u0026rsquo;s property-based testing functions, including forAll and checkAll. ðŸ’¡ Adding the Kotest Plugin doesn't mean you have to use Kotest as your testing framework. You can still use Junit. Dependencies # fixture-monkey-kotlin # Gradle # testImplementation(\u0026quot;com.navercorp.fixturemonkey:fixture-monkey-kotest:1.1.11\u0026quot;) Maven # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey-kotest\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.11\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; Plugin # val fixtureMonkey = FixtureMonkey.builder() .plugin(KotestPlugin()) .plugin(KotlinPlugin()) .build() `}),e.add({id:48,href:"/v1-1-0/docs/intellij-plugin/fixture-monkey-helper/",title:"Fixture Monkey Helper",description:`Fixture Monkey Helper is an IntelliJ plugin that helps to use Fixture Monkey on the IntelliJ IDE.
It provides some features that make using String Expressions and Kotlin DSL Expressions easier, and also add some IntelliJ inspections to detect and fix abnormal code.
ðŸš¨ This plugin currently operates only within Java source code and Kotlin test code. Plans for expansion are in progress. Features # Fixture Monkey Expression support
Seamless Conversion: Transform string expressions into the Kotlin DSL provided by Fixture Monkey for ArbitraryBuilder.`,content:`Fixture Monkey Helper is an IntelliJ plugin that helps to use Fixture Monkey on the IntelliJ IDE.
It provides some features that make using String Expressions and Kotlin DSL Expressions easier, and also add some IntelliJ inspections to detect and fix abnormal code.
ðŸš¨ This plugin currently operates only within Java source code and Kotlin test code. Plans for expansion are in progress. Features # Fixture Monkey Expression support
Seamless Conversion: Transform string expressions into the Kotlin DSL provided by Fixture Monkey for ArbitraryBuilder. Expression Validation: Ensure the accuracy of your string expressions before execution. Intuitive Auto-Completion: Speed up your coding with smart suggestions as you type. Easy Navigation: Jump directly to field references within your codebase. FixtureMonkey Kotlin DSL Enhancements
Bidirectional Transformation: Switch between Kotlin DSL and Fixture Monkey string expressions effortlessly. Support for on-the-fly bidirectional Transformation (Beta) Code Folding: Simplify your view by collapsing DSL expressions into a single line. Lambda Expression Generator: Craft fixture specifications with ease using generated lambda expressions. Lambda to DSL Conversion: Convert complex lambda expressions into readable and maintainable Fixture Monkey Kotlin DSL. Inspection
Change type information passed as method arguments in Fixture Monkey factory methods to generic type arguments Change generic type arguments to variable types in Fixture Monkey factory methods when possible Fixture Monkey Property Overview Tool Window (Alpha)
This tool window allows you to view all properties registered with ArbitraryBuilder at a glance, presented in a tree format. `}),e.add({id:49,href:"/v1-1-0/docs/plugins/kotest-plugin/property-based-testing/",title:"Kotest Property Based Testing",description:`Fixture Monkey\u0026rsquo;s Kotest plugin introduces two primary features that enhance property-based testing within the Kotest framework: forAll and checkAll.
The KotestPlugin and KotlinPlugin should be added to enable this feature.
val fixtureMonkey: FixtureMonkey = FixtureMonkey.builder() .plugin(KotestPlugin()) .plugin(KotlinPlugin()) .build() ForAll # Kotest provides a forAll function that accepts an n-arity function (a, ..., n) -\u0026gt; Boolean to test a property. The test passes if, for all input values, the function returns true.`,content:`Fixture Monkey\u0026rsquo;s Kotest plugin introduces two primary features that enhance property-based testing within the Kotest framework: forAll and checkAll.
The KotestPlugin and KotlinPlugin should be added to enable this feature.
val fixtureMonkey: FixtureMonkey = FixtureMonkey.builder() .plugin(KotestPlugin()) .plugin(KotlinPlugin()) .build() ForAll # Kotest provides a forAll function that accepts an n-arity function (a, ..., n) -\u0026gt; Boolean to test a property. The test passes if, for all input values, the function returns true.
This function accepts type parameters for the argument types, which Kotest uses to locate a generator that provides random values of a suitable type.
class PropertyExample: StringSpec({ \u0026quot;String size\u0026quot; { forAll\u0026lt;String, String\u0026gt; { a, b -\u0026gt; (a + b).length == a.length + b.length } } }) For cases when a custom generator is needed, it\u0026rsquo;s possible to specify generators (called Arb in Kotest). However, only generators of limited types are provided with kotest, and it is hard to customize.
Fixture Monkey offers a way to generate Arb for custom types using the giveMeArb() function. You can further customize the generator using Fixture Monkey\u0026rsquo;s customization APIs.
Here\u0026rsquo;s an example of performing property-based testing with forAll using Fixture Monkey:
class KotestInKotestTest : StringSpec({ \u0026quot;forAll\u0026quot; { forAll(fixtureMonkey.giveMeArb\u0026lt;StringObject\u0026gt; { it.set(\u0026quot;value\u0026quot;, \u0026quot;test\u0026quot;) }) { a -\u0026gt; a.value == \u0026quot;test\u0026quot; } } }) { data class StringObject(val value: String) } CheckAll # Fixture Monkey also provides the extension function checkAll similar to Kotest\u0026rsquo;s checkAll.
Primitive Type Input # With checkAll, you can test assertions against primitive data types, as shown in the example below:
class Test : StringSpec({ \u0026quot;checkAll\u0026quot; { SUT.checkAll { string: String, int: Int -\u0026gt; string shouldNotBeSameInstanceAs int string shouldBe string } } }) Custom Type Input # Fixture Monkey\u0026rsquo;s checkAll extension function goes beyond primitive types. You can also use custom types as input data, generated with Fixture Monkey.
class Test : StringSpec({ \u0026quot;checkAllObject\u0026quot; { SUT.checkAll { stringObject: StringObject -\u0026gt; stringObject.value shouldNotBe null } } }) { data class StringObject(val value: String) } ArbitraryBuilder Input # Additionally, you can work with ArbitraryBuilder instances and further customize them to execute assertions.
class Test : StringSpec({ \u0026quot;checkAllArbitraryBuilder\u0026quot; { SUT.checkAll { string: ArbitraryBuilder\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; -\u0026gt; string .size(\u0026quot;$\u0026quot;, 3) .sample() shouldHaveSize 3 } } }) { data class StringObject(val value: String) } `}),e.add({id:50,href:"/v1-1-0/docs/cheat-sheet/best-practices/",title:"Best Practices",description:`This guide provides practical tips and best practices for using Fixture Monkey effectively in your tests.
1. Keep Tests Simple and Focused # Only customize what matters for the test: Don\u0026rsquo;t set values for fields that don\u0026rsquo;t affect the test\u0026rsquo;s behavior. Java Kotlin // Good - only set what\u0026#39;s relevant to the test @Test void shouldCalculateDiscount() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026#34;price\u0026#34;, 100.0) // Only price matters for discount calculation .`,content:`This guide provides practical tips and best practices for using Fixture Monkey effectively in your tests.
1. Keep Tests Simple and Focused # Only customize what matters for the test: Don\u0026rsquo;t set values for fields that don\u0026rsquo;t affect the test\u0026rsquo;s behavior. Java Kotlin // Good - only set what\u0026#39;s relevant to the test @Test void shouldCalculateDiscount() { Product product = fixtureMonkey.giveMeBuilder(Product.class) .set(\u0026#34;price\u0026#34;, 100.0) // Only price matters for discount calculation .sample(); double discount = productService.calculateDiscount(product); assertThat(discount).isEqualTo(10.0); } // Good - only set what\u0026#39;s relevant to the test @Test fun shouldCalculateDiscount() { val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setExpGetter(Product::getPrice, 100.0) // Only price matters for discount calculation .sample() val discount = productService.calculateDiscount(product) assertThat(discount).isEqualTo(10.0) } 2. Prefer Direct Property Setting Over Post-Conditions # Use direct property setting when possible: Instead of using setPostCondition which can cause performance issues due to rejection sampling, prefer direct configuration with set or size. Java Kotlin // Less efficient - uses post-conditions with rejection sampling @Test void lessEfficientOrderTest() { Order order = fixtureMonkey.giveMeBuilder(Order.class) .setPostCondition(o -\u0026gt; o.getItems().size() \u0026gt; 0) // Performance cost: may reject many samples .setPostCondition(o -\u0026gt; o.getTotalAmount() \u0026gt; 100) // Additional performance cost .sample(); OrderResult result = orderService.process(order); assertThat(result.isSuccessful()).isTrue(); } // More efficient - uses direct property setting @Test void moreEfficientOrderTest() { Order order = fixtureMonkey.giveMeBuilder(Order.class) .size(\u0026#34;items\u0026#34;, 1, 5) // Directly set collection size .set(\u0026#34;totalAmount\u0026#34;, Arbitraries.integers().greaterThan(100)) // Directly set valid range .sample(); OrderResult result = orderService.process(order); assertThat(result.isSuccessful()).isTrue(); } // When to use setPostCondition - for truly complex validation that cannot be expressed with property setting @Test void complexValidationTest() { // Only use setPostCondition for complex validations that cannot be expressed otherwise Invoice invoice = fixtureMonkey.giveMeBuilder(Invoice.class) .set(\u0026#34;items\u0026#34;, fixtureMonkey.giveMe(InvoiceItem.class, 3)) .set(\u0026#34;customerType\u0026#34;, CustomerType.BUSINESS) .setPostCondition(inv -\u0026gt; inv.calculateTotal().compareTo(inv.getItems().stream() .map(InvoiceItem::getAmount).reduce(BigDecimal.ZERO, BigDecimal::add)) == 0) .sample(); assertThat(invoiceService.validate(invoice)).isTrue(); } // Less efficient - uses post-conditions with rejection sampling @Test fun lessEfficientOrderTest() { val order = fixtureMonkey.giveMeBuilder\u0026lt;Order\u0026gt;() .setPostCondition { it.items.isNotEmpty() } // Performance cost: may reject many samples .setPostCondition { it.totalAmount \u0026gt; 100 } // Additional performance cost .sample() val result = orderService.process(order) assertThat(result.isSuccessful).isTrue() } // More efficient - uses direct property setting @Test fun moreEfficientOrderTest() { val order = fixtureMonkey.giveMeBuilder\u0026lt;Order\u0026gt;() .setExpSize(Order::getItems, 1, 5) // Directly set collection size .setExpGetter(Order::getTotalAmount, Arbitraries.integers().greaterThan(100)) // Directly set valid range .sample() val result = orderService.process(order) assertThat(result.isSuccessful).isTrue() } // When to use setPostCondition - for truly complex validation that cannot be expressed with property setting @Test fun complexValidationTest() { // Only use setPostCondition for complex validations that cannot be expressed otherwise val invoice = fixtureMonkey.giveMeBuilder\u0026lt;Invoice\u0026gt;() .setExpGetter(Invoice::getItems, fixtureMonkey.giveMe\u0026lt;InvoiceItem\u0026gt;(3)) .setExpGetter(Invoice::getCustomerType, CustomerType.BUSINESS) .setPostCondition { inv -\u0026gt; inv.calculateTotal() == inv.items.map { it.amount }.fold(BigDecimal.ZERO, BigDecimal::add) } .sample() assertThat(invoiceService.validate(invoice)).isTrue() } 3. Avoid Over-Specification in Tests # Don\u0026rsquo;t overspecify test requirements: Test only what needs to be tested. Java Kotlin // Bad - overspecified test with unnecessary details @Test void badTestTooManyDetails() { User user = fixtureMonkey.giveMeBuilder(User.class) .set(\u0026#34;id\u0026#34;, 1L) .set(\u0026#34;name\u0026#34;, \u0026#34;John\u0026#34;) .set(\u0026#34;email\u0026#34;, \u0026#34;john@example.com\u0026#34;) .set(\u0026#34;address.street\u0026#34;, \u0026#34;123 Main St\u0026#34;) .set(\u0026#34;address.city\u0026#34;, \u0026#34;New York\u0026#34;) .set(\u0026#34;address.zipCode\u0026#34;, \u0026#34;10001\u0026#34;) .set(\u0026#34;registrationDate\u0026#34;, LocalDate.of(2023, 1, 1)) .sample(); // Test is just checking if email is valid assertThat(userValidator.isEmailValid(user)).isTrue(); } // Good - only specify what\u0026#39;s needed for the test @Test void goodTestOnlyNeededDetails() { User user = fixtureMonkey.giveMeBuilder(User.class) .set(\u0026#34;email\u0026#34;, \u0026#34;john@example.com\u0026#34;) // Only email matters for this test .sample(); assertThat(userValidator.isEmailValid(user)).isTrue(); } // Bad - overspecified test with unnecessary details @Test fun badTestTooManyDetails() { val user = fixtureMonkey.giveMeBuilder\u0026lt;User\u0026gt;() .setExpGetter(User::getId, 1L) .setExpGetter(User::getName, \u0026#34;John\u0026#34;) .setExpGetter(User::getEmail, \u0026#34;john@example.com\u0026#34;) .setExpGetter(User::getAddress, { address -\u0026gt; address.setExpGetter(Address::getStreet, \u0026#34;123 Main St\u0026#34;) .setExpGetter(Address::getCity, \u0026#34;New York\u0026#34;) .setExpGetter(Address::getZipCode, \u0026#34;10001\u0026#34;) }) .setExpGetter(User::getRegistrationDate, LocalDate.of(2023, 1, 1)) .sample() // Test is just checking if email is valid assertThat(userValidator.isEmailValid(user)).isTrue() } // Good - only specify what\u0026#39;s needed for the test @Test fun goodTestOnlyNeededDetails() { val user = fixtureMonkey.giveMeBuilder\u0026lt;User\u0026gt;() .setExpGetter(User::getEmail, \u0026#34;john@example.com\u0026#34;) // Only email matters for this test .sample() assertThat(userValidator.isEmailValid(user)).isTrue() } 4. Make Tests Readable with Helper Methods # Create helper methods to improve test readability: Encapsulate fixture setup for better readability. Java Kotlin @Test void testOrderProcessing() { // Helper methods returning ArbitraryBuilder for more flexibility Order standardOrder = standardOrderBuilder() .set(\u0026#34;customerNote\u0026#34;, \u0026#34;Please deliver quickly\u0026#34;) // Test-specific customization .sample(); Customer premiumCustomer = premiumCustomerBuilder() .set(\u0026#34;membershipYears\u0026#34;, 5) // Test-specific customization .sample(); OrderResult result = orderService.process(standardOrder, premiumCustomer); assertThat(result.hasDiscount()).isTrue(); assertThat(result.getDiscount()).isGreaterThanOrEqualTo(standardOrder.getTotalAmount() * 0.1); } // Helper methods return ArbitraryBuilder instead of instances private ArbitraryBuilder\u0026lt;Order\u0026gt; standardOrderBuilder() { return fixtureMonkey.giveMeBuilder(Order.class) .size(\u0026#34;items\u0026#34;, 3, 5) .set(\u0026#34;totalAmount\u0026#34;, Arbitraries.integers().between(100, 500)); } private ArbitraryBuilder\u0026lt;Customer\u0026gt; premiumCustomerBuilder() { return fixtureMonkey.giveMeBuilder(Customer.class) .set(\u0026#34;premiumMember\u0026#34;, true) .set(\u0026#34;membershipYears\u0026#34;, 2); } @Test void testOrderWithSpecialDiscount() { // Reuse the same builder with different customizations Order bulkOrder = standardOrderBuilder() .size(\u0026#34;items\u0026#34;, 10, 20) // Different configuration for this test .set(\u0026#34;totalAmount\u0026#34;, Arbitraries.integers().between(500, 1000)) .sample(); Customer vipCustomer = premiumCustomerBuilder() .set(\u0026#34;membershipYears\u0026#34;, 10) // Different configuration for this test .set(\u0026#34;vipStatus\u0026#34;, true) .sample(); OrderResult result = orderService.processWithSpecialDiscount(bulkOrder, vipCustomer); assertThat(result.getDiscount()).isGreaterThanOrEqualTo(bulkOrder.getTotalAmount() * 0.2); } @Test fun testOrderProcessing() { // Helper methods returning ArbitraryBuilder for more flexibility val standardOrder = standardOrderBuilder() .setExpGetter(Order::getCustomerNote, \u0026#34;Please deliver quickly\u0026#34;) // Test-specific customization .sample() val premiumCustomer = premiumCustomerBuilder() .setExpGetter(Customer::getMembershipYears, 5) // Test-specific customization .sample() val result = orderService.process(standardOrder, premiumCustomer) assertThat(result.hasDiscount()).isTrue() assertThat(result.discount).isGreaterThanOrEqualTo(standardOrder.totalAmount * 0.1) } // Helper methods return ArbitraryBuilder instead of instances private fun standardOrderBuilder(): ArbitraryBuilder\u0026lt;Order\u0026gt; { return fixtureMonkey.giveMeBuilder\u0026lt;Order\u0026gt;() .setExpSize(Order::getItems, 3, 5) .setExpGetter(Order::getTotalAmount, Arbitraries.integers().between(100, 500)) } private fun premiumCustomerBuilder(): ArbitraryBuilder\u0026lt;Customer\u0026gt; { return fixtureMonkey.giveMeBuilder\u0026lt;Customer\u0026gt;() .setExpGetter(Customer::isPremiumMember, true) .setExpGetter(Customer::getMembershipYears, 2) } @Test fun testOrderWithSpecialDiscount() { // Reuse the same builder with different customizations val bulkOrder = standardOrderBuilder() .setExpSize(Order::getItems, 10, 20) // Different configuration for this test .setExpGetter(Order::getTotalAmount, Arbitraries.integers().between(500, 1000)) .sample() val vipCustomer = premiumCustomerBuilder() .setExpGetter(Customer::getMembershipYears, 10) // Different configuration for this test .setExpGetter(Customer::isVipStatus, true) .sample() val result = orderService.processWithSpecialDiscount(bulkOrder, vipCustomer) assertThat(result.discount).isGreaterThanOrEqualTo(bulkOrder.totalAmount * 0.2) } 5. Configure Once, Reuse Everywhere # Create specialized fixture configurations: Define common configurations once and reuse them. Java Kotlin // Define common configurations public class TestFixtures { public static final FixtureMonkey TEST_FIXTURE_MONKEY = FixtureMonkey.builder() .nullInject(0.0) // No null values .build(); public static ArbitraryBuilder\u0026lt;User\u0026gt; validUser() { return TEST_FIXTURE_MONKEY.giveMeBuilder(User.class) .set(\u0026#34;email\u0026#34;, \u0026#34;test@example.com\u0026#34;) .set(\u0026#34;active\u0026#34;, true); } } // Use in tests @Test void testUserRegistration() { User user = TestFixtures.validUser().sample(); userService.register(user); assertThat(userRepository.findByEmail(user.getEmail())).isNotNull(); } // Define common configurations object TestFixtures { val TEST_FIXTURE_MONKEY = FixtureMonkey.builder() .nullInject(0.0) // No null values .build() fun validUser(): ArbitraryBuilder\u0026lt;User\u0026gt; { return TEST_FIXTURE_MONKEY.giveMeBuilder\u0026lt;User\u0026gt;() .setExpGetter(User::getEmail, \u0026#34;test@example.com\u0026#34;) .setExpGetter(User::isActive, true) } } // Use in tests @Test fun testUserRegistration() { val user = TestFixtures.validUser().sample() userService.register(user) assertThat(userRepository.findByEmail(user.email)).isNotNull() } 6. Test Edge Cases and Boundary Conditions # Generate test cases with boundary values: Test min/max values and edge cases. Java Kotlin @Test void testUnderageUserCannotAccessAdultContent() { // Test with underage user User underage = fixtureMonkey.giveMeBuilder(User.class) .set(\u0026#34;age\u0026#34;, 17) // Just below legal age .sample(); assertThat(userService.canAccessAdultContent(underage)).isFalse(); } @Test void testOfAgeUserCanAccessAdultContent() { // Test with exactly of-age user User ofAge = fixtureMonkey.giveMeBuilder(User.class) .set(\u0026#34;age\u0026#34;, 18) // Exactly legal age .sample(); assertThat(userService.canAccessAdultContent(ofAge)).isTrue(); } @Test fun testUnderageUserCannotAccessAdultContent() { // Test with underage user val underage = fixtureMonkey.giveMeBuilder\u0026lt;User\u0026gt;() .setExpGetter(User::getAge, 17) // Just below legal age .sample() assertThat(userService.canAccessAdultContent(underage)).isFalse() } @Test fun testOfAgeUserCanAccessAdultContent() { // Test with exactly of-age user val ofAge = fixtureMonkey.giveMeBuilder\u0026lt;User\u0026gt;() .setExpGetter(User::getAge, 18) // Exactly legal age .sample() assertThat(userService.canAccessAdultContent(ofAge)).isTrue() } 7. Make Tests Reproducible # Use a fixed seed for tests that need reproducibility: This ensures consistent test results. Java Kotlin @Test @Seed(123L) // Makes the test reproducible void testComplexBehavior() { List\u0026lt;Order\u0026gt; orders = fixtureMonkey.giveMe(Order.class, 100); OrderSummary summary = orderService.summarize(orders); assertThat(summary.getTotalAmount()).isGreaterThan(0); } @Test @Seed(123L) // Makes the test reproducible fun testComplexBehavior() { val orders = fixtureMonkey.giveMe\u0026lt;Order\u0026gt;(100) val summary = orderService.summarize(orders) assertThat(summary.totalAmount).isGreaterThan(0) } 8. Define Type-Specific Generation Rules # Register custom rules for specific types: Define how types should be generated consistently across all tests. When to use: Use this approach when you need to control how a specific type is generated everywhere it appears in your tests. Java Kotlin // Create custom Fixture Monkey with type-specific generation rules FixtureMonkey fixtureMonkey = FixtureMonkey.builder() // Register a custom value for a simple type .register(String.class, it -\u0026gt; it.giveMeBuilder(\u0026#34;custom-string\u0026#34;)) // Register a custom rule for Email type // This affects ALL Email instances created by this fixture monkey .register(Email.class, fixture -\u0026gt; fixture.giveMeBuilder(new Email(\u0026#34;test@example.com\u0026#34;))) // Register a custom rule for a complex type with validation // Applies these rules whenever User instances are created .register(User.class, fixture -\u0026gt; fixture .setPostCondition(user -\u0026gt; user.getAge() \u0026gt;= 18) .set(\u0026#34;status\u0026#34;, \u0026#34;ACTIVE\u0026#34;)) // Register a factory method for a type .register(Product.class, fixture -\u0026gt; fixture .instantiate(factoryMethod(\u0026#34;createDefault\u0026#34;) .parameter(String.class, \u0026#34;productName\u0026#34;)) .set(\u0026#34;productName\u0026#34;, \u0026#34;Standard Product\u0026#34;)) .build(); // Using the custom registered instance String customString = fixtureMonkey.giveMeOne(String.class); // Returns \u0026#34;custom-string\u0026#34; Email email = fixtureMonkey.giveMeOne(Email.class); // Returns Email with \u0026#34;test@example.com\u0026#34; User user = fixtureMonkey.giveMeOne(User.class); // Returns an adult user with ACTIVE status // Create custom Fixture Monkey with type-specific generation rules val fixtureMonkey = FixtureMonkey.builder() // Register a custom value for a simple type .register(String::class.java) { it.giveMeBuilder(\u0026#34;custom-string\u0026#34;) } // Register a custom rule for Email type // This affects ALL Email instances created by this fixture monkey .register(Email::class.java) { fixture -\u0026gt; fixture.giveMeBuilder(Email(\u0026#34;test@example.com\u0026#34;)) } // Register a custom rule for a complex type with validation // Applies these rules whenever User instances are created .register(User::class.java) { fixture -\u0026gt; fixture .setPostCondition { user -\u0026gt; user.age \u0026gt;= 18 } .set(\u0026#34;status\u0026#34;, \u0026#34;ACTIVE\u0026#34;) } // Register a factory method for a type .register(Product::class.java) { fixture -\u0026gt; fixture .instantiate(factoryMethod(\u0026#34;createDefault\u0026#34;) .parameter(String::class.java, \u0026#34;productName\u0026#34;)) .set(\u0026#34;productName\u0026#34;, \u0026#34;Standard Product\u0026#34;) } .build() // Using the custom registered instance val customString = fixtureMonkey.giveMeOne\u0026lt;String\u0026gt;() // Returns \u0026#34;custom-string\u0026#34; val email = fixtureMonkey.giveMeOne\u0026lt;Email\u0026gt;() // Returns Email with \u0026#34;test@example.com\u0026#34; val user = fixtureMonkey.giveMeOne\u0026lt;User\u0026gt;() // Returns an adult user with ACTIVE status 9. Configure Field-Level Rules for Complex Objects # Define rules for individual fields within objects: Customize how individual properties are generated within complex objects. When to use: Use this approach when you need fine-grained control over individual fields within a complex object, applying different rules to different properties within the same class. Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() // Register rules for each field in a complex type // This provides field-by-field control, unlike the type-level register method .registerGroup(ProductDetails.class, group -\u0026gt; group // Each field can have its own specific generation rules .register(\u0026#34;name\u0026#34;, Arbitraries.strings().alpha().ofMinLength(3).ofMaxLength(50)) .register(\u0026#34;sku\u0026#34;, Arbitraries.strings().numeric().ofLength(10)) .register(\u0026#34;description\u0026#34;, Arbitraries.strings().ofMinLength(10).ofMaxLength(500)) .register(\u0026#34;inStock\u0026#34;, true) // Always in stock for tests .register(\u0026#34;price\u0026#34;, Arbitraries.doubles().between(1.0, 999.99)) .register(\u0026#34;weight\u0026#34;, Arbitraries.doubles().between(0.1, 100.0)) ) .build(); // The generated ProductDetails will have each field following its specific rule ProductDetails product = fixtureMonkey.giveMeOne(ProductDetails.class); // name - alphabetic string between 3-50 chars // sku - numeric string of exactly 10 chars // description - any string between 10-500 chars // inStock - always true // price - between 1.0 and 999.99 // weight - between 0.1 and 100.0 val fixtureMonkey = FixtureMonkey.builder() // Register rules for each field in a complex type // This provides field-by-field control, unlike the type-level register method .registerGroup(ProductDetails::class.java) { group -\u0026gt; group // Each field can have its own specific generation rules .register(\u0026#34;name\u0026#34;, Arbitraries.strings().alpha().ofMinLength(3).ofMaxLength(50)) .register(\u0026#34;sku\u0026#34;, Arbitraries.strings().numeric().ofLength(10)) .register(\u0026#34;description\u0026#34;, Arbitraries.strings().ofMinLength(10).ofMaxLength(500)) .register(\u0026#34;inStock\u0026#34;, true) // Always in stock for tests .register(\u0026#34;price\u0026#34;, Arbitraries.doubles().between(1.0, 999.99)) .register(\u0026#34;weight\u0026#34;, Arbitraries.doubles().between(0.1, 100.0)) } .build() // The generated ProductDetails will have each field following its specific rule val product = fixtureMonkey.giveMeOne\u0026lt;ProductDetails\u0026gt;() // name - alphabetic string between 3-50 chars // sku - numeric string of exactly 10 chars // description - any string between 10-500 chars // inStock - always true // price - between 1.0 and 999.99 // weight - between 0.1 and 100.0 `}),e.add({id:51,href:"/v1-1-0/docs/cheat-sheet/",title:"Cheat sheet",description:"",content:""}),e.add({id:52,href:"/v1-1-0/docs/cheat-sheet/faq/",title:"FAQ",description:`How do I get started with Fixture Monkey? # Fixture Monkey provides a simple way to create test objects with random values. Here\u0026rsquo;s how to get started:
Java Kotlin // Create a FixtureMonkey instance FixtureMonkey fixtureMonkey = FixtureMonkey.create(); // Generate a random object Person person = fixtureMonkey.giveMeOne(Person.class); // Create a FixtureMonkey instance val fixtureMonkey = FixtureMonkey.create() // Generate a random object val person = fixtureMonkey.giveMeOne\u0026lt;Person\u0026gt;() How do I add Fixture Monkey to my project?`,content:`How do I get started with Fixture Monkey? # Fixture Monkey provides a simple way to create test objects with random values. Here\u0026rsquo;s how to get started:
Java Kotlin // Create a FixtureMonkey instance FixtureMonkey fixtureMonkey = FixtureMonkey.create(); // Generate a random object Person person = fixtureMonkey.giveMeOne(Person.class); // Create a FixtureMonkey instance val fixtureMonkey = FixtureMonkey.create() // Generate a random object val person = fixtureMonkey.giveMeOne\u0026lt;Person\u0026gt;() How do I add Fixture Monkey to my project? # You can easily add Fixture Monkey to your Maven or Gradle project:
Gradle (Kotlin) Gradle (Groovy) Maven implementation(\u0026#34;com.navercorp.fixturemonkey:fixture-monkey:1.1.x\u0026#34;) implementation \u0026#39;com.navercorp.fixturemonkey:fixture-monkey:1.1.x\u0026#39; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.navercorp.fixturemonkey\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fixture-monkey\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.x\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; How do I specify values for certain fields while keeping others random? # You can use the set() method to specify values for specific fields:
Java Kotlin Person person = fixtureMonkey.giveMeBuilder(Person.class) .set(\u0026#34;name\u0026#34;, \u0026#34;John Doe\u0026#34;) .set(\u0026#34;age\u0026#34;, 25) .sample(); val person = fixtureMonkey.giveMeBuilder\u0026lt;Person\u0026gt;() .setExpGetter(Person::getName, \u0026#34;John Doe\u0026#34;) .setExpGetter(Person::getAge, 25) .sample() How do I control the size of collections like List, Set or Map? # You can control the size of collections using the size() method:
Java Kotlin Person person = fixtureMonkey.giveMeBuilder(Person.class) .size(\u0026#34;friends\u0026#34;, 5) // Sets the size of the friends list to 5 .sample(); // Setting a range for size Product product = fixtureMonkey.giveMeBuilder(Product.class) .size(\u0026#34;tags\u0026#34;, 2, 5) // The tags list will have between 2 and 5 elements .sample(); val person = fixtureMonkey.giveMeBuilder\u0026lt;Person\u0026gt;() .setExpSize(Person::getFriends, 5) // Sets the size of the friends list to 5 .sample() // Setting a range for size val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setExpSize(Product::getTags, 2, 5) // The tags list will have between 2 and 5 elements .sample() How do I handle null values? # You can control null probability using the nullInject option:
Java Kotlin // Create a FixtureMonkey with no null values FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .nullInject(0.0) // Set null probability to 0 .build(); // Create a FixtureMonkey with 50% null probability FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .nullInject(0.5) // Set null probability to 50% .build(); // Set a specific field to null Person person = fixtureMonkey.giveMeBuilder(Person.class) .set(\u0026#34;address\u0026#34;, null) .sample(); // Create a FixtureMonkey with no null values val fixtureMonkey = FixtureMonkey.builder() .nullInject(0.0) // Set null probability to 0 .build() // Create a FixtureMonkey with 50% null probability val fixtureMonkey = FixtureMonkey.builder() .nullInject(0.5) // Set null probability to 50% .build() // Set a specific field to null val person = fixtureMonkey.giveMeBuilder\u0026lt;Person\u0026gt;() .setExpGetter(Person::getAddress, null) .sample() How do I make my tests reproducible? # You can use a fixed seed to generate the same data across test runs:
Java Kotlin // Create a FixtureMonkey with a fixed seed FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .seed(123L) .build(); // Create a FixtureMonkey with a fixed seed val fixtureMonkey = FixtureMonkey.builder() .seed(123L) .build() With JUnit, you can also use the @Seed annotation:
Java Kotlin @Test @Seed(123L) void testWithSeed() { Person person = fixtureMonkey.giveMeOne(Person.class); // The same Person will be generated every time } @Test @Seed(123L) fun testWithSeed() { val person = fixtureMonkey.giveMeOne\u0026lt;Person\u0026gt;() // The same Person will be generated every time } How do I ensure generated objects satisfy certain conditions? # You can use setPostCondition() to filter generated objects that don\u0026rsquo;t meet your criteria:
Java Kotlin // Ensure the person is an adult Person adult = fixtureMonkey.giveMeBuilder(Person.class) .setPostCondition(person -\u0026gt; person.getAge() \u0026gt;= 18) .sample(); // Ensure a specific field meets a condition Product product = fixtureMonkey.giveMeBuilder(Product.class) .setPostCondition(\u0026#34;price\u0026#34;, Double.class, price -\u0026gt; price \u0026gt; 0 \u0026amp;\u0026amp; price \u0026lt; 1000) .sample(); // Ensure the person is an adult val adult = fixtureMonkey.giveMeBuilder\u0026lt;Person\u0026gt;() .setPostCondition { it.age \u0026gt;= 18 } .sample() // Ensure a specific field meets a condition val product = fixtureMonkey.giveMeBuilder\u0026lt;Product\u0026gt;() .setPostConditionExpGetter(Product::getPrice, Double::class.java) { it \u0026gt; 0 \u0026amp;\u0026amp; it \u0026lt; 1000 } .sample() How can I exclude certain values from being generated? # You can use set() with a filter to exclude certain values:
Java Kotlin Product product = sut.giveMeBuilder(Product.class) .set(\u0026#34;productType\u0026#34;, ArbitraryUtils.toCombinableArbitrary(Arbitraries.of(ProductType)).filter(it -\u0026gt; it != CLOTHING \u0026amp;\u0026amp; it != ELECTRONICS)) .sample(); val product = sut.giveMeBuilder\u0026lt;Product\u0026gt;() .setExpGetter(Product::getProductType, ArbitraryUtils.toCombinableArbitrary(Arbitraries.of(ProductType::class.java)).filter { it != ProductType.CLOTHING \u0026amp;\u0026amp; it != ProductType.ELECTRONICS }) .sample() Or you can use setPostCondition() which works like a filter:
Java Kotlin Product product = sut.giveMeBuilder(Product.class) .setPostCondition(\u0026#34;productType\u0026#34;, ProductType.class, it -\u0026gt; it != CLOTHING \u0026amp;\u0026amp; it != ELECTRONICS) .sample(); val product = sut.giveMeBuilder\u0026lt;Product\u0026gt;() .setPostConditionExpGetter(Product::getProductType, ProductType::class.java) { it != ProductType.CLOTHING \u0026amp;\u0026amp; it != ProductType.ELECTRONICS } .sample() Please note that using setPostCondition() can incur higher costs for narrow conditions because it filters after the Product instance has been created. In such cases, it\u0026rsquo;s recommended to use set() instead.
How do I handle nested objects? # Fixture Monkey automatically generates nested objects. You can customize them using a property path:
Java Kotlin Order order = fixtureMonkey.giveMeBuilder(Order.class) .set(\u0026#34;customer.name\u0026#34;, \u0026#34;John Doe\u0026#34;) .set(\u0026#34;customer.address.city\u0026#34;, \u0026#34;New York\u0026#34;) .size(\u0026#34;items\u0026#34;, 3) .set(\u0026#34;items[0].productName\u0026#34;, \u0026#34;Laptop\u0026#34;) .sample(); val order = fixtureMonkey.giveMeBuilder\u0026lt;Order\u0026gt;() .setExp(\u0026#34;customer.name\u0026#34;, \u0026#34;John Doe\u0026#34;) .setExp(\u0026#34;customer.address.city\u0026#34;, \u0026#34;New York\u0026#34;) .sizeExp(\u0026#34;items\u0026#34;, 3) .setExp(\u0026#34;items[0].productName\u0026#34;, \u0026#34;Laptop\u0026#34;) .sample() One of my fields depends on the value of another field. How can I customize my fixture? # The thenApply() method comes in handy when you need to customize a field that relies on another field:
Java Kotlin Money money = fixtureMonkey.giveMeBuilder(Money.class) .set(\u0026#34;currency\u0026#34;, Currency.getInstance(\u0026#34;USD\u0026#34;)) .thenApply((m, builder) -\u0026gt; builder.set(\u0026#34;amount\u0026#34;, m.getCurrency().equals(Currency.getInstance(\u0026#34;USD\u0026#34;)) ? 100.0 : 120.0)) .sample(); val money = fixtureMonkey.giveMeBuilder\u0026lt;Money\u0026gt;() .setExpGetter(Money::getCurrency, Currency.getInstance(\u0026#34;USD\u0026#34;)) .thenApply { money, builder -\u0026gt; builder.setExpGetter(Money::getAmount, if (money.currency == Currency.getInstance(\u0026#34;USD\u0026#34;)) 100.0 else 120.0) } .sample() For more information, check the thenApply() section.
How can I limit the range of characters for my generated Strings? # Related - How can I constrain the range of my generated Instant values?
If you want each generated primitive type to adhere to specific constraints, you can use the javaTypeArbitaryGenerator and javaTimeTypeArbitraryGenerator options.
Java Kotlin // Configure String generation with specific character ranges FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .javaTypeArbitraryGenerator(new JavaTypeArbitraryGenerator() { @Override public StringArbitrary strings() { return Arbitraries.strings().alpha().ofLength(5, 10); } }) .build(); // Configure time generation with specific ranges FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .javaTimeTypeArbitraryGenerator(new JavaTimeTypeArbitraryGenerator() { @Override public Arbitrary\u0026lt;Instant\u0026gt; instant() { Instant start = Instant.parse(\u0026#34;2023-01-01T00:00:00Z\u0026#34;); Instant end = Instant.parse(\u0026#34;2023-12-31T23:59:59Z\u0026#34;); return Arbitraries.instants().between(start, end); } }) .build(); // Configure String generation with specific character ranges val fixtureMonkey = FixtureMonkey.builder() .javaTypeArbitraryGenerator(object : JavaTypeArbitraryGenerator() { override fun strings(): StringArbitrary { return Arbitraries.strings().alpha().ofLength(5, 10) } }) .build() // Configure time generation with specific ranges val fixtureMonkey = FixtureMonkey.builder() .javaTimeTypeArbitraryGenerator(object : JavaTimeTypeArbitraryGenerator() { override fun instant(): Arbitrary\u0026lt;Instant\u0026gt; { val start = Instant.parse(\u0026#34;2023-01-01T00:00:00Z\u0026#34;) val end = Instant.parse(\u0026#34;2023-12-31T23:59:59Z\u0026#34;) return Arbitraries.instants().between(start, end) } }) .build() Throws an exception when generating a certain type # If you encounter exceptions when generating certain types, try using PriorityConstructorArbitraryIntrospector:
Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .pushExactTypeArbitraryIntrospector(ProblematicType.class, PriorityConstructorArbitraryIntrospector.INSTANCE) .build(); // Now generation should work ProblematicType instance = fixtureMonkey.giveMeOne(ProblematicType.class); val fixtureMonkey = FixtureMonkey.builder() .pushExactTypeArbitraryIntrospector(ProblematicType::class.java, PriorityConstructorArbitraryIntrospector.INSTANCE) .build() // Now generation should work val instance = fixtureMonkey.giveMeOne\u0026lt;ProblematicType\u0026gt;() If it does not work, please try to make your own ArbitraryIntrospector or create an issue on GitHub and ask for help.
`}),e.add({id:53,href:"/v1-1-0/docs/migration-guide/",title:"Migration guide",description:"",content:""}),e.add({id:54,href:"/v1-1-0/docs/",title:"Docs",description:"",content:""}),search.addEventListener("input",t,!0);function t(){const s=4,o=300;var n=this.value,i=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of i.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[c,r]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href="/fixture-monkey"+c,n.appendChild(e);const i=document.createElement("span");i.textContent=r.title,i.classList.add("suggestion__title"),e.appendChild(i);const a=document.createElement("span");if(a.textContent=r.description.substring(0,o),a.classList.add("suggestion__description"),e.appendChild(a),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()
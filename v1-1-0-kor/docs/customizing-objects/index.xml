<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>객체 커스터마이징 on</title><link>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/</link><description>Recent content in 객체 커스터마이징 on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/index.xml" rel="self" type="application/rss+xml"/><item><title>커스터마이징 API</title><link>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/apis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/apis/</guid><description>Fixture Monkey는 ArbitraryBuilder를 통해 생성된 객체를 커스텀할 수 있는 다양한 API를 제공합니다.
픽스쳐 커스터마이징하기 # set() # set() 메서드는 표현식에 참조된 하나 이상의 프로퍼티에 값을 설정하는 데 사용됩니다.
Supplier, Arbitrary, ArbitraryBuilder, NOT_NULL, NULL, 또는 Just 를 포함한 다양한 타입을 값으로 설정할 수 있습니다. 또한 객체의 특정 인스턴스를 값으로 사용할 수도 있습니다.
Java Kotlin fixtureMonkey.giveMeBuilder(Product.class) .set(&amp;#34;id&amp;#34;, 1000); fixtureMonkey.giveMeBuilder&amp;lt;Product&amp;gt;() .setExp(Product::id, 1000) Just # set()을 사용할 때 Just로 래핑된 객체를 사용하면 인스턴스를 분해하지 않고 값을 직접 설정할 수 있습니다.</description></item><item><title>표현식</title><link>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/expressions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/expressions/</guid><description>Fixture Monkey를 사용할 때, Fixture Monkey 표현식을 사용하여 오브젝트의 프로퍼티를 하나 이상 유연하게 선택할 수 있습니다.
아래와 같은 예제 오브젝트가 있다고 가정해보겠습니다.
@Value public class JavaClass { String field; String[] array; List&amp;lt;String&amp;gt; list; Nested object; List&amp;lt;Nested&amp;gt; objectList; @Value public static class Nested { String nestedField; } } String Expressions을 통해 프로퍼티 선택하기 # root object 선택: # &amp;quot;$&amp;quot; 특정 필드 선택: # &amp;quot;field&amp;quot; nested 필드 선택: # &amp;quot;object.nestedField&amp;quot; 컬렉션의 n번째 요소 선택 # &amp;quot;list[n]&amp;quot; 컬렉션의 모든 요소 선택 # &amp;quot;list[*]&amp;quot; 배열의 n번째 요소 선택: # &amp;quot;array[n]&amp;quot; 배열의 모든 요소 선택: # &amp;quot;array[*]&amp;quot; 표현식을 결합하여 nested 필드 선택: # &amp;quot;objectList[0].</description></item><item><title>Arbitrary를 활용한 커스터마이징</title><link>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/arbitrary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/arbitrary/</guid><description>Jqwik은 JVM 환경에서 사용할 수 있는 프로퍼티 기반 테스트 라이브러리입니다. Fixture Monkey는 문자, 문자열, 정수 등의 기본 타입에 대한 랜덤 값을 생성하기 위해 Jqwik의 Arbitrary를 사용합니다.
Jqwik에서 Arbitrary는 생성(Generating) 및 축소(Shrinking)할 수 있는 객체를 나타내는 핵심 인터페이스입니다. 때때로 픽스처 프로퍼티가 특정 제약 조건을 준수하면서 랜덤 값을 가지도록 원할 수 있습니다.
이러한 경우에는 Fixture Monkey의 set() 메서드로 프로퍼티의 값을 Arbitrary로 할당하여 랜덤 값을 가지도록 할 수 있습니다. Jqwik의 Arbitraries 클래스의 정적 메서드를 호출하여 특정 조건을 충족하는 Arbitrary를 생성할 수 있습니다.</description></item><item><title>InnerSpec</title><link>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/innerspec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/innerspec/</guid><description>InnerSpec은 적용하려는 커스터마이징에 대한 타입 독립적인 명세입니다. ArbitraryBuilder 내의 setInner() 메서드를 사용하면 InnerSpec 인스턴스에 정의된 명세를 빌더에 적용할 수 있습니다.
InnerSpec 에는 커스터마이징 세부 정보가 저장되며 여러 ArbitraryBuilder에서 재사용할 수 있습니다. ArbitraryBuilder에서 픽스처 몽키 표현식을 사용하는 방식과 달리 InnerSpec은 중첩된 구조를 사용해 프로퍼티에 접근이 가능합니다.
InnerSpec 의 또 다른 장점은 일반적인 표현식과 달리 맵 프로퍼티를 커스터마이징할 수 있다는 점입니다.
💡 Kotlin EXP 는 InnerSpec에서 지원하지 않습니다. InnerSpec은 타입 독립적으로 설계되었기 때문에, 프로퍼티 이름을 통해 프로퍼티를 접근해야 합니다.</description></item><item><title>인터페이스 커스터마이징</title><link>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/interface/</guid><description>인터페이스에서 ArbitraryBuilder의 모든 API를 사용할 수 있습니다. 우리는 이미 Generating Interface Type 에서 API를 사용한 예를 확인했었습니다. 알아본 내용을 복습하면, 인터페이스의 종류에는 interface, generic interface ,selaed interface이 있습니다. 인터페이스의 종류와 상관없이 모든 인터페이스의 프로퍼티를 제어할 수 있습니다.
public interface StringSupplier { String getValue(); } FixtureMonkey fixture = FixtureMonkey.create(); String result = fixture.giveMeBuilder(StringSupplier.class) .set(&amp;quot;value&amp;quot;, &amp;quot;fix&amp;quot;) .sample() .getValue(); 인터페이스를 생성하는 ArbitraryBuilder가 제어할 수 있는 프로퍼티는 실제로 생성한 구현체마다 다릅니다. 하지만 아직은 구현체를 선택할 수 있는 ArbitraryBuilder API가 존재하지 않습니다.</description></item></channel></rss>
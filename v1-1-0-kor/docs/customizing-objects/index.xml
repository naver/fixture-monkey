<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>객체 커스터마이징 on</title><link>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/</link><description>Recent content in 객체 커스터마이징 on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/index.xml" rel="self" type="application/rss+xml"/><item><title>빠른 시작 가이드</title><link>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/quick-start-guide/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/quick-start-guide/</guid><description>학습 내용 # Fixture Monkey로 테스트 객체를 커스터마이징하는 핵심 방법 단순하고 복잡한 객체를 커스터마이징하는 기본 접근법 초보자가 자주 겪는 문제의 해결책 5분 빠른 시작 # 이 섹션은 Fixture Monkey를 시작하는 데 필요한 핵심 정보만 다룹니다.
꼭 알아야 할 4가지 핵심 메서드 # 시간이 없다면, 지금 꼭 알아야 할 내용은 다음과 같습니다:
Java Kotlin // 1. FixtureMonkey 인스턴스 생성 FixtureMonkey fixtureMonkey = FixtureMonkey.create(); // 2. 특정 속성 값으로 상품 생성 Product product = fixtureMonkey.</description></item><item><title>경로 표현식</title><link>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/path-expressions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/path-expressions/</guid><description>이 문서에서 배우는 내용 # 테스트 객체의 특정 필드나 속성을 선택하는 방법 문자열 표현식을 사용하여 객체의 특정 부분을 참조하는 방법 중첩된 객체, 배열, 리스트 등 다양한 구조의 속성에 접근하는 방법 경로 표현식 소개 # 테스트를 작성할 때는 테스트 객체의 특정 필드를 수정해야 하는 경우가 많습니다. Fixture Monkey의 경로 표현식은 GPS 좌표와 같이 테스트 객체의 어떤 부분이든 정확하게 찾아 수정할 수 있게 도와주는 도구입니다.
초보자라면 경로 표현식을 객체 구조를 &amp;ldquo;탐색&amp;quot;하여 변경하고 싶은 필드에 정확히 도달하는 방법이라고 생각하면 됩니다.</description></item><item><title>커스터마이징 API</title><link>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/apis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/apis/</guid><description>이 문서에서 배우는 내용 # 테스트에 필요한 데이터를 쉽게 만드는 방법 원하는 값을 가진 객체를 자유롭게 생성하는 방법 실제 테스트에서 자주 필요한 데이터 생성 방법 시작하기 전에 # 이 문서에서는 테스트 데이터를 쉽게 만들 수 있는 다양한 방법을 배웁니다. 예를 들어 다음과 같은 상황에서 Fixture Monkey API를 활용할 수 있습니다:
회원가입 테스트를 위해 특정 나이대의 회원 데이터가 필요할 때 주문 테스트를 위해 여러 개의 상품이 담긴 장바구니가 필요할 때 결제 테스트를 위해 특정 금액 이상의 주문이 필요할 때 알아두면 좋은 용어 # 샘플링(sampling): 테스트용 데이터를 실제로 만드는 것을 의미합니다.</description></item><item><title>조건을 만족하는 랜덤 테스트 데이터 만들기</title><link>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/arbitrary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/arbitrary/</guid><description>이 문서에서 배우는 내용 # 랜덤하지만 규칙을 따르는 테스트 데이터 만들기 숫자 범위, 문자열 패턴, 값 목록 등의 제약조건 설정 방법 고정 값 대신 랜덤 값을 사용해야 하는 상황과 이유 랜덤 테스트 데이터 소개 # 테스트에서 항상 고정된 값만 사용하는 것은 충분하지 않을 수 있습니다. 다음과 같은 상황에서는 랜덤 값이 필요합니다:
단일 값이 아닌 유효한 입력값 범위로 테스트 테스트가 실행될 때마다 다른 테스트 데이터 사용 비즈니스 규칙을 따르는 현실적이지만 다양한 데이터 예를 들어, 다음과 같은 테스트 상황에서 유용합니다:</description></item><item><title>인터페이스 테스트하기</title><link>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/interface/</guid><description>이 문서에서 배울 내용 # 인터페이스에 대한 테스트 데이터를 생성하는 방법 어떤 구현체를 사용할지 지정하는 방법 인터페이스 구현체의 속성을 커스터마이징하는 방법 다양한 인터페이스 테스팅 접근법 중 선택하는 방법 인터페이스 테스팅의 중요성 # 이 섹션에서는 소프트웨어 개발에서 인터페이스가 왜 중요한지, 그리고 왜 인터페이스 테스팅이 가치있는지 배웁니다.
인터페이스는 현대 소프트웨어 개발에서 다음과 같은 여러 중요한 이유로 필수적인 역할을 합니다:
실제 애플리케이션에서 인터페이스가 중요한 이유 # 느슨한 결합(Loose Coupling): 인터페이스는 컴포넌트들이 서로의 내부 세부사항을 알 필요 없이 계약을 맺을 수 있게 합니다.</description></item><item><title>InnerSpec</title><link>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/innerspec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/innerspec/</guid><description>이 문서에서 배우는 내용 # 복잡한 객체 구조를 더 세밀하게 커스터마이징하는 방법 맵(Map) 타입의 속성을 효과적으로 다루는 방법 재사용 가능한 커스터마이징 명세를 작성하는 방법 InnerSpec 소개 # 이 섹션에서는 InnerSpec의 기본 개념과 복잡한 객체를 커스터마이징할 때 왜 유용한지 배우게 됩니다.
이전 문서들에서 기본적인 속성 변경 방법을 배웠다면, 이제 더 복잡한 객체 구조를 다루는 방법을 배워보겠습니다.
InnerSpec이란 무엇이고 왜 사용하나요? # InnerSpec은 픽스처 몽키에서 복잡한 중첩 객체를 구조화된 방식으로 커스터마이징하는데 도움을 주는 강력한 도구입니다.</description></item><item><title>이름을 통한 연산 등록</title><link>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/registerbyname/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/customizing-objects/registerbyname/</guid><description>registerByName와 selectName 기능을 사용하면 특정 이름으로 연산을 정의하고 재사용할 수 있습니다. 이 기능은 테스트 전반에서 설정을 체계적으로 관리하고 재활용할 수 있는 강력한 방법을 제공합니다.
이름으로 연산 등록하기 # registerByName 메서드를 사용해 특정 이름으로 연산을 등록할 수 있습니다:
FixtureMonkey fixtureMonkey = FixtureMonkey.builder() .registerByName( &amp;quot;test&amp;quot;, String.class, monkey -&amp;gt; monkey.giveMeBuilder(&amp;quot;foo&amp;quot;) ) .build(); selectName으로 연산 적용하기 # 등록된 이름 기반 연산은 selectName을 통해 특정 속성에 적용할 수 있습니다:
SimpleObject actual = sut.giveMeBuilder(SimpleObject.class) .selectName(&amp;quot;test&amp;quot;) .sample(); // SimpleObject의 String 속성이 &amp;quot;foo&amp;quot;로 설정됩니다.</description></item></channel></rss>
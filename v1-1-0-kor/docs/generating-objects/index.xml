<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>객체 생성 on</title><link>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/generating-objects/</link><description>Recent content in 객체 생성 on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/generating-objects/index.xml" rel="self" type="application/rss+xml"/><item><title>FixtureMonkey</title><link>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/generating-objects/fixture-monkey/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/generating-objects/fixture-monkey/</guid><description>테스트 픽스처를 생성하기 위해서는 우선 FixtureMonkey 인스턴스를 생성해야 합니다. 해당 인스턴스는 테스트 픽스쳐 생성을 담당합니다.
FixtureMonkey 인스턴스를 생성하기 위해서는 create() 메서드를 사용하면 됩니다. Kotlin 환경에서는 Kotlin 플러그인을 추가해야 합니다.
Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.create(); val fixtureMonkey = FixtureMonkey .plugin(KotlinPlugin()) .build() 테스트 픽스처를 생성하거나 커스텀하기 위해서는 FixtureMonkey 빌더를 사용하여 옵션을 추가할 수 있습니다.
Java Kotlin FixtureMonkey fixtureMonkey = FixtureMonkey.builder() + options... .build(); val fixtureMonkey = FixtureMonkey.builder() + options... .build() 어떤 옵션을 사용할 수 있는지에 대한 정보는 Fixture Monkey 옵션 항목을 참고해주세요.</description></item><item><title>객체 생성 방법 지정하기</title><link>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/generating-objects/instantiate-methods/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/generating-objects/instantiate-methods/</guid><description>각 테스트마다 객체 생성을 다르게 하고 싶을 수 있습니다. 예를 들어, 같은 클래스에서도 첫 테스트에서는 생성자로 객체를 생성하고, 다른 테스트에서는 팩터리 메서드로 객체를 생성하고 싶을 수 있습니다
Fixture Monkey는 instantiate() 메서드를 제공해 객체 생성 방법을 선택할 수 있게 합니다. 💡 Kotlin Plugin을 추가한다면 커스텀 DSL에서 instantiateBy() 메서드를 사용할 수 있습니다. ArbitraryBuilder에서 원하는 인스턴스 생성 방법(생성자 또는 팩토리 메서드)으로 객체를 생성할 수 있습니다.
ArbitraryBuilder를 사용할 때마다 매번 객체 생성 방법을 지정해야 하는 것은 아닙니다.</description></item><item><title>복잡한 객체 생성하기</title><link>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/generating-objects/generating-complex-types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/generating-objects/generating-complex-types/</guid><description>Fixture Monkey는 직접 생성하기 어려운 복잡한 객체도 테스트 픽스처로 쉽게 생성할 수 있습니다.
이 페이지는 생성할 수 있는 다양한 타입의 객체를 보여줍니다.
Java # Generic Objects # @Value public static class GenericObject&amp;lt;T&amp;gt; { T foo; } @Value public static class GenericArrayObject&amp;lt;T&amp;gt; { GenericObject&amp;lt;T&amp;gt;[] foo; } @Value public static class TwoGenericObject&amp;lt;T, U&amp;gt; { T foo; U bar; } @Value public static class ThreeGenericObject&amp;lt;T, U, V&amp;gt; { T foo; U bar; V baz; } Generic Interfaces # public interface GenericInterface&amp;lt;T&amp;gt; { } @Value public static class GenericInterfaceImpl&amp;lt;T&amp;gt; implements GenericInterface&amp;lt;T&amp;gt; { T foo; } public interface TwoGenericInterface&amp;lt;T, U&amp;gt; { } @Value public static class TwoGenericImpl&amp;lt;T, U&amp;gt; implements TwoGenericInterface&amp;lt;T, U&amp;gt; { T foo; U bar; } SelfReference # @Value public class SelfReference { String foo; SelfReference bar; } @Value public class SelfReferenceList { String foo; List&amp;lt;SelfReferenceList&amp;gt; bar; } Interface # public interface Interface { String foo(); Integer bar(); } public interface InheritedInterface extends Interface { String foo(); } public interface InheritedInterfaceWithSameNameMethod extends Interface { String foo(); } public interface ContainerInterface { List&amp;lt;String&amp;gt; baz(); Map&amp;lt;String, Integer&amp;gt; qux(); } public interface InheritedTwoInterface extends Interface, ContainerInterface { } Kotlin # Generic Objects # class Generic&amp;lt;T&amp;gt;(val foo: T) class GenericImpl(val foo: Generic&amp;lt;String&amp;gt;) SelfReference # class SelfReference(val foo: String, val bar: SelfReference?</description></item><item><title>Introspector</title><link>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/generating-objects/introspector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/generating-objects/introspector/</guid><description>instantiate를 사용하여 ArbitraryBuilder에서 객체를 생성하는 방법을 변경할 수 있지만, 옵션을 통해 전역적으로도 객체 생성 방법을 지정할 수 있습니다. Fixture Monkey는 다양한 Introspector로 객체를 생성하는 방법을 제공합니다.
Introspector는 Fixture Monkey가 객체를 생성하는 기본 방법을 정의합니다. 각 introspector는 클래스의 인스턴스를 생성할 수 있는 몇 가지 제약 조건이 있습니다.
사용하려는 introspector를 FixtureMonkey의 objectIntrospector 옵션을 사용하여 변경할 수 있습니다.
BeanArbitraryIntrospector # BeanArbitraryIntrospector는 Fixture Monkey가 객체 생성에 사용하는 기본 introspector입니다. 리플렉션과 setter 메서드를 사용하여 새 인스턴스를 생성하므로 생성할 클래스에는 인자가 없는 생성자(또는 기본생성자)와 setter가 있어야 합니다.</description></item><item><title>인터페이스 생성하기</title><link>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/generating-objects/generating-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naver.github.io/fixture-monkey/v1-1-0-kor/docs/generating-objects/generating-interface/</guid><description>Fixture Monkey는 복잡한 인터페이스 객체를 생성할 수 있습니다. 생성하는 인터페이스 종류는 다음 세 가지로 분류할 수 있습니다. interface, generic interface, sealed interface.
Fixture Monkey에서 기본적으로 구현체를 정의해둔 인터페이스가 있습니다. 예를 들면, List 인터페이스는 ArrayList, Set 인터페이스는 HashSet 를 생성합니다.
그 외의 인터페이스는 모두 구현체를 명시해주어야 합니다. 명시하지 않으면 Fixture Monkey는 인터페이스의 익명 객체를 생성합니다. 예외적으로 sealed interface를 생성할 때는 구현체를 명시할 필요 없습니다.
인터페이스를 어떻게 생성하는지 자세한 예제를 보면서 알아보겠습니다.</description></item></channel></rss>